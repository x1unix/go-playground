package packagedb

import (
	"io/fs"
	"syscall"

	"github.com/x1unix/go-playground/internal/gorepl/pacman"
	"github.com/x1unix/go-playground/internal/gowasm"
	"github.com/x1unix/go-playground/internal/gowasm/wlog"
	"golang.org/x/mod/module"
)

var _ pacman.PackageIndex = (*PackageIndex)(nil)

// maxPackageVersionLength is theoretical max length of package version string.
//
// This value is based on length of untagged version string for legacy packages
// generated by go.mod.
//
// Example: v2.0.4-0.20190803094908-fe8645b0a904+incompatible
const maxPackageVersionLength = 50

// PackageIndex is pacman.PackageIndex implementation to communicate
// with IndexDB-based package registry on browser side.
type PackageIndex struct{}

func NewPackageIndex() PackageIndex {
	return PackageIndex{}
}

func (p PackageIndex) LookupPackage(pkgName string) (*module.Version, error) {
	wlog.Debugln("LookupPackage: ", pkgName)
	cb := gowasm.RequestCallback()
	defer gowasm.ReleaseCallback(cb)

	// Since JS host can't access Go memory allocator,
	// preallocate enough memory for result.
	buff := make([]byte, 0, maxPackageVersionLength)
	go lookupPackage(pkgName, &buff, cb)

	err := gowasm.AwaitCallback(cb)
	if err == syscall.ENOENT {
		return nil, fs.ErrNotExist
	}

	if err != nil {
		return nil, err
	}

	return &module.Version{
		Path:    pkgName,
		Version: string(buff),
	}, nil
}

func (p PackageIndex) RegisterPackage(pkg *module.Version) error {
	wlog.Debugln("RegisterPackage: ", pkg)
	cb := gowasm.RequestCallback()
	defer gowasm.ReleaseCallback(cb)

	go registerPackage(pkg.Path, pkg.Version, cb)
	if err := gowasm.AwaitCallback(cb); err != nil {
		return err
	}

	return nil
}

func (p PackageIndex) RemovePackage(pkg *module.Version) error {
	wlog.Debugln("RemovePackage: ", pkg)
	cb := gowasm.RequestCallback()
	defer gowasm.ReleaseCallback(cb)

	go removePackage(pkg.Path, cb)
	if err := gowasm.AwaitCallback(cb); err != nil {
		return err
	}

	return nil
}
