[
  {
    "name": "archive",
    "synopsis": "",
    "url": "https://pkg.go.dev/archive",
    "path": "archive",
    "children": [
      {
        "name": "tar",
        "synopsis": "Package tar implements access to tar archives.\n\nTape archives (tar) are a file format for storing a sequence of files that\ncan be read and written in a streaming manner.\nThis package aims to cover most variations of the format,\nincluding those produced by GNU and BSD tar tools.\n\n[\"archive/tar\" on pkg.go.dev](https://pkg.go.dev/archive/tar)",
        "url": "https://pkg.go.dev/archive/tar",
        "path": "archive/tar",
        "children": []
      },
      {
        "name": "zip",
        "synopsis": "Package zip provides support for reading and writing ZIP archives.\n\nSee: https://www.pkware.com/appnote\n\nThis package does not support disk spanning.\n\nA note about ZIP64:\n\nTo be backwards compatible the FileHeader has both 32 and 64 bit Size\nfields. The 64 bit fields will always contain the correct value and\nfor normal archives both fields will be the same. For files requiring\nthe ZIP64 format the 32 bit fields will be 0xffffffff and the 64 bit\nfields must be used instead.\n\n[\"archive/zip\" on pkg.go.dev](https://pkg.go.dev/archive/zip)",
        "url": "https://pkg.go.dev/archive/zip",
        "path": "archive/zip",
        "children": []
      }
    ]
  },
  {
    "name": "bufio",
    "synopsis": "Package bufio implements buffered I/O. It wraps an io.Reader or io.Writer\nobject, creating another object (Reader or Writer) that also implements\nthe interface but provides buffering and some help for textual I/O.\n\n[\"bufio\" on pkg.go.dev](https://pkg.go.dev/bufio)",
    "url": "https://pkg.go.dev/bufio",
    "path": "bufio",
    "children": []
  },
  {
    "name": "builtin",
    "synopsis": "Package builtin provides documentation for Go's predeclared identifiers.\nThe items documented here are not actually in package builtin\nbut their descriptions here allow godoc to present documentation\nfor the language's special identifiers.\n\n[\"builtin\" on pkg.go.dev](https://pkg.go.dev/builtin)",
    "url": "https://pkg.go.dev/builtin",
    "path": "builtin",
    "children": []
  },
  {
    "name": "bytes",
    "synopsis": "Package bytes implements functions for the manipulation of byte slices.\nIt is analogous to the facilities of the strings package.\n\n[\"bytes\" on pkg.go.dev](https://pkg.go.dev/bytes)",
    "url": "https://pkg.go.dev/bytes",
    "path": "bytes",
    "children": []
  },
  {
    "name": "compress",
    "synopsis": "",
    "url": "https://pkg.go.dev/compress",
    "path": "compress",
    "children": [
      {
        "name": "bzip2",
        "synopsis": "Package bzip2 implements bzip2 decompression.\n\n[\"compress/bzip2\" on pkg.go.dev](https://pkg.go.dev/compress/bzip2)",
        "url": "https://pkg.go.dev/compress/bzip2",
        "path": "compress/bzip2",
        "children": []
      },
      {
        "name": "flate",
        "synopsis": "Package flate implements the DEFLATE compressed data format, described in\nRFC 1951.  The gzip and zlib packages implement access to DEFLATE-based file\nformats.\n\n[\"compress/flate\" on pkg.go.dev](https://pkg.go.dev/compress/flate)",
        "url": "https://pkg.go.dev/compress/flate",
        "path": "compress/flate",
        "children": []
      },
      {
        "name": "gzip",
        "synopsis": "Package gzip implements reading and writing of gzip format compressed files,\nas specified in RFC 1952.\n\n[\"compress/gzip\" on pkg.go.dev](https://pkg.go.dev/compress/gzip)",
        "url": "https://pkg.go.dev/compress/gzip",
        "path": "compress/gzip",
        "children": []
      },
      {
        "name": "lzw",
        "synopsis": "Package lzw implements the Lempel-Ziv-Welch compressed data format,\ndescribed in T. A. Welch, ``A Technique for High-Performance Data\nCompression'', Computer, 17(6) (June 1984), pp 8-19.\n\nIn particular, it implements LZW as used by the GIF and PDF file\nformats, which means variable-width codes up to 12 bits and the first\ntwo non-literal codes are a clear code and an EOF code.\n\nThe TIFF file format uses a similar but incompatible version of the LZW\nalgorithm. See the golang.org/x/image/tiff/lzw package for an\nimplementation.\n\n[\"compress/lzw\" on pkg.go.dev](https://pkg.go.dev/compress/lzw)",
        "url": "https://pkg.go.dev/compress/lzw",
        "path": "compress/lzw",
        "children": []
      },
      {
        "name": "zlib",
        "synopsis": "Package zlib implements reading and writing of zlib format compressed data,\nas specified in RFC 1950.\n\nThe implementation provides filters that uncompress during reading\nand compress during writing.  For example, to write compressed data\nto a buffer:\n\n```\nvar b bytes.Buffer\nw := zlib.NewWriter(\u0026b)\nw.Write([]byte(\"hello, world\\n\"))\nw.Close()\n\n```\nand to read that data back:\n\n```\nr, err := zlib.NewReader(\u0026b)\nio.Copy(os.Stdout, r)\nr.Close()\n\n[\"compress/zlib\" on pkg.go.dev](https://pkg.go.dev/compress/zlib)",
        "url": "https://pkg.go.dev/compress/zlib",
        "path": "compress/zlib",
        "children": []
      }
    ]
  },
  {
    "name": "container",
    "synopsis": "",
    "url": "https://pkg.go.dev/container",
    "path": "container",
    "children": [
      {
        "name": "heap",
        "synopsis": "Package heap provides heap operations for any type that implements\nheap.Interface. A heap is a tree with the property that each node is the\nminimum-valued node in its subtree.\n\nThe minimum element in the tree is the root, at index 0.\n\nA heap is a common way to implement a priority queue. To build a priority\nqueue, implement the Heap interface with the (negative) priority as the\nordering for the Less method, so Push adds items while Pop removes the\nhighest-priority item from the queue. The Examples include such an\nimplementation; the file example_pq_test.go has the complete source.\n\n[\"container/heap\" on pkg.go.dev](https://pkg.go.dev/container/heap)",
        "url": "https://pkg.go.dev/container/heap",
        "path": "container/heap",
        "children": []
      },
      {
        "name": "list",
        "synopsis": "Package list implements a doubly linked list.\n\nTo iterate over a list (where l is a *List):\n```\nfor e := l.Front(); e != nil; e = e.Next() {\n\t// do something with e.Value\n}\n\n[\"container/list\" on pkg.go.dev](https://pkg.go.dev/container/list)",
        "url": "https://pkg.go.dev/container/list",
        "path": "container/list",
        "children": []
      },
      {
        "name": "ring",
        "synopsis": "Package ring implements operations on circular lists.\n\n[\"container/ring\" on pkg.go.dev](https://pkg.go.dev/container/ring)",
        "url": "https://pkg.go.dev/container/ring",
        "path": "container/ring",
        "children": []
      }
    ]
  },
  {
    "name": "context",
    "synopsis": "Package context defines the Context type, which carries deadlines,\ncancellation signals, and other request-scoped values across API boundaries\nand between processes.\n\nIncoming requests to a server should create a Context, and outgoing\ncalls to servers should accept a Context. The chain of function\ncalls between them must propagate the Context, optionally replacing\nit with a derived Context created using WithCancel, WithDeadline,\nWithTimeout, or WithValue. When a Context is canceled, all\nContexts derived from it are also canceled.\n\nThe WithCancel, WithDeadline, and WithTimeout functions take a\nContext (the parent) and return a derived Context (the child) and a\nCancelFunc. Calling the CancelFunc cancels the child and its\nchildren, removes the parent's reference to the child, and stops\nany associated timers. Failing to call the CancelFunc leaks the\nchild and its children until the parent is canceled or the timer\nfires. The go vet tool checks that CancelFuncs are used on all\ncontrol-flow paths.\n\nPrograms that use Contexts should follow these rules to keep interfaces\nconsistent across packages and enable static analysis tools to check context\npropagation:\n\nDo not store Contexts inside a struct type; instead, pass a Context\nexplicitly to each function that needs it. The Context should be the first\nparameter, typically named ctx:\n\n```\nfunc DoSomething(ctx context.Context, arg Arg) error {\n\t// ... use ctx ...\n}\n\n```\nDo not pass a nil Context, even if a function permits it. Pass context.TODO\nif you are unsure about which Context to use.\n\nUse context Values only for request-scoped data that transits processes and\nAPIs, not for passing optional parameters to functions.\n\nThe same Context may be passed to functions running in different goroutines;\nContexts are safe for simultaneous use by multiple goroutines.\n\nSee https://blog.golang.org/context for example code for a server that uses\nContexts.\n\n[\"context\" on pkg.go.dev](https://pkg.go.dev/context)",
    "url": "https://pkg.go.dev/context",
    "path": "context",
    "children": []
  },
  {
    "name": "crypto",
    "synopsis": "Package crypto collects common cryptographic constants.\n\n[\"crypto\" on pkg.go.dev](https://pkg.go.dev/crypto)",
    "url": "https://pkg.go.dev/crypto",
    "path": "crypto",
    "children": [
      {
        "name": "aes",
        "synopsis": "Package aes implements AES encryption (formerly Rijndael), as defined in\nU.S. Federal Information Processing Standards Publication 197.\n\nThe AES operations in this package are not implemented using constant-time algorithms.\nAn exception is when running on systems with enabled hardware support for AES\nthat makes these operations constant-time. Examples include amd64 systems using AES-NI\nextensions and s390x systems using Message-Security-Assist extensions.\nOn such systems, when the result of NewCipher is passed to cipher.NewGCM,\nthe GHASH operation used by GCM is also constant-time.\n\n[\"crypto/aes\" on pkg.go.dev](https://pkg.go.dev/crypto/aes)",
        "url": "https://pkg.go.dev/crypto/aes",
        "path": "crypto/aes",
        "children": []
      },
      {
        "name": "cipher",
        "synopsis": "Package cipher implements standard block cipher modes that can be wrapped\naround low-level block cipher implementations.\nSee https://csrc.nist.gov/groups/ST/toolkit/BCM/current_modes.html\nand NIST Special Publication 800-38A.\n\n[\"crypto/cipher\" on pkg.go.dev](https://pkg.go.dev/crypto/cipher)",
        "url": "https://pkg.go.dev/crypto/cipher",
        "path": "crypto/cipher",
        "children": []
      },
      {
        "name": "des",
        "synopsis": "Package des implements the Data Encryption Standard (DES) and the\nTriple Data Encryption Algorithm (TDEA) as defined\nin U.S. Federal Information Processing Standards Publication 46-3.\n\nDES is cryptographically broken and should not be used for secure\napplications.\n\n[\"crypto/des\" on pkg.go.dev](https://pkg.go.dev/crypto/des)",
        "url": "https://pkg.go.dev/crypto/des",
        "path": "crypto/des",
        "children": []
      },
      {
        "name": "dsa",
        "synopsis": "Package dsa implements the Digital Signature Algorithm, as defined in FIPS 186-3.\n\nThe DSA operations in this package are not implemented using constant-time algorithms.\n\nDeprecated: DSA is a legacy algorithm, and modern alternatives such as\nEd25519 (implemented by package crypto/ed25519) should be used instead. Keys\nwith 1024-bit moduli (L1024N160 parameters) are cryptographically weak, while\nbigger keys are not widely supported. Note that FIPS 186-5 no longer approves\nDSA for signature generation.\n\n[\"crypto/dsa\" on pkg.go.dev](https://pkg.go.dev/crypto/dsa)",
        "url": "https://pkg.go.dev/crypto/dsa",
        "path": "crypto/dsa",
        "children": []
      },
      {
        "name": "ecdsa",
        "synopsis": "Package ecdsa implements the Elliptic Curve Digital Signature Algorithm, as\ndefined in FIPS 186-4 and SEC 1, Version 2.0.\n\nSignatures generated by this package are not deterministic, but entropy is\nmixed with the private key and the message, achieving the same level of\nsecurity in case of randomness source failure.\n\n[\"crypto/ecdsa\" on pkg.go.dev](https://pkg.go.dev/crypto/ecdsa)",
        "url": "https://pkg.go.dev/crypto/ecdsa",
        "path": "crypto/ecdsa",
        "children": []
      },
      {
        "name": "ed25519",
        "synopsis": "Package ed25519 implements the Ed25519 signature algorithm. See\nhttps://ed25519.cr.yp.to/.\n\nThese functions are also compatible with the “Ed25519” function defined in\nRFC 8032. However, unlike RFC 8032's formulation, this package's private key\nrepresentation includes a public key suffix to make multiple signing\noperations with the same key more efficient. This package refers to the RFC\n8032 private key as the “seed”.\n\n[\"crypto/ed25519\" on pkg.go.dev](https://pkg.go.dev/crypto/ed25519)",
        "url": "https://pkg.go.dev/crypto/ed25519",
        "path": "crypto/ed25519",
        "children": []
      },
      {
        "name": "elliptic",
        "synopsis": "Package elliptic implements the standard NIST P-224, P-256, P-384, and P-521\nelliptic curves over prime fields.\n\n[\"crypto/elliptic\" on pkg.go.dev](https://pkg.go.dev/crypto/elliptic)",
        "url": "https://pkg.go.dev/crypto/elliptic",
        "path": "crypto/elliptic",
        "children": []
      },
      {
        "name": "hmac",
        "synopsis": "Package hmac implements the Keyed-Hash Message Authentication Code (HMAC) as\ndefined in U.S. Federal Information Processing Standards Publication 198.\nAn HMAC is a cryptographic hash that uses a key to sign a message.\nThe receiver verifies the hash by recomputing it using the same key.\n\nReceivers should be careful to use Equal to compare MACs in order to avoid\ntiming side-channels:\n\n```\n// ValidMAC reports whether messageMAC is a valid HMAC tag for message.\nfunc ValidMAC(message, messageMAC, key []byte) bool {\n\tmac := hmac.New(sha256.New, key)\n\tmac.Write(message)\n\texpectedMAC := mac.Sum(nil)\n\treturn hmac.Equal(messageMAC, expectedMAC)\n}\n\n[\"crypto/hmac\" on pkg.go.dev](https://pkg.go.dev/crypto/hmac)",
        "url": "https://pkg.go.dev/crypto/hmac",
        "path": "crypto/hmac",
        "children": []
      },
      {
        "name": "md5",
        "synopsis": "Package md5 implements the MD5 hash algorithm as defined in RFC 1321.\n\nMD5 is cryptographically broken and should not be used for secure\napplications.\n\n[\"crypto/md5\" on pkg.go.dev](https://pkg.go.dev/crypto/md5)",
        "url": "https://pkg.go.dev/crypto/md5",
        "path": "crypto/md5",
        "children": []
      },
      {
        "name": "rand",
        "synopsis": "Package rand implements a cryptographically secure\nrandom number generator.\n\n[\"crypto/rand\" on pkg.go.dev](https://pkg.go.dev/crypto/rand)",
        "url": "https://pkg.go.dev/crypto/rand",
        "path": "crypto/rand",
        "children": []
      },
      {
        "name": "rc4",
        "synopsis": "Package rc4 implements RC4 encryption, as defined in Bruce Schneier's\nApplied Cryptography.\n\nRC4 is cryptographically broken and should not be used for secure\napplications.\n\n[\"crypto/rc4\" on pkg.go.dev](https://pkg.go.dev/crypto/rc4)",
        "url": "https://pkg.go.dev/crypto/rc4",
        "path": "crypto/rc4",
        "children": []
      },
      {
        "name": "rsa",
        "synopsis": "Package rsa implements RSA encryption as specified in PKCS #1 and RFC 8017.\n\nRSA is a single, fundamental operation that is used in this package to\nimplement either public-key encryption or public-key signatures.\n\nThe original specification for encryption and signatures with RSA is PKCS #1\nand the terms \"RSA encryption\" and \"RSA signatures\" by default refer to\nPKCS #1 version 1.5. However, that specification has flaws and new designs\nshould use version 2, usually called by just OAEP and PSS, where\npossible.\n\nTwo sets of interfaces are included in this package. When a more abstract\ninterface isn't necessary, there are functions for encrypting/decrypting\nwith v1.5/OAEP and signing/verifying with v1.5/PSS. If one needs to abstract\nover the public key primitive, the PrivateKey type implements the\nDecrypter and Signer interfaces from the crypto package.\n\nThe RSA operations in this package are not implemented using constant-time algorithms.\n\n[\"crypto/rsa\" on pkg.go.dev](https://pkg.go.dev/crypto/rsa)",
        "url": "https://pkg.go.dev/crypto/rsa",
        "path": "crypto/rsa",
        "children": []
      },
      {
        "name": "sha1",
        "synopsis": "Package sha1 implements the SHA-1 hash algorithm as defined in RFC 3174.\n\nSHA-1 is cryptographically broken and should not be used for secure\napplications.\n\n[\"crypto/sha1\" on pkg.go.dev](https://pkg.go.dev/crypto/sha1)",
        "url": "https://pkg.go.dev/crypto/sha1",
        "path": "crypto/sha1",
        "children": []
      },
      {
        "name": "sha256",
        "synopsis": "Package sha256 implements the SHA224 and SHA256 hash algorithms as defined\nin FIPS 180-4.\n\n[\"crypto/sha256\" on pkg.go.dev](https://pkg.go.dev/crypto/sha256)",
        "url": "https://pkg.go.dev/crypto/sha256",
        "path": "crypto/sha256",
        "children": []
      },
      {
        "name": "sha512",
        "synopsis": "Package sha512 implements the SHA-384, SHA-512, SHA-512/224, and SHA-512/256\nhash algorithms as defined in FIPS 180-4.\n\nAll the hash.Hash implementations returned by this package also\nimplement encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to\nmarshal and unmarshal the internal state of the hash.\n\n[\"crypto/sha512\" on pkg.go.dev](https://pkg.go.dev/crypto/sha512)",
        "url": "https://pkg.go.dev/crypto/sha512",
        "path": "crypto/sha512",
        "children": []
      },
      {
        "name": "subtle",
        "synopsis": "Package subtle implements functions that are often useful in cryptographic\ncode but require careful thought to use correctly.\n\n[\"crypto/subtle\" on pkg.go.dev](https://pkg.go.dev/crypto/subtle)",
        "url": "https://pkg.go.dev/crypto/subtle",
        "path": "crypto/subtle",
        "children": []
      },
      {
        "name": "tls",
        "synopsis": "Package tls partially implements TLS 1.2, as specified in RFC 5246,\nand TLS 1.3, as specified in RFC 8446.\n\n[\"crypto/tls\" on pkg.go.dev](https://pkg.go.dev/crypto/tls)",
        "url": "https://pkg.go.dev/crypto/tls",
        "path": "crypto/tls",
        "children": []
      },
      {
        "name": "x509",
        "synopsis": "Copyright 2021 The Go Authors. All rights reserved.\nUse of this source code is governed by a BSD-style\nlicense that can be found in the LICENSE file.\n\nCopyright 2021 The Go Authors. All rights reserved.\nUse of this source code is governed by a BSD-style\nlicense that can be found in the LICENSE file.\n\nPackage x509 parses X.509-encoded keys and certificates.\n\n[\"crypto/x509\" on pkg.go.dev](https://pkg.go.dev/crypto/x509)",
        "url": "https://pkg.go.dev/crypto/x509",
        "path": "crypto/x509",
        "children": [
          {
            "name": "pkix",
            "synopsis": "Package pkix contains shared, low level structures used for ASN.1 parsing\nand serialization of X.509 certificates, CRL and OCSP.\n\n[\"crypto/x509/pkix\" on pkg.go.dev](https://pkg.go.dev/crypto/x509/pkix)",
            "url": "https://pkg.go.dev/crypto/x509/pkix",
            "path": "crypto/x509/pkix",
            "children": []
          }
        ]
      }
    ]
  },
  {
    "name": "database",
    "synopsis": "",
    "url": "https://pkg.go.dev/database",
    "path": "database",
    "children": [
      {
        "name": "sql",
        "synopsis": "Package sql provides a generic interface around SQL (or SQL-like)\ndatabases.\n\nThe sql package must be used in conjunction with a database driver.\nSee https://golang.org/s/sqldrivers for a list of drivers.\n\nDrivers that do not support context cancellation will not return until\nafter the query is completed.\n\nFor usage examples, see the wiki page at\nhttps://golang.org/s/sqlwiki.\n\n[\"database/sql\" on pkg.go.dev](https://pkg.go.dev/database/sql)",
        "url": "https://pkg.go.dev/database/sql",
        "path": "database/sql",
        "children": [
          {
            "name": "driver",
            "synopsis": "Package driver defines interfaces to be implemented by database\ndrivers as used by package sql.\n\nMost code should use package sql.\n\nThe driver interface has evolved over time. Drivers should implement\nConnector and DriverContext interfaces.\nThe Connector.Connect and Driver.Open methods should never return ErrBadConn.\nErrBadConn should only be returned from Validator, SessionResetter, or\na query method if the connection is already in an invalid (e.g. closed) state.\n\nAll Conn implementations should implement the following interfaces:\nPinger, SessionResetter, and Validator.\n\nIf named parameters or context are supported, the driver's Conn should implement:\nExecerContext, QueryerContext, ConnPrepareContext, and ConnBeginTx.\n\nTo support custom data types, implement NamedValueChecker. NamedValueChecker\nalso allows queries to accept per-query options as a parameter by returning\nErrRemoveArgument from CheckNamedValue.\n\nIf multiple result sets are supported, Rows should implement RowsNextResultSet.\nIf the driver knows how to describe the types present in the returned result\nit should implement the following interfaces: RowsColumnTypeScanType,\nRowsColumnTypeDatabaseTypeName, RowsColumnTypeLength, RowsColumnTypeNullable,\nand RowsColumnTypePrecisionScale. A given row value may also return a Rows\ntype, which may represent a database cursor value.\n\nBefore a connection is returned to the connection pool after use, IsValid is\ncalled if implemented. Before a connection is reused for another query,\nResetSession is called if implemented. If a connection is never returned to the\nconnection pool but immediately reused, then ResetSession is called prior to\nreuse but IsValid is not called.\n\n[\"database/sql/driver\" on pkg.go.dev](https://pkg.go.dev/database/sql/driver)",
            "url": "https://pkg.go.dev/database/sql/driver",
            "path": "database/sql/driver",
            "children": []
          }
        ]
      }
    ]
  },
  {
    "name": "debug",
    "synopsis": "",
    "url": "https://pkg.go.dev/debug",
    "path": "debug",
    "children": [
      {
        "name": "buildinfo",
        "synopsis": "Package buildinfo provides access to information embedded in a Go binary\nabout how it was built. This includes the Go toolchain version, and the\nset of modules used (for binaries built in module mode).\n\nBuild information is available for the currently running binary in\nruntime/debug.ReadBuildInfo.\n\n[\"debug/buildinfo\" on pkg.go.dev](https://pkg.go.dev/debug/buildinfo)",
        "url": "https://pkg.go.dev/debug/buildinfo",
        "path": "debug/buildinfo",
        "children": []
      },
      {
        "name": "dwarf",
        "synopsis": "Package dwarf provides access to DWARF debugging information loaded from\nexecutable files, as defined in the DWARF 2.0 Standard at\nhttp://dwarfstd.org/doc/dwarf-2.0.0.pdf\n\n[\"debug/dwarf\" on pkg.go.dev](https://pkg.go.dev/debug/dwarf)",
        "url": "https://pkg.go.dev/debug/dwarf",
        "path": "debug/dwarf",
        "children": []
      },
      {
        "name": "elf",
        "synopsis": "Package elf implements access to ELF object files.\n\n[\"debug/elf\" on pkg.go.dev](https://pkg.go.dev/debug/elf)",
        "url": "https://pkg.go.dev/debug/elf",
        "path": "debug/elf",
        "children": []
      },
      {
        "name": "gosym",
        "synopsis": "Package gosym implements access to the Go symbol\nand line number tables embedded in Go binaries generated\nby the gc compilers.\n\n[\"debug/gosym\" on pkg.go.dev](https://pkg.go.dev/debug/gosym)",
        "url": "https://pkg.go.dev/debug/gosym",
        "path": "debug/gosym",
        "children": []
      },
      {
        "name": "macho",
        "synopsis": "Package macho implements access to Mach-O object files.\n\n[\"debug/macho\" on pkg.go.dev](https://pkg.go.dev/debug/macho)",
        "url": "https://pkg.go.dev/debug/macho",
        "path": "debug/macho",
        "children": []
      },
      {
        "name": "pe",
        "synopsis": "Package pe implements access to PE (Microsoft Windows Portable Executable) files.\n\n[\"debug/pe\" on pkg.go.dev](https://pkg.go.dev/debug/pe)",
        "url": "https://pkg.go.dev/debug/pe",
        "path": "debug/pe",
        "children": []
      },
      {
        "name": "plan9obj",
        "synopsis": "Package plan9obj implements access to Plan 9 a.out object files.\n\n[\"debug/plan9obj\" on pkg.go.dev](https://pkg.go.dev/debug/plan9obj)",
        "url": "https://pkg.go.dev/debug/plan9obj",
        "path": "debug/plan9obj",
        "children": []
      }
    ]
  },
  {
    "name": "embed",
    "synopsis": "Package embed provides access to files embedded in the running Go program.\n\nGo source files that import \"embed\" can use the //go:embed directive\nto initialize a variable of type string, []byte, or FS with the contents of\nfiles read from the package directory or subdirectories at compile time.\n\nFor example, here are three ways to embed a file named hello.txt\nand then print its contents at run time.\n\nEmbedding one file into a string:\n\n```\nimport _ \"embed\"\n\n//go:embed hello.txt\nvar s string\nprint(s)\n\n```\nEmbedding one file into a slice of bytes:\n\n```\nimport _ \"embed\"\n\n//go:embed hello.txt\nvar b []byte\nprint(string(b))\n\n```\nEmbedded one or more files into a file system:\n\n```\nimport \"embed\"\n\n//go:embed hello.txt\nvar f embed.FS\ndata, _ := f.ReadFile(\"hello.txt\")\nprint(string(data))\n\n```\nDirectives\n\nA //go:embed directive above a variable declaration specifies which files to embed,\nusing one or more path.Match patterns.\n\nThe directive must immediately precede a line containing the declaration of a single variable.\nOnly blank lines and ‘//’ line comments are permitted between the directive and the declaration.\n\nThe type of the variable must be a string type, or a slice of a byte type,\nor FS (or an alias of FS).\n\nFor example:\n\n```\npackage server\n\nimport \"embed\"\n\n// content holds our static web server content.\n//go:embed image/* template/*\n//go:embed html/index.html\nvar content embed.FS\n\n```\nThe Go build system will recognize the directives and arrange for the declared variable\n(in the example above, content) to be populated with the matching files from the file system.\n\nThe //go:embed directive accepts multiple space-separated patterns for\nbrevity, but it can also be repeated, to avoid very long lines when there are\nmany patterns. The patterns are interpreted relative to the package directory\ncontaining the source file. The path separator is a forward slash, even on\nWindows systems. Patterns may not contain ‘.’ or ‘..’ or empty path elements,\nnor may they begin or end with a slash. To match everything in the current\ndirectory, use ‘*’ instead of ‘.’. To allow for naming files with spaces in\ntheir names, patterns can be written as Go double-quoted or back-quoted\nstring literals.\n\nIf a pattern names a directory, all files in the subtree rooted at that directory are\nembedded (recursively), except that files with names beginning with ‘.’ or ‘_’\nare excluded. So the variable in the above example is almost equivalent to:\n\n```\n// content is our static web server content.\n//go:embed image template html/index.html\nvar content embed.FS\n\n```\nThe difference is that ‘image/*’ embeds ‘image/.tempfile’ while ‘image’ does not.\nNeither embeds ‘image/dir/.tempfile’.\n\nIf a pattern begins with the prefix ‘all:’, then the rule for walking directories is changed\nto include those files beginning with ‘.’ or ‘_’. For example, ‘all:image’ embeds\nboth ‘image/.tempfile’ and ‘image/dir/.tempfile’.\n\nThe //go:embed directive can be used with both exported and unexported variables,\ndepending on whether the package wants to make the data available to other packages.\nIt can only be used with variables at package scope, not with local variables.\n\nPatterns must not match files outside the package's module, such as ‘.git/*’ or symbolic links.\nMatches for empty directories are ignored. After that, each pattern in a //go:embed line\nmust match at least one file or non-empty directory.\n\nIf any patterns are invalid or have invalid matches, the build will fail.\n\nStrings and Bytes\n\nThe //go:embed line for a variable of type string or []byte can have only a single pattern,\nand that pattern can match only a single file. The string or []byte is initialized with\nthe contents of that file.\n\nThe //go:embed directive requires importing \"embed\", even when using a string or []byte.\nIn source files that don't refer to embed.FS, use a blank import (import _ \"embed\").\n\nFile Systems\n\nFor embedding a single file, a variable of type string or []byte is often best.\nThe FS type enables embedding a tree of files, such as a directory of static\nweb server content, as in the example above.\n\nFS implements the io/fs package's FS interface, so it can be used with any package that\nunderstands file systems, including net/http, text/template, and html/template.\n\nFor example, given the content variable in the example above, we can write:\n\n```\nhttp.Handle(\"/static/\", http.StripPrefix(\"/static/\", http.FileServer(http.FS(content))))\n\ntemplate.ParseFS(content, \"*.tmpl\")\n\n```\nTools\n\nTo support tools that analyze Go packages, the patterns found in //go:embed lines\nare available in “go list” output. See the EmbedPatterns, TestEmbedPatterns,\nand XTestEmbedPatterns fields in the “go help list” output.\n\n[\"embed\" on pkg.go.dev](https://pkg.go.dev/embed)",
    "url": "https://pkg.go.dev/embed",
    "path": "embed",
    "children": []
  },
  {
    "name": "encoding",
    "synopsis": "Package encoding defines interfaces shared by other packages that\nconvert data to and from byte-level and textual representations.\nPackages that check for these interfaces include encoding/gob,\nencoding/json, and encoding/xml. As a result, implementing an\ninterface once can make a type useful in multiple encodings.\nStandard types that implement these interfaces include time.Time and net.IP.\nThe interfaces come in pairs that produce and consume encoded data.\n\n[\"encoding\" on pkg.go.dev](https://pkg.go.dev/encoding)",
    "url": "https://pkg.go.dev/encoding",
    "path": "encoding",
    "children": [
      {
        "name": "ascii85",
        "synopsis": "Package ascii85 implements the ascii85 data encoding\nas used in the btoa tool and Adobe's PostScript and PDF document formats.\n\n[\"encoding/ascii85\" on pkg.go.dev](https://pkg.go.dev/encoding/ascii85)",
        "url": "https://pkg.go.dev/encoding/ascii85",
        "path": "encoding/ascii85",
        "children": []
      },
      {
        "name": "asn1",
        "synopsis": "Package asn1 implements parsing of DER-encoded ASN.1 data structures,\nas defined in ITU-T Rec X.690.\n\nSee also ``A Layman's Guide to a Subset of ASN.1, BER, and DER,''\nhttp://luca.ntop.org/Teaching/Appunti/asn1.html.\n\n[\"encoding/asn1\" on pkg.go.dev](https://pkg.go.dev/encoding/asn1)",
        "url": "https://pkg.go.dev/encoding/asn1",
        "path": "encoding/asn1",
        "children": []
      },
      {
        "name": "base32",
        "synopsis": "Package base32 implements base32 encoding as specified by RFC 4648.\n\n[\"encoding/base32\" on pkg.go.dev](https://pkg.go.dev/encoding/base32)",
        "url": "https://pkg.go.dev/encoding/base32",
        "path": "encoding/base32",
        "children": []
      },
      {
        "name": "base64",
        "synopsis": "Package base64 implements base64 encoding as specified by RFC 4648.\n\n[\"encoding/base64\" on pkg.go.dev](https://pkg.go.dev/encoding/base64)",
        "url": "https://pkg.go.dev/encoding/base64",
        "path": "encoding/base64",
        "children": []
      },
      {
        "name": "binary",
        "synopsis": "Package binary implements simple translation between numbers and byte\nsequences and encoding and decoding of varints.\n\nNumbers are translated by reading and writing fixed-size values.\nA fixed-size value is either a fixed-size arithmetic\ntype (bool, int8, uint8, int16, float32, complex64, ...)\nor an array or struct containing only fixed-size values.\n\nThe varint functions encode and decode single integer values using\na variable-length encoding; smaller values require fewer bytes.\nFor a specification, see\nhttps://developers.google.com/protocol-buffers/docs/encoding.\n\nThis package favors simplicity over efficiency. Clients that require\nhigh-performance serialization, especially for large data structures,\nshould look at more advanced solutions such as the encoding/gob\npackage or protocol buffers.\n\n[\"encoding/binary\" on pkg.go.dev](https://pkg.go.dev/encoding/binary)",
        "url": "https://pkg.go.dev/encoding/binary",
        "path": "encoding/binary",
        "children": []
      },
      {
        "name": "csv",
        "synopsis": "Package csv reads and writes comma-separated values (CSV) files.\nThere are many kinds of CSV files; this package supports the format\ndescribed in RFC 4180.\n\nA csv file contains zero or more records of one or more fields per record.\nEach record is separated by the newline character. The final record may\noptionally be followed by a newline character.\n\n```\nfield1,field2,field3\n\n```\nWhite space is considered part of a field.\n\nCarriage returns before newline characters are silently removed.\n\nBlank lines are ignored. A line with only whitespace characters (excluding\nthe ending newline character) is not considered a blank line.\n\nFields which start and stop with the quote character \" are called\nquoted-fields. The beginning and ending quote are not part of the\nfield.\n\nThe source:\n\n```\nnormal string,\"quoted-field\"\n\n```\nresults in the fields\n\n```\n{`normal string`, `quoted-field`}\n\n```\nWithin a quoted-field a quote character followed by a second quote\ncharacter is considered a single quote.\n\n```\n\"the \"\"word\"\" is true\",\"a \"\"quoted-field\"\"\"\n\n```\nresults in\n\n```\n{`the \"word\" is true`, `a \"quoted-field\"`}\n\n```\nNewlines and commas may be included in a quoted-field\n\n```\n\"Multi-line\nfield\",\"comma is ,\"\n\n```\nresults in\n\n```\n{`Multi-line\nfield`, `comma is ,`}\n\n[\"encoding/csv\" on pkg.go.dev](https://pkg.go.dev/encoding/csv)",
        "url": "https://pkg.go.dev/encoding/csv",
        "path": "encoding/csv",
        "children": []
      },
      {
        "name": "gob",
        "synopsis": "Package gob manages streams of gobs - binary values exchanged between an\nEncoder (transmitter) and a Decoder (receiver). A typical use is transporting\narguments and results of remote procedure calls (RPCs) such as those provided by\npackage \"net/rpc\".\n\nThe implementation compiles a custom codec for each data type in the stream and\nis most efficient when a single Encoder is used to transmit a stream of values,\namortizing the cost of compilation.\n\nBasics\n\nA stream of gobs is self-describing. Each data item in the stream is preceded by\na specification of its type, expressed in terms of a small set of predefined\ntypes. Pointers are not transmitted, but the things they point to are\ntransmitted; that is, the values are flattened. Nil pointers are not permitted,\nas they have no value. Recursive types work fine, but\nrecursive values (data with cycles) are problematic. This may change.\n\nTo use gobs, create an Encoder and present it with a series of data items as\nvalues or addresses that can be dereferenced to values. The Encoder makes sure\nall type information is sent before it is needed. At the receive side, a\nDecoder retrieves values from the encoded stream and unpacks them into local\nvariables.\n\nTypes and Values\n\nThe source and destination values/types need not correspond exactly. For structs,\nfields (identified by name) that are in the source but absent from the receiving\nvariable will be ignored. Fields that are in the receiving variable but missing\nfrom the transmitted type or value will be ignored in the destination. If a field\nwith the same name is present in both, their types must be compatible. Both the\nreceiver and transmitter will do all necessary indirection and dereferencing to\nconvert between gobs and actual Go values. For instance, a gob type that is\nschematically,\n\n```\nstruct { A, B int }\n\n```\ncan be sent from or received into any of these Go types:\n\n```\nstruct { A, B int }\t// the same\n*struct { A, B int }\t// extra indirection of the struct\nstruct { *A, **B int }\t// extra indirection of the fields\nstruct { A, B int64 }\t// different concrete value type; see below\n\n```\nIt may also be received into any of these:\n\n```\nstruct { A, B int }\t// the same\nstruct { B, A int }\t// ordering doesn't matter; matching is by name\nstruct { A, B, C int }\t// extra field (C) ignored\nstruct { B int }\t// missing field (A) ignored; data will be dropped\nstruct { B, C int }\t// missing field (A) ignored; extra field (C) ignored.\n\n```\nAttempting to receive into these types will draw a decode error:\n\n```\nstruct { A int; B uint }\t// change of signedness for B\nstruct { A int; B float }\t// change of type for B\nstruct { }\t\t\t// no field names in common\nstruct { C, D int }\t\t// no field names in common\n\n```\nIntegers are transmitted two ways: arbitrary precision signed integers or\narbitrary precision unsigned integers. There is no int8, int16 etc.\ndiscrimination in the gob format; there are only signed and unsigned integers. As\ndescribed below, the transmitter sends the value in a variable-length encoding;\nthe receiver accepts the value and stores it in the destination variable.\nFloating-point numbers are always sent using IEEE-754 64-bit precision (see\nbelow).\n\nSigned integers may be received into any signed integer variable: int, int16, etc.;\nunsigned integers may be received into any unsigned integer variable; and floating\npoint values may be received into any floating point variable. However,\nthe destination variable must be able to represent the value or the decode\noperation will fail.\n\nStructs, arrays and slices are also supported. Structs encode and decode only\nexported fields. Strings and arrays of bytes are supported with a special,\nefficient representation (see below). When a slice is decoded, if the existing\nslice has capacity the slice will be extended in place; if not, a new array is\nallocated. Regardless, the length of the resulting slice reports the number of\nelements decoded.\n\nIn general, if allocation is required, the decoder will allocate memory. If not,\nit will update the destination variables with values read from the stream. It does\nnot initialize them first, so if the destination is a compound value such as a\nmap, struct, or slice, the decoded values will be merged elementwise into the\nexisting variables.\n\nFunctions and channels will not be sent in a gob. Attempting to encode such a value\nat the top level will fail. A struct field of chan or func type is treated exactly\nlike an unexported field and is ignored.\n\nGob can encode a value of any type implementing the GobEncoder or\nencoding.BinaryMarshaler interfaces by calling the corresponding method,\nin that order of preference.\n\nGob can decode a value of any type implementing the GobDecoder or\nencoding.BinaryUnmarshaler interfaces by calling the corresponding method,\nagain in that order of preference.\n\nEncoding Details\n\nThis section documents the encoding, details that are not important for most\nusers. Details are presented bottom-up.\n\nAn unsigned integer is sent one of two ways. If it is less than 128, it is sent\nas a byte with that value. Otherwise it is sent as a minimal-length big-endian\n(high byte first) byte stream holding the value, preceded by one byte holding the\nbyte count, negated. Thus 0 is transmitted as (00), 7 is transmitted as (07) and\n256 is transmitted as (FE 01 00).\n\nA boolean is encoded within an unsigned integer: 0 for false, 1 for true.\n\nA signed integer, i, is encoded within an unsigned integer, u. Within u, bits 1\nupward contain the value; bit 0 says whether they should be complemented upon\nreceipt. The encode algorithm looks like this:\n\n```\nvar u uint\nif i \u003c 0 {\n\tu = (^uint(i) \u003c\u003c 1) | 1 // complement i, bit 0 is 1\n} else {\n\tu = (uint(i) \u003c\u003c 1) // do not complement i, bit 0 is 0\n}\nencodeUnsigned(u)\n\n```\nThe low bit is therefore analogous to a sign bit, but making it the complement bit\ninstead guarantees that the largest negative integer is not a special case. For\nexample, -129=^128=(^256\u003e\u003e1) encodes as (FE 01 01).\n\nFloating-point numbers are always sent as a representation of a float64 value.\nThat value is converted to a uint64 using math.Float64bits. The uint64 is then\nbyte-reversed and sent as a regular unsigned integer. The byte-reversal means the\nexponent and high-precision part of the mantissa go first. Since the low bits are\noften zero, this can save encoding bytes. For instance, 17.0 is encoded in only\nthree bytes (FE 31 40).\n\nStrings and slices of bytes are sent as an unsigned count followed by that many\nuninterpreted bytes of the value.\n\nAll other slices and arrays are sent as an unsigned count followed by that many\nelements using the standard gob encoding for their type, recursively.\n\nMaps are sent as an unsigned count followed by that many key, element\npairs. Empty but non-nil maps are sent, so if the receiver has not allocated\none already, one will always be allocated on receipt unless the transmitted map\nis nil and not at the top level.\n\nIn slices and arrays, as well as maps, all elements, even zero-valued elements,\nare transmitted, even if all the elements are zero.\n\nStructs are sent as a sequence of (field number, field value) pairs. The field\nvalue is sent using the standard gob encoding for its type, recursively. If a\nfield has the zero value for its type (except for arrays; see above), it is omitted\nfrom the transmission. The field number is defined by the type of the encoded\nstruct: the first field of the encoded type is field 0, the second is field 1,\netc. When encoding a value, the field numbers are delta encoded for efficiency\nand the fields are always sent in order of increasing field number; the deltas are\ntherefore unsigned. The initialization for the delta encoding sets the field\nnumber to -1, so an unsigned integer field 0 with value 7 is transmitted as unsigned\ndelta = 1, unsigned value = 7 or (01 07). Finally, after all the fields have been\nsent a terminating mark denotes the end of the struct. That mark is a delta=0\nvalue, which has representation (00).\n\nInterface types are not checked for compatibility; all interface types are\ntreated, for transmission, as members of a single \"interface\" type, analogous to\nint or []byte - in effect they're all treated as interface{}. Interface values\nare transmitted as a string identifying the concrete type being sent (a name\nthat must be pre-defined by calling Register), followed by a byte count of the\nlength of the following data (so the value can be skipped if it cannot be\nstored), followed by the usual encoding of concrete (dynamic) value stored in\nthe interface value. (A nil interface value is identified by the empty string\nand transmits no value.) Upon receipt, the decoder verifies that the unpacked\nconcrete item satisfies the interface of the receiving variable.\n\nIf a value is passed to Encode and the type is not a struct (or pointer to struct,\netc.), for simplicity of processing it is represented as a struct of one field.\nThe only visible effect of this is to encode a zero byte after the value, just as\nafter the last field of an encoded struct, so that the decode algorithm knows when\nthe top-level value is complete.\n\nThe representation of types is described below. When a type is defined on a given\nconnection between an Encoder and Decoder, it is assigned a signed integer type\nid. When Encoder.Encode(v) is called, it makes sure there is an id assigned for\nthe type of v and all its elements and then it sends the pair (typeid, encoded-v)\nwhere typeid is the type id of the encoded type of v and encoded-v is the gob\nencoding of the value v.\n\nTo define a type, the encoder chooses an unused, positive type id and sends the\npair (-type id, encoded-type) where encoded-type is the gob encoding of a wireType\ndescription, constructed from these types:\n\n```\ntype wireType struct {\n\tArrayT           *ArrayType\n\tSliceT           *SliceType\n\tStructT          *StructType\n\tMapT             *MapType\n\tGobEncoderT      *gobEncoderType\n\tBinaryMarshalerT *gobEncoderType\n\tTextMarshalerT   *gobEncoderType\n\n}\ntype arrayType struct {\n\tCommonType\n\tElem typeId\n\tLen  int\n}\ntype CommonType struct {\n\tName string // the name of the struct type\n\tId  int    // the id of the type, repeated so it's inside the type\n}\ntype sliceType struct {\n\tCommonType\n\tElem typeId\n}\ntype structType struct {\n\tCommonType\n\tField []*fieldType // the fields of the struct.\n}\ntype fieldType struct {\n\tName string // the name of the field.\n\tId   int    // the type id of the field, which must be already defined\n}\ntype mapType struct {\n\tCommonType\n\tKey  typeId\n\tElem typeId\n}\ntype gobEncoderType struct {\n\tCommonType\n}\n\n```\nIf there are nested type ids, the types for all inner type ids must be defined\nbefore the top-level type id is used to describe an encoded-v.\n\nFor simplicity in setup, the connection is defined to understand these types a\npriori, as well as the basic gob types int, uint, etc. Their ids are:\n\n```\nbool        1\nint         2\nuint        3\nfloat       4\n[]byte      5\nstring      6\ncomplex     7\ninterface   8\n// gap for reserved ids.\nWireType    16\nArrayType   17\nCommonType  18\nSliceType   19\nStructType  20\nFieldType   21\n// 22 is slice of fieldType.\nMapType     23\n\n```\nFinally, each message created by a call to Encode is preceded by an encoded\nunsigned integer count of the number of bytes remaining in the message. After\nthe initial type name, interface values are wrapped the same way; in effect, the\ninterface value acts like a recursive invocation of Encode.\n\nIn summary, a gob stream looks like\n\n```\n(byteCount (-type id, encoding of a wireType)* (type id, encoding of a value))*\n\n```\nwhere * signifies zero or more repetitions and the type id of a value must\nbe predefined or be defined before the value in the stream.\n\nCompatibility: Any future changes to the package will endeavor to maintain\ncompatibility with streams encoded using previous versions. That is, any released\nversion of this package should be able to decode data written with any previously\nreleased version, subject to issues such as security fixes. See the Go compatibility\ndocument for background: https://golang.org/doc/go1compat\n\nSee \"Gobs of data\" for a design discussion of the gob wire format:\nhttps://blog.golang.org/gobs-of-data\n\n[\"encoding/gob\" on pkg.go.dev](https://pkg.go.dev/encoding/gob)",
        "url": "https://pkg.go.dev/encoding/gob",
        "path": "encoding/gob",
        "children": []
      },
      {
        "name": "hex",
        "synopsis": "Package hex implements hexadecimal encoding and decoding.\n\n[\"encoding/hex\" on pkg.go.dev](https://pkg.go.dev/encoding/hex)",
        "url": "https://pkg.go.dev/encoding/hex",
        "path": "encoding/hex",
        "children": []
      },
      {
        "name": "json",
        "synopsis": "Package json implements encoding and decoding of JSON as defined in\nRFC 7159. The mapping between JSON and Go values is described\nin the documentation for the Marshal and Unmarshal functions.\n\nSee \"JSON and Go\" for an introduction to this package:\nhttps://golang.org/doc/articles/json_and_go.html\n\n[\"encoding/json\" on pkg.go.dev](https://pkg.go.dev/encoding/json)",
        "url": "https://pkg.go.dev/encoding/json",
        "path": "encoding/json",
        "children": []
      },
      {
        "name": "pem",
        "synopsis": "Package pem implements the PEM data encoding, which originated in Privacy\nEnhanced Mail. The most common use of PEM encoding today is in TLS keys and\ncertificates. See RFC 1421.\n\n[\"encoding/pem\" on pkg.go.dev](https://pkg.go.dev/encoding/pem)",
        "url": "https://pkg.go.dev/encoding/pem",
        "path": "encoding/pem",
        "children": []
      },
      {
        "name": "xml",
        "synopsis": "Package xml implements a simple XML 1.0 parser that\nunderstands XML name spaces.\n\n[\"encoding/xml\" on pkg.go.dev](https://pkg.go.dev/encoding/xml)",
        "url": "https://pkg.go.dev/encoding/xml",
        "path": "encoding/xml",
        "children": []
      }
    ]
  },
  {
    "name": "errors",
    "synopsis": "Package errors implements functions to manipulate errors.\n\nThe New function creates errors whose only content is a text message.\n\nThe Unwrap, Is and As functions work on errors that may wrap other errors.\nAn error wraps another error if its type has the method\n\n```\nUnwrap() error\n\n```\nIf e.Unwrap() returns a non-nil error w, then we say that e wraps w.\n\nUnwrap unpacks wrapped errors. If its argument's type has an\nUnwrap method, it calls the method once. Otherwise, it returns nil.\n\nA simple way to create wrapped errors is to call fmt.Errorf and apply the %w verb\nto the error argument:\n\n```\nerrors.Unwrap(fmt.Errorf(\"... %w ...\", ..., err, ...))\n\n```\nreturns err.\n\nIs unwraps its first argument sequentially looking for an error that matches the\nsecond. It reports whether it finds a match. It should be used in preference to\nsimple equality checks:\n\n```\nif errors.Is(err, fs.ErrExist)\n\n```\nis preferable to\n\n```\nif err == fs.ErrExist\n\n```\nbecause the former will succeed if err wraps fs.ErrExist.\n\nAs unwraps its first argument sequentially looking for an error that can be\nassigned to its second argument, which must be a pointer. If it succeeds, it\nperforms the assignment and returns true. Otherwise, it returns false. The form\n\n```\nvar perr *fs.PathError\nif errors.As(err, \u0026perr) {\n\tfmt.Println(perr.Path)\n}\n\n```\nis preferable to\n\n```\nif perr, ok := err.(*fs.PathError); ok {\n\tfmt.Println(perr.Path)\n}\n\n```\nbecause the former will succeed if err wraps an *fs.PathError.\n\n[\"errors\" on pkg.go.dev](https://pkg.go.dev/errors)",
    "url": "https://pkg.go.dev/errors",
    "path": "errors",
    "children": []
  },
  {
    "name": "expvar",
    "synopsis": "Package expvar provides a standardized interface to public variables, such\nas operation counters in servers. It exposes these variables via HTTP at\n/debug/vars in JSON format.\n\nOperations to set or modify these public variables are atomic.\n\nIn addition to adding the HTTP handler, this package registers the\nfollowing variables:\n\n```\ncmdline   os.Args\nmemstats  runtime.Memstats\n\n```\nThe package is sometimes only imported for the side effect of\nregistering its HTTP handler and the above variables. To use it\nthis way, link this package into your program:\n```\nimport _ \"expvar\"\n\n[\"expvar\" on pkg.go.dev](https://pkg.go.dev/expvar)",
    "url": "https://pkg.go.dev/expvar",
    "path": "expvar",
    "children": []
  },
  {
    "name": "flag",
    "synopsis": "```\nPackage flag implements command-line flag parsing.\n\nUsage\n\nDefine flags using flag.String(), Bool(), Int(), etc.\n\nThis declares an integer flag, -n, stored in the pointer nFlag, with type *int:\n\timport \"flag\"\n\tvar nFlag = flag.Int(\"n\", 1234, \"help message for flag n\")\nIf you like, you can bind the flag to a variable using the Var() functions.\n\tvar flagvar int\n\tfunc init() {\n\t\tflag.IntVar(\u0026flagvar, \"flagname\", 1234, \"help message for flagname\")\n\t}\nOr you can create custom flags that satisfy the Value interface (with\npointer receivers) and couple them to flag parsing by\n\tflag.Var(\u0026flagVal, \"name\", \"help message for flagname\")\nFor such flags, the default value is just the initial value of the variable.\n\nAfter all flags are defined, call\n\tflag.Parse()\nto parse the command line into the defined flags.\n\nFlags may then be used directly. If you're using the flags themselves,\nthey are all pointers; if you bind to variables, they're values.\n\tfmt.Println(\"ip has value \", *ip)\n\tfmt.Println(\"flagvar has value \", flagvar)\n\nAfter parsing, the arguments following the flags are available as the\nslice flag.Args() or individually as flag.Arg(i).\nThe arguments are indexed from 0 through flag.NArg()-1.\n\nCommand line flag syntax\n\nThe following forms are permitted:\n\n\t-flag\n\t-flag=x\n\t-flag x  // non-boolean flags only\nOne or two minus signs may be used; they are equivalent.\nThe last form is not permitted for boolean flags because the\nmeaning of the command\n\tcmd -x *\nwhere * is a Unix shell wildcard, will change if there is a file\ncalled 0, false, etc. You must use the -flag=false form to turn\noff a boolean flag.\n\nFlag parsing stops just before the first non-flag argument\n(\"-\" is a non-flag argument) or after the terminator \"--\".\n\nInteger flags accept 1234, 0664, 0x1234 and may be negative.\nBoolean flags may be:\n\t1, 0, t, f, T, F, true, false, TRUE, FALSE, True, False\nDuration flags accept any input valid for time.ParseDuration.\n\nThe default set of command-line flags is controlled by\ntop-level functions.  The FlagSet type allows one to define\nindependent sets of flags, such as to implement subcommands\nin a command-line interface. The methods of FlagSet are\nanalogous to the top-level functions for the command-line\nflag set.\n\n[\"flag\" on pkg.go.dev](https://pkg.go.dev/flag)",
    "url": "https://pkg.go.dev/flag",
    "path": "flag",
    "children": []
  },
  {
    "name": "fmt",
    "synopsis": "```\nPackage fmt implements formatted I/O with functions analogous\nto C's printf and scanf.  The format 'verbs' are derived from C's but\nare simpler.\n\nPrinting\n\nThe verbs:\n\nGeneral:\n\t%v\tthe value in a default format\n\t\twhen printing structs, the plus flag (%+v) adds field names\n\t%#v\ta Go-syntax representation of the value\n\t%T\ta Go-syntax representation of the type of the value\n\t%%\ta literal percent sign; consumes no value\n\nBoolean:\n\t%t\tthe word true or false\nInteger:\n\t%b\tbase 2\n\t%c\tthe character represented by the corresponding Unicode code point\n\t%d\tbase 10\n\t%o\tbase 8\n\t%O\tbase 8 with 0o prefix\n\t%q\ta single-quoted character literal safely escaped with Go syntax.\n\t%x\tbase 16, with lower-case letters for a-f\n\t%X\tbase 16, with upper-case letters for A-F\n\t%U\tUnicode format: U+1234; same as \"U+%04X\"\nFloating-point and complex constituents:\n\t%b\tdecimalless scientific notation with exponent a power of two,\n\t\tin the manner of strconv.FormatFloat with the 'b' format,\n\t\te.g. -123456p-78\n\t%e\tscientific notation, e.g. -1.234456e+78\n\t%E\tscientific notation, e.g. -1.234456E+78\n\t%f\tdecimal point but no exponent, e.g. 123.456\n\t%F\tsynonym for %f\n\t%g\t%e for large exponents, %f otherwise. Precision is discussed below.\n\t%G\t%E for large exponents, %F otherwise\n\t%x\thexadecimal notation (with decimal power of two exponent), e.g. -0x1.23abcp+20\n\t%X\tupper-case hexadecimal notation, e.g. -0X1.23ABCP+20\nString and slice of bytes (treated equivalently with these verbs):\n\t%s\tthe uninterpreted bytes of the string or slice\n\t%q\ta double-quoted string safely escaped with Go syntax\n\t%x\tbase 16, lower-case, two characters per byte\n\t%X\tbase 16, upper-case, two characters per byte\nSlice:\n\t%p\taddress of 0th element in base 16 notation, with leading 0x\nPointer:\n\t%p\tbase 16 notation, with leading 0x\n\tThe %b, %d, %o, %x and %X verbs also work with pointers,\n\tformatting the value exactly as if it were an integer.\n\nThe default format for %v is:\n\tbool:                    %t\n\tint, int8 etc.:          %d\n\tuint, uint8 etc.:        %d, %#x if printed with %#v\n\tfloat32, complex64, etc: %g\n\tstring:                  %s\n\tchan:                    %p\n\tpointer:                 %p\nFor compound objects, the elements are printed using these rules, recursively,\nlaid out like this:\n\tstruct:             {field0 field1 ...}\n\tarray, slice:       [elem0 elem1 ...]\n\tmaps:               map[key1:value1 key2:value2 ...]\n\tpointer to above:   \u0026{}, \u0026[], \u0026map[]\n\nWidth is specified by an optional decimal number immediately preceding the verb.\nIf absent, the width is whatever is necessary to represent the value.\nPrecision is specified after the (optional) width by a period followed by a\ndecimal number. If no period is present, a default precision is used.\nA period with no following number specifies a precision of zero.\nExamples:\n\t%f     default width, default precision\n\t%9f    width 9, default precision\n\t%.2f   default width, precision 2\n\t%9.2f  width 9, precision 2\n\t%9.f   width 9, precision 0\n\nWidth and precision are measured in units of Unicode code points,\nthat is, runes. (This differs from C's printf where the\nunits are always measured in bytes.) Either or both of the flags\nmay be replaced with the character '*', causing their values to be\nobtained from the next operand (preceding the one to format),\nwhich must be of type int.\n\nFor most values, width is the minimum number of runes to output,\npadding the formatted form with spaces if necessary.\n\nFor strings, byte slices and byte arrays, however, precision\nlimits the length of the input to be formatted (not the size of\nthe output), truncating if necessary. Normally it is measured in\nrunes, but for these types when formatted with the %x or %X format\nit is measured in bytes.\n\nFor floating-point values, width sets the minimum width of the field and\nprecision sets the number of places after the decimal, if appropriate,\nexcept that for %g/%G precision sets the maximum number of significant\ndigits (trailing zeros are removed). For example, given 12.345 the format\n%6.3f prints 12.345 while %.3g prints 12.3. The default precision for %e, %f\nand %#g is 6; for %g it is the smallest number of digits necessary to identify\nthe value uniquely.\n\nFor complex numbers, the width and precision apply to the two\ncomponents independently and the result is parenthesized, so %f applied\nto 1.2+3.4i produces (1.200000+3.400000i).\n\nOther flags:\n\t+\talways print a sign for numeric values;\n\t\tguarantee ASCII-only output for %q (%+q)\n\t-\tpad with spaces on the right rather than the left (left-justify the field)\n\t#\talternate format: add leading 0b for binary (%#b), 0 for octal (%#o),\n\t\t0x or 0X for hex (%#x or %#X); suppress 0x for %p (%#p);\n\t\tfor %q, print a raw (backquoted) string if strconv.CanBackquote\n\t\treturns true;\n\t\talways print a decimal point for %e, %E, %f, %F, %g and %G;\n\t\tdo not remove trailing zeros for %g and %G;\n\t\twrite e.g. U+0078 'x' if the character is printable for %U (%#U).\n\t' '\t(space) leave a space for elided sign in numbers (% d);\n\t\tput spaces between bytes printing strings or slices in hex (% x, % X)\n\t0\tpad with leading zeros rather than spaces;\n\t\tfor numbers, this moves the padding after the sign\n\nFlags are ignored by verbs that do not expect them.\nFor example there is no alternate decimal format, so %#d and %d\nbehave identically.\n\nFor each Printf-like function, there is also a Print function\nthat takes no format and is equivalent to saying %v for every\noperand.  Another variant Println inserts blanks between\noperands and appends a newline.\n\nRegardless of the verb, if an operand is an interface value,\nthe internal concrete value is used, not the interface itself.\nThus:\n\tvar i interface{} = 23\n\tfmt.Printf(\"%v\\n\", i)\nwill print 23.\n\nExcept when printed using the verbs %T and %p, special\nformatting considerations apply for operands that implement\ncertain interfaces. In order of application:\n\n1. If the operand is a reflect.Value, the operand is replaced by the\nconcrete value that it holds, and printing continues with the next rule.\n\n2. If an operand implements the Formatter interface, it will\nbe invoked. In this case the interpretation of verbs and flags is\ncontrolled by that implementation.\n\n3. If the %v verb is used with the # flag (%#v) and the operand\nimplements the GoStringer interface, that will be invoked.\n\nIf the format (which is implicitly %v for Println etc.) is valid\nfor a string (%s %q %v %x %X), the following two rules apply:\n\n4. If an operand implements the error interface, the Error method\nwill be invoked to convert the object to a string, which will then\nbe formatted as required by the verb (if any).\n\n5. If an operand implements method String() string, that method\nwill be invoked to convert the object to a string, which will then\nbe formatted as required by the verb (if any).\n\nFor compound operands such as slices and structs, the format\napplies to the elements of each operand, recursively, not to the\noperand as a whole. Thus %q will quote each element of a slice\nof strings, and %6.2f will control formatting for each element\nof a floating-point array.\n\nHowever, when printing a byte slice with a string-like verb\n(%s %q %x %X), it is treated identically to a string, as a single item.\n\nTo avoid recursion in cases such as\n\ttype X string\n\tfunc (x X) String() string { return Sprintf(\"\u003c%s\u003e\", x) }\nconvert the value before recurring:\n\tfunc (x X) String() string { return Sprintf(\"\u003c%s\u003e\", string(x)) }\nInfinite recursion can also be triggered by self-referential data\nstructures, such as a slice that contains itself as an element, if\nthat type has a String method. Such pathologies are rare, however,\nand the package does not protect against them.\n\nWhen printing a struct, fmt cannot and therefore does not invoke\nformatting methods such as Error or String on unexported fields.\n\nExplicit argument indexes\n\nIn Printf, Sprintf, and Fprintf, the default behavior is for each\nformatting verb to format successive arguments passed in the call.\nHowever, the notation [n] immediately before the verb indicates that the\nnth one-indexed argument is to be formatted instead. The same notation\nbefore a '*' for a width or precision selects the argument index holding\nthe value. After processing a bracketed expression [n], subsequent verbs\nwill use arguments n+1, n+2, etc. unless otherwise directed.\n\nFor example,\n\tfmt.Sprintf(\"%[2]d %[1]d\\n\", 11, 22)\nwill yield \"22 11\", while\n\tfmt.Sprintf(\"%[3]*.[2]*[1]f\", 12.0, 2, 6)\nequivalent to\n\tfmt.Sprintf(\"%6.2f\", 12.0)\nwill yield \" 12.00\". Because an explicit index affects subsequent verbs,\nthis notation can be used to print the same values multiple times\nby resetting the index for the first argument to be repeated:\n\tfmt.Sprintf(\"%d %d %#[1]x %#x\", 16, 17)\nwill yield \"16 17 0x10 0x11\".\n\nFormat errors\n\nIf an invalid argument is given for a verb, such as providing\na string to %d, the generated string will contain a\ndescription of the problem, as in these examples:\n\n\tWrong type or unknown verb: %!verb(type=value)\n\t\tPrintf(\"%d\", \"hi\"):        %!d(string=hi)\n\tToo many arguments: %!(EXTRA type=value)\n\t\tPrintf(\"hi\", \"guys\"):      hi%!(EXTRA string=guys)\n\tToo few arguments: %!verb(MISSING)\n\t\tPrintf(\"hi%d\"):            hi%!d(MISSING)\n\tNon-int for width or precision: %!(BADWIDTH) or %!(BADPREC)\n\t\tPrintf(\"%*s\", 4.5, \"hi\"):  %!(BADWIDTH)hi\n\t\tPrintf(\"%.*s\", 4.5, \"hi\"): %!(BADPREC)hi\n\tInvalid or invalid use of argument index: %!(BADINDEX)\n\t\tPrintf(\"%*[2]d\", 7):       %!d(BADINDEX)\n\t\tPrintf(\"%.[2]d\", 7):       %!d(BADINDEX)\n\nAll errors begin with the string \"%!\" followed sometimes\nby a single character (the verb) and end with a parenthesized\ndescription.\n\nIf an Error or String method triggers a panic when called by a\nprint routine, the fmt package reformats the error message\nfrom the panic, decorating it with an indication that it came\nthrough the fmt package.  For example, if a String method\ncalls panic(\"bad\"), the resulting formatted message will look\nlike\n\t%!s(PANIC=bad)\n\nThe %!s just shows the print verb in use when the failure\noccurred. If the panic is caused by a nil receiver to an Error\nor String method, however, the output is the undecorated\nstring, \"\u003cnil\u003e\".\n\nScanning\n\nAn analogous set of functions scans formatted text to yield\nvalues.  Scan, Scanf and Scanln read from os.Stdin; Fscan,\nFscanf and Fscanln read from a specified io.Reader; Sscan,\nSscanf and Sscanln read from an argument string.\n\nScan, Fscan, Sscan treat newlines in the input as spaces.\n\nScanln, Fscanln and Sscanln stop scanning at a newline and\nrequire that the items be followed by a newline or EOF.\n\nScanf, Fscanf, and Sscanf parse the arguments according to a\nformat string, analogous to that of Printf. In the text that\nfollows, 'space' means any Unicode whitespace character\nexcept newline.\n\nIn the format string, a verb introduced by the % character\nconsumes and parses input; these verbs are described in more\ndetail below. A character other than %, space, or newline in\nthe format consumes exactly that input character, which must\nbe present. A newline with zero or more spaces before it in\nthe format string consumes zero or more spaces in the input\nfollowed by a single newline or the end of the input. A space\nfollowing a newline in the format string consumes zero or more\nspaces in the input. Otherwise, any run of one or more spaces\nin the format string consumes as many spaces as possible in\nthe input. Unless the run of spaces in the format string\nappears adjacent to a newline, the run must consume at least\none space from the input or find the end of the input.\n\nThe handling of spaces and newlines differs from that of C's\nscanf family: in C, newlines are treated as any other space,\nand it is never an error when a run of spaces in the format\nstring finds no spaces to consume in the input.\n\nThe verbs behave analogously to those of Printf.\nFor example, %x will scan an integer as a hexadecimal number,\nand %v will scan the default representation format for the value.\nThe Printf verbs %p and %T and the flags # and + are not implemented.\nFor floating-point and complex values, all valid formatting verbs\n(%b %e %E %f %F %g %G %x %X and %v) are equivalent and accept\nboth decimal and hexadecimal notation (for example: \"2.3e+7\", \"0x4.5p-8\")\nand digit-separating underscores (for example: \"3.14159_26535_89793\").\n\nInput processed by verbs is implicitly space-delimited: the\nimplementation of every verb except %c starts by discarding\nleading spaces from the remaining input, and the %s verb\n(and %v reading into a string) stops consuming input at the first\nspace or newline character.\n\nThe familiar base-setting prefixes 0b (binary), 0o and 0 (octal),\nand 0x (hexadecimal) are accepted when scanning integers\nwithout a format or with the %v verb, as are digit-separating\nunderscores.\n\nWidth is interpreted in the input text but there is no\nsyntax for scanning with a precision (no %5.2f, just %5f).\nIf width is provided, it applies after leading spaces are\ntrimmed and specifies the maximum number of runes to read\nto satisfy the verb. For example,\n   Sscanf(\" 1234567 \", \"%5s%d\", \u0026s, \u0026i)\nwill set s to \"12345\" and i to 67 while\n   Sscanf(\" 12 34 567 \", \"%5s%d\", \u0026s, \u0026i)\nwill set s to \"12\" and i to 34.\n\nIn all the scanning functions, a carriage return followed\nimmediately by a newline is treated as a plain newline\n(\\r\\n means the same as \\n).\n\nIn all the scanning functions, if an operand implements method\nScan (that is, it implements the Scanner interface) that\nmethod will be used to scan the text for that operand.  Also,\nif the number of arguments scanned is less than the number of\narguments provided, an error is returned.\n\nAll arguments to be scanned must be either pointers to basic\ntypes or implementations of the Scanner interface.\n\nLike Scanf and Fscanf, Sscanf need not consume its entire input.\nThere is no way to recover how much of the input string Sscanf used.\n\nNote: Fscan etc. can read one character (rune) past the input\nthey return, which means that a loop calling a scan routine\nmay skip some of the input.  This is usually a problem only\nwhen there is no space between input values.  If the reader\nprovided to Fscan implements ReadRune, that method will be used\nto read characters.  If the reader also implements UnreadRune,\nthat method will be used to save the character and successive\ncalls will not lose data.  To attach ReadRune and UnreadRune\nmethods to a reader without that capability, use\nbufio.NewReader.\n\n[\"fmt\" on pkg.go.dev](https://pkg.go.dev/fmt)",
    "url": "https://pkg.go.dev/fmt",
    "path": "fmt",
    "children": []
  },
  {
    "name": "go",
    "synopsis": "",
    "url": "https://pkg.go.dev/go",
    "path": "go",
    "children": [
      {
        "name": "ast",
        "synopsis": "Package ast declares the types used to represent syntax trees for Go\npackages.\n\n[\"go/ast\" on pkg.go.dev](https://pkg.go.dev/go/ast)",
        "url": "https://pkg.go.dev/go/ast",
        "path": "go/ast",
        "children": []
      },
      {
        "name": "build",
        "synopsis": "Package build gathers information about Go packages.\n\nGo Path\n\nThe Go path is a list of directory trees containing Go source code.\nIt is consulted to resolve imports that cannot be found in the standard\nGo tree. The default path is the value of the GOPATH environment\nvariable, interpreted as a path list appropriate to the operating system\n(on Unix, the variable is a colon-separated string;\non Windows, a semicolon-separated string;\non Plan 9, a list).\n\nEach directory listed in the Go path must have a prescribed structure:\n\nThe src/ directory holds source code. The path below 'src' determines\nthe import path or executable name.\n\nThe pkg/ directory holds installed package objects.\nAs in the Go tree, each target operating system and\narchitecture pair has its own subdirectory of pkg\n(pkg/GOOS_GOARCH).\n\nIf DIR is a directory listed in the Go path, a package with\nsource in DIR/src/foo/bar can be imported as \"foo/bar\" and\nhas its compiled form installed to \"DIR/pkg/GOOS_GOARCH/foo/bar.a\"\n(or, for gccgo, \"DIR/pkg/gccgo/foo/libbar.a\").\n\nThe bin/ directory holds compiled commands.\nEach command is named for its source directory, but only\nusing the final element, not the entire path. That is, the\ncommand with source in DIR/src/foo/quux is installed into\nDIR/bin/quux, not DIR/bin/foo/quux. The foo/ is stripped\nso that you can add DIR/bin to your PATH to get at the\ninstalled commands.\n\nHere's an example directory layout:\n\n```\nGOPATH=/home/user/gocode\n\n/home/user/gocode/\n    src/\n        foo/\n            bar/               (go code in package bar)\n                x.go\n            quux/              (go code in package main)\n                y.go\n    bin/\n        quux                   (installed command)\n    pkg/\n        linux_amd64/\n            foo/\n                bar.a          (installed package object)\n\n```\nBuild Constraints\n\nA build constraint, also known as a build tag, is a line comment that begins\n\n```\n//go:build\n\n```\nthat lists the conditions under which a file should be included in the\npackage. Build constraints may also be part of a file's name\n(for example, source_windows.go will only be included if the target\noperating system is windows).\n\nSee 'go help buildconstraint'\n(https://golang.org/cmd/go/#hdr-Build_constraints) for details.\n\nBinary-Only Packages\n\nIn Go 1.12 and earlier, it was possible to distribute packages in binary\nform without including the source code used for compiling the package.\nThe package was distributed with a source file not excluded by build\nconstraints and containing a \"//go:binary-only-package\" comment. Like a\nbuild constraint, this comment appeared at the top of a file, preceded\nonly by blank lines and other line comments and with a blank line\nfollowing the comment, to separate it from the package documentation.\nUnlike build constraints, this comment is only recognized in non-test\nGo source files.\n\nThe minimal source code for a binary-only package was therefore:\n\n```\n//go:binary-only-package\n\npackage mypkg\n\n```\nThe source code could include additional Go code. That code was never\ncompiled but would be processed by tools like godoc and might be useful\nas end-user documentation.\n\n\"go build\" and other commands no longer support binary-only-packages.\nImport and ImportDir will still set the BinaryOnly flag in packages\ncontaining these comments for use in tools and error messages.\n\n[\"go/build\" on pkg.go.dev](https://pkg.go.dev/go/build)",
        "url": "https://pkg.go.dev/go/build",
        "path": "go/build",
        "children": [
          {
            "name": "constraint",
            "synopsis": "Package constraint implements parsing and evaluation of build constraint lines.\nSee https://golang.org/cmd/go/#hdr-Build_constraints for documentation about build constraints themselves.\n\nThis package parses both the original “// +build” syntax and the “//go:build” syntax that will be added in Go 1.17.\nThe parser is being included in Go 1.16 to allow tools that need to process Go 1.17 source code\nto still be built against the Go 1.16 release.\nSee https://golang.org/design/draft-gobuild for details about the “//go:build” syntax.\n\n[\"go/build/constraint\" on pkg.go.dev](https://pkg.go.dev/go/build/constraint)",
            "url": "https://pkg.go.dev/go/build/constraint",
            "path": "go/build/constraint",
            "children": []
          }
        ]
      },
      {
        "name": "constant",
        "synopsis": "Package constant implements Values representing untyped\nGo constants and their corresponding operations.\n\nA special Unknown value may be used when a value\nis unknown due to an error. Operations on unknown\nvalues produce unknown values unless specified\notherwise.\n\n[\"go/constant\" on pkg.go.dev](https://pkg.go.dev/go/constant)",
        "url": "https://pkg.go.dev/go/constant",
        "path": "go/constant",
        "children": []
      },
      {
        "name": "doc",
        "synopsis": "Package doc extracts source code documentation from a Go AST.\n\n[\"go/doc\" on pkg.go.dev](https://pkg.go.dev/go/doc)",
        "url": "https://pkg.go.dev/go/doc",
        "path": "go/doc",
        "children": []
      },
      {
        "name": "format",
        "synopsis": "Package format implements standard formatting of Go source.\n\nNote that formatting of Go source code changes over time, so tools relying on\nconsistent formatting should execute a specific version of the gofmt binary\ninstead of using this package. That way, the formatting will be stable, and\nthe tools won't need to be recompiled each time gofmt changes.\n\nFor example, pre-submit checks that use this package directly would behave\ndifferently depending on what Go version each developer uses, causing the\ncheck to be inherently fragile.\n\n[\"go/format\" on pkg.go.dev](https://pkg.go.dev/go/format)",
        "url": "https://pkg.go.dev/go/format",
        "path": "go/format",
        "children": []
      },
      {
        "name": "importer",
        "synopsis": "Package importer provides access to export data importers.\n\n[\"go/importer\" on pkg.go.dev](https://pkg.go.dev/go/importer)",
        "url": "https://pkg.go.dev/go/importer",
        "path": "go/importer",
        "children": []
      },
      {
        "name": "parser",
        "synopsis": "Package parser implements a parser for Go source files. Input may be\nprovided in a variety of forms (see the various Parse* functions); the\noutput is an abstract syntax tree (AST) representing the Go source. The\nparser is invoked through one of the Parse* functions.\n\nThe parser accepts a larger language than is syntactically permitted by\nthe Go spec, for simplicity, and for improved robustness in the presence\nof syntax errors. For instance, in method declarations, the receiver is\ntreated like an ordinary parameter list and thus may contain multiple\nentries where the spec permits exactly one. Consequently, the corresponding\nfield in the AST (ast.FuncDecl.Recv) field is not restricted to one entry.\n\n[\"go/parser\" on pkg.go.dev](https://pkg.go.dev/go/parser)",
        "url": "https://pkg.go.dev/go/parser",
        "path": "go/parser",
        "children": []
      },
      {
        "name": "printer",
        "synopsis": "Package printer implements printing of AST nodes.\n\n[\"go/printer\" on pkg.go.dev](https://pkg.go.dev/go/printer)",
        "url": "https://pkg.go.dev/go/printer",
        "path": "go/printer",
        "children": []
      },
      {
        "name": "scanner",
        "synopsis": "Package scanner implements a scanner for Go source text.\nIt takes a []byte as source which can then be tokenized\nthrough repeated calls to the Scan method.\n\n[\"go/scanner\" on pkg.go.dev](https://pkg.go.dev/go/scanner)",
        "url": "https://pkg.go.dev/go/scanner",
        "path": "go/scanner",
        "children": []
      },
      {
        "name": "token",
        "synopsis": "Package token defines constants representing the lexical tokens of the Go\nprogramming language and basic operations on tokens (printing, predicates).\n\n[\"go/token\" on pkg.go.dev](https://pkg.go.dev/go/token)",
        "url": "https://pkg.go.dev/go/token",
        "path": "go/token",
        "children": []
      },
      {
        "name": "types",
        "synopsis": "Package types declares the data types and implements\nthe algorithms for type-checking of Go packages. Use\nConfig.Check to invoke the type checker for a package.\nAlternatively, create a new type checker with NewChecker\nand invoke it incrementally by calling Checker.Files.\n\nType-checking consists of several interdependent phases:\n\nName resolution maps each identifier (ast.Ident) in the program to the\nlanguage object (Object) it denotes.\nUse Info.{Defs,Uses,Implicits} for the results of name resolution.\n\nConstant folding computes the exact constant value (constant.Value)\nfor every expression (ast.Expr) that is a compile-time constant.\nUse Info.Types[expr].Value for the results of constant folding.\n\nType inference computes the type (Type) of every expression (ast.Expr)\nand checks for compliance with the language specification.\nUse Info.Types[expr].Type for the results of type inference.\n\nFor a tutorial, see https://golang.org/s/types-tutorial.\n\n[\"go/types\" on pkg.go.dev](https://pkg.go.dev/go/types)",
        "url": "https://pkg.go.dev/go/types",
        "path": "go/types",
        "children": []
      }
    ]
  },
  {
    "name": "hash",
    "synopsis": "Package hash provides interfaces for hash functions.\n\n[\"hash\" on pkg.go.dev](https://pkg.go.dev/hash)",
    "url": "https://pkg.go.dev/hash",
    "path": "hash",
    "children": [
      {
        "name": "adler32",
        "synopsis": "Package adler32 implements the Adler-32 checksum.\n\nIt is defined in RFC 1950:\n```\nAdler-32 is composed of two sums accumulated per byte: s1 is\nthe sum of all bytes, s2 is the sum of all s1 values. Both sums\nare done modulo 65521. s1 is initialized to 1, s2 to zero.  The\nAdler-32 checksum is stored as s2*65536 + s1 in most-\nsignificant-byte first (network) order.\n\n[\"hash/adler32\" on pkg.go.dev](https://pkg.go.dev/hash/adler32)",
        "url": "https://pkg.go.dev/hash/adler32",
        "path": "hash/adler32",
        "children": []
      },
      {
        "name": "crc32",
        "synopsis": "Package crc32 implements the 32-bit cyclic redundancy check, or CRC-32,\nchecksum. See https://en.wikipedia.org/wiki/Cyclic_redundancy_check for\ninformation.\n\nPolynomials are represented in LSB-first form also known as reversed representation.\n\nSee https://en.wikipedia.org/wiki/Mathematics_of_cyclic_redundancy_checks#Reversed_representations_and_reciprocal_polynomials\nfor information.\n\n[\"hash/crc32\" on pkg.go.dev](https://pkg.go.dev/hash/crc32)",
        "url": "https://pkg.go.dev/hash/crc32",
        "path": "hash/crc32",
        "children": []
      },
      {
        "name": "crc64",
        "synopsis": "Package crc64 implements the 64-bit cyclic redundancy check, or CRC-64,\nchecksum. See https://en.wikipedia.org/wiki/Cyclic_redundancy_check for\ninformation.\n\n[\"hash/crc64\" on pkg.go.dev](https://pkg.go.dev/hash/crc64)",
        "url": "https://pkg.go.dev/hash/crc64",
        "path": "hash/crc64",
        "children": []
      },
      {
        "name": "fnv",
        "synopsis": "Package fnv implements FNV-1 and FNV-1a, non-cryptographic hash functions\ncreated by Glenn Fowler, Landon Curt Noll, and Phong Vo.\nSee\nhttps://en.wikipedia.org/wiki/Fowler-Noll-Vo_hash_function.\n\nAll the hash.Hash implementations returned by this package also\nimplement encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to\nmarshal and unmarshal the internal state of the hash.\n\n[\"hash/fnv\" on pkg.go.dev](https://pkg.go.dev/hash/fnv)",
        "url": "https://pkg.go.dev/hash/fnv",
        "path": "hash/fnv",
        "children": []
      },
      {
        "name": "maphash",
        "synopsis": "Package maphash provides hash functions on byte sequences.\nThese hash functions are intended to be used to implement hash tables or\nother data structures that need to map arbitrary strings or byte\nsequences to a uniform distribution on unsigned 64-bit integers.\nEach different instance of a hash table or data structure should use its own Seed.\n\nThe hash functions are not cryptographically secure.\n(See crypto/sha256 and crypto/sha512 for cryptographic use.)\n\n[\"hash/maphash\" on pkg.go.dev](https://pkg.go.dev/hash/maphash)",
        "url": "https://pkg.go.dev/hash/maphash",
        "path": "hash/maphash",
        "children": []
      }
    ]
  },
  {
    "name": "html",
    "synopsis": "Package html provides functions for escaping and unescaping HTML text.\n\n[\"html\" on pkg.go.dev](https://pkg.go.dev/html)",
    "url": "https://pkg.go.dev/html",
    "path": "html",
    "children": [
      {
        "name": "template",
        "synopsis": "Package template (html/template) implements data-driven templates for\ngenerating HTML output safe against code injection. It provides the\nsame interface as package text/template and should be used instead of\ntext/template whenever the output is HTML.\n\nThe documentation here focuses on the security features of the package.\nFor information about how to program the templates themselves, see the\ndocumentation for text/template.\n\nIntroduction\n\nThis package wraps package text/template so you can share its template API\nto parse and execute HTML templates safely.\n\n  tmpl, err := template.New(\"name\").Parse(...)\n  // Error checking elided\n  err = tmpl.Execute(out, data)\n\nIf successful, tmpl will now be injection-safe. Otherwise, err is an error\ndefined in the docs for ErrorCode.\n\nHTML templates treat data values as plain text which should be encoded so they\ncan be safely embedded in an HTML document. The escaping is contextual, so\nactions can appear within JavaScript, CSS, and URI contexts.\n\nThe security model used by this package assumes that template authors are\ntrusted, while Execute's data parameter is not. More details are\nprovided below.\n\nExample\n\n  import \"text/template\"\n  ...\n  t, err := template.New(\"foo\").Parse(`{{define \"T\"}}Hello, {{.}}!{{end}}`)\n  err = t.ExecuteTemplate(out, \"T\", \"\u003cscript\u003ealert('you have been pwned')\u003c/script\u003e\")\n\nproduces\n\n  Hello, \u003cscript\u003ealert('you have been pwned')\u003c/script\u003e!\n\nbut the contextual autoescaping in html/template\n\n  import \"html/template\"\n  ...\n  t, err := template.New(\"foo\").Parse(`{{define \"T\"}}Hello, {{.}}!{{end}}`)\n  err = t.ExecuteTemplate(out, \"T\", \"\u003cscript\u003ealert('you have been pwned')\u003c/script\u003e\")\n\nproduces safe, escaped HTML output\n\n  Hello, \u0026lt;script\u0026gt;alert(\u0026#39;you have been pwned\u0026#39;)\u0026lt;/script\u0026gt;!\n\nContexts\n\nThis package understands HTML, CSS, JavaScript, and URIs. It adds sanitizing\nfunctions to each simple action pipeline, so given the excerpt\n\n  \u003ca href=\"/search?q={{.}}\"\u003e{{.}}\u003c/a\u003e\n\nAt parse time each {{.}} is overwritten to add escaping functions as necessary.\nIn this case it becomes\n\n  \u003ca href=\"/search?q={{. | urlescaper | attrescaper}}\"\u003e{{. | htmlescaper}}\u003c/a\u003e\n\nwhere urlescaper, attrescaper, and htmlescaper are aliases for internal escaping\nfunctions.\n\nFor these internal escaping functions, if an action pipeline evaluates to\na nil interface value, it is treated as though it were an empty string.\n\nNamespaced and data- attributes\n\nAttributes with a namespace are treated as if they had no namespace.\nGiven the excerpt\n\n  \u003ca my:href=\"{{.}}\"\u003e\u003c/a\u003e\n\nAt parse time the attribute will be treated as if it were just \"href\".\nSo at parse time the template becomes:\n\n  \u003ca my:href=\"{{. | urlescaper | attrescaper}}\"\u003e\u003c/a\u003e\n\nSimilarly to attributes with namespaces, attributes with a \"data-\" prefix are\ntreated as if they had no \"data-\" prefix. So given\n\n  \u003ca data-href=\"{{.}}\"\u003e\u003c/a\u003e\n\nAt parse time this becomes\n\n  \u003ca data-href=\"{{. | urlescaper | attrescaper}}\"\u003e\u003c/a\u003e\n\nIf an attribute has both a namespace and a \"data-\" prefix, only the namespace\nwill be removed when determining the context. For example\n\n  \u003ca my:data-href=\"{{.}}\"\u003e\u003c/a\u003e\n\nThis is handled as if \"my:data-href\" was just \"data-href\" and not \"href\" as\nit would be if the \"data-\" prefix were to be ignored too. Thus at parse\ntime this becomes just\n\n  \u003ca my:data-href=\"{{. | attrescaper}}\"\u003e\u003c/a\u003e\n\nAs a special case, attributes with the namespace \"xmlns\" are always treated\nas containing URLs. Given the excerpts\n\n  \u003ca xmlns:title=\"{{.}}\"\u003e\u003c/a\u003e\n  \u003ca xmlns:href=\"{{.}}\"\u003e\u003c/a\u003e\n  \u003ca xmlns:onclick=\"{{.}}\"\u003e\u003c/a\u003e\n\nAt parse time they become:\n\n  \u003ca xmlns:title=\"{{. | urlescaper | attrescaper}}\"\u003e\u003c/a\u003e\n  \u003ca xmlns:href=\"{{. | urlescaper | attrescaper}}\"\u003e\u003c/a\u003e\n  \u003ca xmlns:onclick=\"{{. | urlescaper | attrescaper}}\"\u003e\u003c/a\u003e\n\nErrors\n\nSee the documentation of ErrorCode for details.\n\nA fuller picture\n\nThe rest of this package comment may be skipped on first reading; it includes\ndetails necessary to understand escaping contexts and error messages. Most users\nwill not need to understand these details.\n\nContexts\n\nAssuming {{.}} is `O'Reilly: How are \u003ci\u003eyou\u003c/i\u003e?`, the table below shows\nhow {{.}} appears when used in the context to the left.\n\n  Context                          {{.}} After\n  {{.}}                            O'Reilly: How are \u0026lt;i\u0026gt;you\u0026lt;/i\u0026gt;?\n  \u003ca title='{{.}}'\u003e                O\u0026#39;Reilly: How are you?\n  \u003ca href=\"/{{.}}\"\u003e                O\u0026#39;Reilly: How are %3ci%3eyou%3c/i%3e?\n  \u003ca href=\"?q={{.}}\"\u003e              O\u0026#39;Reilly%3a%20How%20are%3ci%3e...%3f\n  \u003ca onx='f(\"{{.}}\")'\u003e             O\\x27Reilly: How are \\x3ci\\x3eyou...?\n  \u003ca onx='f({{.}})'\u003e               \"O\\x27Reilly: How are \\x3ci\\x3eyou...?\"\n  \u003ca onx='pattern = /{{.}}/;'\u003e     O\\x27Reilly: How are \\x3ci\\x3eyou...\\x3f\n\nIf used in an unsafe context, then the value might be filtered out:\n\n  Context                          {{.}} After\n  \u003ca href=\"{{.}}\"\u003e                 #ZgotmplZ\n\nsince \"O'Reilly:\" is not an allowed protocol like \"http:\".\n\nIf {{.}} is the innocuous word, `left`, then it can appear more widely,\n\n  Context                              {{.}} After\n  {{.}}                                left\n  \u003ca title='{{.}}'\u003e                    left\n  \u003ca href='{{.}}'\u003e                     left\n  \u003ca href='/{{.}}'\u003e                    left\n  \u003ca href='?dir={{.}}'\u003e                left\n  \u003ca style=\"border-{{.}}: 4px\"\u003e        left\n  \u003ca style=\"align: {{.}}\"\u003e             left\n  \u003ca style=\"background: '{{.}}'\u003e       left\n  \u003ca style=\"background: url('{{.}}')\u003e  left\n  \u003cstyle\u003ep.{{.}} {color:red}\u003c/style\u003e   left\n\nNon-string values can be used in JavaScript contexts.\nIf {{.}} is\n\n  struct{A,B string}{ \"foo\", \"bar\" }\n\nin the escaped template\n\n  \u003cscript\u003evar pair = {{.}};\u003c/script\u003e\n\nthen the template output is\n\n  \u003cscript\u003evar pair = {\"A\": \"foo\", \"B\": \"bar\"};\u003c/script\u003e\n\nSee package json to understand how non-string content is marshaled for\nembedding in JavaScript contexts.\n\nTyped Strings\n\nBy default, this package assumes that all pipelines produce a plain text string.\nIt adds escaping pipeline stages necessary to correctly and safely embed that\nplain text string in the appropriate context.\n\nWhen a data value is not plain text, you can make sure it is not over-escaped\nby marking it with its type.\n\nTypes HTML, JS, URL, and others from content.go can carry safe content that is\nexempted from escaping.\n\nThe template\n\n  Hello, {{.}}!\n\ncan be invoked with\n\n  tmpl.Execute(out, template.HTML(`\u003cb\u003eWorld\u003c/b\u003e`))\n\nto produce\n\n  Hello, \u003cb\u003eWorld\u003c/b\u003e!\n\ninstead of the\n\n  Hello, \u0026lt;b\u0026gt;World\u0026lt;b\u0026gt;!\n\nthat would have been produced if {{.}} was a regular string.\n\nSecurity Model\n\nhttps://rawgit.com/mikesamuel/sanitized-jquery-templates/trunk/safetemplate.html#problem_definition defines \"safe\" as used by this package.\n\nThis package assumes that template authors are trusted, that Execute's data\nparameter is not, and seeks to preserve the properties below in the face\nof untrusted data:\n\nStructure Preservation Property:\n\"... when a template author writes an HTML tag in a safe templating language,\nthe browser will interpret the corresponding portion of the output as a tag\nregardless of the values of untrusted data, and similarly for other structures\nsuch as attribute boundaries and JS and CSS string boundaries.\"\n\nCode Effect Property:\n\"... only code specified by the template author should run as a result of\ninjecting the template output into a page and all code specified by the\ntemplate author should run as a result of the same.\"\n\nLeast Surprise Property:\n\"A developer (or code reviewer) familiar with HTML, CSS, and JavaScript, who\nknows that contextual autoescaping happens should be able to look at a {{.}}\nand correctly infer what sanitization happens.\"\n\n[\"html/template\" on pkg.go.dev](https://pkg.go.dev/html/template)",
        "url": "https://pkg.go.dev/html/template",
        "path": "html/template",
        "children": []
      }
    ]
  },
  {
    "name": "image",
    "synopsis": "Package image implements a basic 2-D image library.\n\nThe fundamental interface is called Image. An Image contains colors, which\nare described in the image/color package.\n\nValues of the Image interface are created either by calling functions such\nas NewRGBA and NewPaletted, or by calling Decode on an io.Reader containing\nimage data in a format such as GIF, JPEG or PNG. Decoding any particular\nimage format requires the prior registration of a decoder function.\nRegistration is typically automatic as a side effect of initializing that\nformat's package so that, to decode a PNG image, it suffices to have\n```\nimport _ \"image/png\"\n```\nin a program's main package. The _ means to import a package purely for its\ninitialization side effects.\n\nSee \"The Go image package\" for more details:\nhttps://golang.org/doc/articles/image_package.html\n\n[\"image\" on pkg.go.dev](https://pkg.go.dev/image)",
    "url": "https://pkg.go.dev/image",
    "path": "image",
    "children": [
      {
        "name": "color",
        "synopsis": "Package color implements a basic color library.\n\n[\"image/color\" on pkg.go.dev](https://pkg.go.dev/image/color)",
        "url": "https://pkg.go.dev/image/color",
        "path": "image/color",
        "children": [
          {
            "name": "palette",
            "synopsis": "Package palette provides standard color palettes.\n\n[\"image/color/palette\" on pkg.go.dev](https://pkg.go.dev/image/color/palette)",
            "url": "https://pkg.go.dev/image/color/palette",
            "path": "image/color/palette",
            "children": []
          }
        ]
      },
      {
        "name": "draw",
        "synopsis": "Package draw provides image composition functions.\n\nSee \"The Go image/draw package\" for an introduction to this package:\nhttps://golang.org/doc/articles/image_draw.html\n\n[\"image/draw\" on pkg.go.dev](https://pkg.go.dev/image/draw)",
        "url": "https://pkg.go.dev/image/draw",
        "path": "image/draw",
        "children": []
      },
      {
        "name": "gif",
        "synopsis": "Package gif implements a GIF image decoder and encoder.\n\nThe GIF specification is at https://www.w3.org/Graphics/GIF/spec-gif89a.txt.\n\n[\"image/gif\" on pkg.go.dev](https://pkg.go.dev/image/gif)",
        "url": "https://pkg.go.dev/image/gif",
        "path": "image/gif",
        "children": []
      },
      {
        "name": "jpeg",
        "synopsis": "Package jpeg implements a JPEG image decoder and encoder.\n\nJPEG is defined in ITU-T T.81: https://www.w3.org/Graphics/JPEG/itu-t81.pdf.\n\n[\"image/jpeg\" on pkg.go.dev](https://pkg.go.dev/image/jpeg)",
        "url": "https://pkg.go.dev/image/jpeg",
        "path": "image/jpeg",
        "children": []
      },
      {
        "name": "png",
        "synopsis": "Package png implements a PNG image decoder and encoder.\n\nThe PNG specification is at https://www.w3.org/TR/PNG/.\n\n[\"image/png\" on pkg.go.dev](https://pkg.go.dev/image/png)",
        "url": "https://pkg.go.dev/image/png",
        "path": "image/png",
        "children": []
      }
    ]
  },
  {
    "name": "index",
    "synopsis": "",
    "url": "https://pkg.go.dev/index",
    "path": "index",
    "children": [
      {
        "name": "suffixarray",
        "synopsis": "Package suffixarray implements substring search in logarithmic time using\nan in-memory suffix array.\n\nExample use:\n\n```\n// create index for some data\nindex := suffixarray.New(data)\n\n// lookup byte slice s\noffsets1 := index.Lookup(s, -1) // the list of all indices where s occurs in data\noffsets2 := index.Lookup(s, 3)  // the list of at most 3 indices where s occurs in data\n\n[\"index/suffixarray\" on pkg.go.dev](https://pkg.go.dev/index/suffixarray)",
        "url": "https://pkg.go.dev/index/suffixarray",
        "path": "index/suffixarray",
        "children": []
      }
    ]
  },
  {
    "name": "io",
    "synopsis": "Package io provides basic interfaces to I/O primitives.\nIts primary job is to wrap existing implementations of such primitives,\nsuch as those in package os, into shared public interfaces that\nabstract the functionality, plus some other related primitives.\n\nBecause these interfaces and primitives wrap lower-level operations with\nvarious implementations, unless otherwise informed clients should not\nassume they are safe for parallel execution.\n\n[\"io\" on pkg.go.dev](https://pkg.go.dev/io)",
    "url": "https://pkg.go.dev/io",
    "path": "io",
    "children": [
      {
        "name": "fs",
        "synopsis": "Package fs defines basic interfaces to a file system.\nA file system can be provided by the host operating system\nbut also by other packages.\n\n[\"io/fs\" on pkg.go.dev](https://pkg.go.dev/io/fs)",
        "url": "https://pkg.go.dev/io/fs",
        "path": "io/fs",
        "children": []
      },
      {
        "name": "ioutil",
        "synopsis": "Package ioutil implements some I/O utility functions.\n\nAs of Go 1.16, the same functionality is now provided\nby package io or package os, and those implementations\nshould be preferred in new code.\nSee the specific function documentation for details.\n\n[\"io/ioutil\" on pkg.go.dev](https://pkg.go.dev/io/ioutil)",
        "url": "https://pkg.go.dev/io/ioutil",
        "path": "io/ioutil",
        "children": []
      }
    ]
  },
  {
    "name": "log",
    "synopsis": "Package log implements a simple logging package. It defines a type, Logger,\nwith methods for formatting output. It also has a predefined 'standard'\nLogger accessible through helper functions Print[f|ln], Fatal[f|ln], and\nPanic[f|ln], which are easier to use than creating a Logger manually.\nThat logger writes to standard error and prints the date and time\nof each logged message.\nEvery log message is output on a separate line: if the message being\nprinted does not end in a newline, the logger will add one.\nThe Fatal functions call os.Exit(1) after writing the log message.\nThe Panic functions call panic after writing the log message.\n\n[\"log\" on pkg.go.dev](https://pkg.go.dev/log)",
    "url": "https://pkg.go.dev/log",
    "path": "log",
    "children": [
      {
        "name": "syslog",
        "synopsis": "Package syslog provides a simple interface to the system log\nservice. It can send messages to the syslog daemon using UNIX\ndomain sockets, UDP or TCP.\n\nOnly one call to Dial is necessary. On write failures,\nthe syslog client will attempt to reconnect to the server\nand write again.\n\nThe syslog package is frozen and is not accepting new features.\nSome external packages provide more functionality. See:\n\n  https://godoc.org/?q=syslog\n\n[\"log/syslog\" on pkg.go.dev](https://pkg.go.dev/log/syslog)",
        "url": "https://pkg.go.dev/log/syslog",
        "path": "log/syslog",
        "children": []
      }
    ]
  },
  {
    "name": "math",
    "synopsis": "Package math provides basic constants and mathematical functions.\n\nThis package does not guarantee bit-identical results across architectures.\n\n[\"math\" on pkg.go.dev](https://pkg.go.dev/math)",
    "url": "https://pkg.go.dev/math",
    "path": "math",
    "children": [
      {
        "name": "big",
        "synopsis": "Package big implements arbitrary-precision arithmetic (big numbers).\nThe following numeric types are supported:\n\n```\nInt    signed integers\nRat    rational numbers\nFloat  floating-point numbers\n\n```\nThe zero value for an Int, Rat, or Float correspond to 0. Thus, new\nvalues can be declared in the usual ways and denote 0 without further\ninitialization:\n\n```\nvar x Int        // \u0026x is an *Int of value 0\nvar r = \u0026Rat{}   // r is a *Rat of value 0\ny := new(Float)  // y is a *Float of value 0\n\n```\nAlternatively, new values can be allocated and initialized with factory\nfunctions of the form:\n\n```\nfunc NewT(v V) *T\n\n```\nFor instance, NewInt(x) returns an *Int set to the value of the int64\nargument x, NewRat(a, b) returns a *Rat set to the fraction a/b where\na and b are int64 values, and NewFloat(f) returns a *Float initialized\nto the float64 argument f. More flexibility is provided with explicit\nsetters, for instance:\n\n```\nvar z1 Int\nz1.SetUint64(123)                 // z1 := 123\nz2 := new(Rat).SetFloat64(1.25)   // z2 := 5/4\nz3 := new(Float).SetInt(z1)       // z3 := 123.0\n\n```\nSetters, numeric operations and predicates are represented as methods of\nthe form:\n\n```\nfunc (z *T) SetV(v V) *T          // z = v\nfunc (z *T) Unary(x *T) *T        // z = unary x\nfunc (z *T) Binary(x, y *T) *T    // z = x binary y\nfunc (x *T) Pred() P              // p = pred(x)\n\n```\nwith T one of Int, Rat, or Float. For unary and binary operations, the\nresult is the receiver (usually named z in that case; see below); if it\nis one of the operands x or y it may be safely overwritten (and its memory\nreused).\n\nArithmetic expressions are typically written as a sequence of individual\nmethod calls, with each call corresponding to an operation. The receiver\ndenotes the result and the method arguments are the operation's operands.\nFor instance, given three *Int values a, b and c, the invocation\n\n```\nc.Add(a, b)\n\n```\ncomputes the sum a + b and stores the result in c, overwriting whatever\nvalue was held in c before. Unless specified otherwise, operations permit\naliasing of parameters, so it is perfectly ok to write\n\n```\nsum.Add(sum, x)\n\n```\nto accumulate values x in a sum.\n\n(By always passing in a result value via the receiver, memory use can be\nmuch better controlled. Instead of having to allocate new memory for each\nresult, an operation can reuse the space allocated for the result value,\nand overwrite that value with the new result in the process.)\n\nNotational convention: Incoming method parameters (including the receiver)\nare named consistently in the API to clarify their use. Incoming operands\nare usually named x, y, a, b, and so on, but never z. A parameter specifying\nthe result is named z (typically the receiver).\n\nFor instance, the arguments for (*Int).Add are named x and y, and because\nthe receiver specifies the result destination, it is called z:\n\n```\nfunc (z *Int) Add(x, y *Int) *Int\n\n```\nMethods of this form typically return the incoming receiver as well, to\nenable simple call chaining.\n\nMethods which don't require a result value to be passed in (for instance,\nInt.Sign), simply return the result. In this case, the receiver is typically\nthe first operand, named x:\n\n```\nfunc (x *Int) Sign() int\n\n```\nVarious methods support conversions between strings and corresponding\nnumeric values, and vice versa: *Int, *Rat, and *Float values implement\nthe Stringer interface for a (default) string representation of the value,\nbut also provide SetString methods to initialize a value from a string in\na variety of supported formats (see the respective SetString documentation).\n\nFinally, *Int, *Rat, and *Float satisfy the fmt package's Scanner interface\nfor scanning and (except for *Rat) the Formatter interface for formatted\nprinting.\n\n[\"math/big\" on pkg.go.dev](https://pkg.go.dev/math/big)",
        "url": "https://pkg.go.dev/math/big",
        "path": "math/big",
        "children": []
      },
      {
        "name": "bits",
        "synopsis": "Package bits implements bit counting and manipulation\nfunctions for the predeclared unsigned integer types.\n\n[\"math/bits\" on pkg.go.dev](https://pkg.go.dev/math/bits)",
        "url": "https://pkg.go.dev/math/bits",
        "path": "math/bits",
        "children": []
      },
      {
        "name": "cmplx",
        "synopsis": "Package cmplx provides basic constants and mathematical functions for\ncomplex numbers. Special case handling conforms to the C99 standard\nAnnex G IEC 60559-compatible complex arithmetic.\n\n[\"math/cmplx\" on pkg.go.dev](https://pkg.go.dev/math/cmplx)",
        "url": "https://pkg.go.dev/math/cmplx",
        "path": "math/cmplx",
        "children": []
      },
      {
        "name": "rand",
        "synopsis": "Package rand implements pseudo-random number generators unsuitable for\nsecurity-sensitive work.\n\nRandom numbers are generated by a Source. Top-level functions, such as\nFloat64 and Int, use a default shared Source that produces a deterministic\nsequence of values each time a program is run. Use the Seed function to\ninitialize the default Source if different behavior is required for each run.\nThe default Source is safe for concurrent use by multiple goroutines, but\nSources created by NewSource are not.\n\nThis package's outputs might be easily predictable regardless of how it's\nseeded. For random numbers suitable for security-sensitive work, see the\ncrypto/rand package.\n\n[\"math/rand\" on pkg.go.dev](https://pkg.go.dev/math/rand)",
        "url": "https://pkg.go.dev/math/rand",
        "path": "math/rand",
        "children": []
      }
    ]
  },
  {
    "name": "mime",
    "synopsis": "Package mime implements parts of the MIME spec.\n\n[\"mime\" on pkg.go.dev](https://pkg.go.dev/mime)",
    "url": "https://pkg.go.dev/mime",
    "path": "mime",
    "children": [
      {
        "name": "multipart",
        "synopsis": "Package multipart implements MIME multipart parsing, as defined in RFC\n2046.\n\nThe implementation is sufficient for HTTP (RFC 2388) and the multipart\nbodies generated by popular browsers.\n\n[\"mime/multipart\" on pkg.go.dev](https://pkg.go.dev/mime/multipart)",
        "url": "https://pkg.go.dev/mime/multipart",
        "path": "mime/multipart",
        "children": []
      },
      {
        "name": "quotedprintable",
        "synopsis": "Package quotedprintable implements quoted-printable encoding as specified by\nRFC 2045.\n\n[\"mime/quotedprintable\" on pkg.go.dev](https://pkg.go.dev/mime/quotedprintable)",
        "url": "https://pkg.go.dev/mime/quotedprintable",
        "path": "mime/quotedprintable",
        "children": []
      }
    ]
  },
  {
    "name": "net",
    "synopsis": "Package net provides a portable interface for network I/O, including\nTCP/IP, UDP, domain name resolution, and Unix domain sockets.\n\nAlthough the package provides access to low-level networking\nprimitives, most clients will need only the basic interface provided\nby the Dial, Listen, and Accept functions and the associated\nConn and Listener interfaces. The crypto/tls package uses\nthe same interfaces and similar Dial and Listen functions.\n\nThe Dial function connects to a server:\n\n```\nconn, err := net.Dial(\"tcp\", \"golang.org:80\")\nif err != nil {\n\t// handle error\n}\nfmt.Fprintf(conn, \"GET / HTTP/1.0\\r\\n\\r\\n\")\nstatus, err := bufio.NewReader(conn).ReadString('\\n')\n// ...\n\n```\nThe Listen function creates servers:\n\n```\nln, err := net.Listen(\"tcp\", \":8080\")\nif err != nil {\n\t// handle error\n}\nfor {\n\tconn, err := ln.Accept()\n\tif err != nil {\n\t\t// handle error\n\t}\n\tgo handleConnection(conn)\n}\n\n```\nName Resolution\n\nThe method for resolving domain names, whether indirectly with functions like Dial\nor directly with functions like LookupHost and LookupAddr, varies by operating system.\n\nOn Unix systems, the resolver has two options for resolving names.\nIt can use a pure Go resolver that sends DNS requests directly to the servers\nlisted in /etc/resolv.conf, or it can use a cgo-based resolver that calls C\nlibrary routines such as getaddrinfo and getnameinfo.\n\nBy default the pure Go resolver is used, because a blocked DNS request consumes\nonly a goroutine, while a blocked C call consumes an operating system thread.\nWhen cgo is available, the cgo-based resolver is used instead under a variety of\nconditions: on systems that do not let programs make direct DNS requests (OS X),\nwhen the LOCALDOMAIN environment variable is present (even if empty),\nwhen the RES_OPTIONS or HOSTALIASES environment variable is non-empty,\nwhen the ASR_CONFIG environment variable is non-empty (OpenBSD only),\nwhen /etc/resolv.conf or /etc/nsswitch.conf specify the use of features that the\nGo resolver does not implement, and when the name being looked up ends in .local\nor is an mDNS name.\n\nThe resolver decision can be overridden by setting the netdns value of the\nGODEBUG environment variable (see package runtime) to go or cgo, as in:\n\n```\nexport GODEBUG=netdns=go    # force pure Go resolver\nexport GODEBUG=netdns=cgo   # force cgo resolver\n\n```\nThe decision can also be forced while building the Go source tree\nby setting the netgo or netcgo build tag.\n\nA numeric netdns setting, as in GODEBUG=netdns=1, causes the resolver\nto print debugging information about its decisions.\nTo force a particular resolver while also printing debugging information,\njoin the two settings by a plus sign, as in GODEBUG=netdns=go+1.\n\nOn Plan 9, the resolver always accesses /net/cs and /net/dns.\n\nOn Windows, the resolver always uses C library functions, such as GetAddrInfo and DnsQuery.\n\n[\"net\" on pkg.go.dev](https://pkg.go.dev/net)",
    "url": "https://pkg.go.dev/net",
    "path": "net",
    "children": [
      {
        "name": "http",
        "synopsis": "Package http provides HTTP client and server implementations.\n\nGet, Head, Post, and PostForm make HTTP (or HTTPS) requests:\n\n```\nresp, err := http.Get(\"http://example.com/\")\n...\nresp, err := http.Post(\"http://example.com/upload\", \"image/jpeg\", \u0026buf)\n...\nresp, err := http.PostForm(\"http://example.com/form\",\n\turl.Values{\"key\": {\"Value\"}, \"id\": {\"123\"}})\n\n```\nThe client must close the response body when finished with it:\n\n```\nresp, err := http.Get(\"http://example.com/\")\nif err != nil {\n\t// handle error\n}\ndefer resp.Body.Close()\nbody, err := io.ReadAll(resp.Body)\n// ...\n\n```\nFor control over HTTP client headers, redirect policy, and other\nsettings, create a Client:\n\n```\nclient := \u0026http.Client{\n\tCheckRedirect: redirectPolicyFunc,\n}\n\nresp, err := client.Get(\"http://example.com\")\n// ...\n\nreq, err := http.NewRequest(\"GET\", \"http://example.com\", nil)\n// ...\nreq.Header.Add(\"If-None-Match\", `W/\"wyzzy\"`)\nresp, err := client.Do(req)\n// ...\n\n```\nFor control over proxies, TLS configuration, keep-alives,\ncompression, and other settings, create a Transport:\n\n```\ntr := \u0026http.Transport{\n\tMaxIdleConns:       10,\n\tIdleConnTimeout:    30 * time.Second,\n\tDisableCompression: true,\n}\nclient := \u0026http.Client{Transport: tr}\nresp, err := client.Get(\"https://example.com\")\n\n```\nClients and Transports are safe for concurrent use by multiple\ngoroutines and for efficiency should only be created once and re-used.\n\nListenAndServe starts an HTTP server with a given address and handler.\nThe handler is usually nil, which means to use DefaultServeMux.\nHandle and HandleFunc add handlers to DefaultServeMux:\n\n```\nhttp.Handle(\"/foo\", fooHandler)\n\nhttp.HandleFunc(\"/bar\", func(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintf(w, \"Hello, %q\", html.EscapeString(r.URL.Path))\n})\n\nlog.Fatal(http.ListenAndServe(\":8080\", nil))\n\n```\nMore control over the server's behavior is available by creating a\ncustom Server:\n\n```\ns := \u0026http.Server{\n\tAddr:           \":8080\",\n\tHandler:        myHandler,\n\tReadTimeout:    10 * time.Second,\n\tWriteTimeout:   10 * time.Second,\n\tMaxHeaderBytes: 1 \u003c\u003c 20,\n}\nlog.Fatal(s.ListenAndServe())\n\n```\nStarting with Go 1.6, the http package has transparent support for the\nHTTP/2 protocol when using HTTPS. Programs that must disable HTTP/2\ncan do so by setting Transport.TLSNextProto (for clients) or\nServer.TLSNextProto (for servers) to a non-nil, empty\nmap. Alternatively, the following GODEBUG environment variables are\ncurrently supported:\n\n```\nGODEBUG=http2client=0  # disable HTTP/2 client support\nGODEBUG=http2server=0  # disable HTTP/2 server support\nGODEBUG=http2debug=1   # enable verbose HTTP/2 debug logs\nGODEBUG=http2debug=2   # ... even more verbose, with frame dumps\n\n```\nThe GODEBUG variables are not covered by Go's API compatibility\npromise. Please report any issues before disabling HTTP/2\nsupport: https://golang.org/s/http2bug\n\nThe http package's Transport and Server both automatically enable\nHTTP/2 support for simple configurations. To enable HTTP/2 for more\ncomplex configurations, to use lower-level HTTP/2 features, or to use\na newer version of Go's http2 package, import \"golang.org/x/net/http2\"\ndirectly and use its ConfigureTransport and/or ConfigureServer\nfunctions. Manually configuring HTTP/2 via the golang.org/x/net/http2\npackage takes precedence over the net/http package's built-in HTTP/2\nsupport.\n\n[\"net/http\" on pkg.go.dev](https://pkg.go.dev/net/http)",
        "url": "https://pkg.go.dev/net/http",
        "path": "net/http",
        "children": [
          {
            "name": "cgi",
            "synopsis": "Package cgi implements CGI (Common Gateway Interface) as specified\nin RFC 3875.\n\nNote that using CGI means starting a new process to handle each\nrequest, which is typically less efficient than using a\nlong-running server. This package is intended primarily for\ncompatibility with existing systems.\n\n[\"net/http/cgi\" on pkg.go.dev](https://pkg.go.dev/net/http/cgi)",
            "url": "https://pkg.go.dev/net/http/cgi",
            "path": "net/http/cgi",
            "children": []
          },
          {
            "name": "cookiejar",
            "synopsis": "Package cookiejar implements an in-memory RFC 6265-compliant http.CookieJar.\n\n[\"net/http/cookiejar\" on pkg.go.dev](https://pkg.go.dev/net/http/cookiejar)",
            "url": "https://pkg.go.dev/net/http/cookiejar",
            "path": "net/http/cookiejar",
            "children": []
          },
          {
            "name": "fcgi",
            "synopsis": "Package fcgi implements the FastCGI protocol.\n\nSee https://fast-cgi.github.io/ for an unofficial mirror of the\noriginal documentation.\n\nCurrently only the responder role is supported.\n\n[\"net/http/fcgi\" on pkg.go.dev](https://pkg.go.dev/net/http/fcgi)",
            "url": "https://pkg.go.dev/net/http/fcgi",
            "path": "net/http/fcgi",
            "children": []
          },
          {
            "name": "httptest",
            "synopsis": "Package httptest provides utilities for HTTP testing.\n\n[\"net/http/httptest\" on pkg.go.dev](https://pkg.go.dev/net/http/httptest)",
            "url": "https://pkg.go.dev/net/http/httptest",
            "path": "net/http/httptest",
            "children": []
          },
          {
            "name": "httptrace",
            "synopsis": "Package httptrace provides mechanisms to trace the events within\nHTTP client requests.\n\n[\"net/http/httptrace\" on pkg.go.dev](https://pkg.go.dev/net/http/httptrace)",
            "url": "https://pkg.go.dev/net/http/httptrace",
            "path": "net/http/httptrace",
            "children": []
          },
          {
            "name": "httputil",
            "synopsis": "Package httputil provides HTTP utility functions, complementing the\nmore common ones in the net/http package.\n\n[\"net/http/httputil\" on pkg.go.dev](https://pkg.go.dev/net/http/httputil)",
            "url": "https://pkg.go.dev/net/http/httputil",
            "path": "net/http/httputil",
            "children": []
          },
          {
            "name": "pprof",
            "synopsis": "Package pprof serves via its HTTP server runtime profiling data\nin the format expected by the pprof visualization tool.\n\nThe package is typically only imported for the side effect of\nregistering its HTTP handlers.\nThe handled paths all begin with /debug/pprof/.\n\nTo use pprof, link this package into your program:\n```\nimport _ \"net/http/pprof\"\n\n```\nIf your application is not already running an http server, you\nneed to start one. Add \"net/http\" and \"log\" to your imports and\nthe following code to your main function:\n\n```\ngo func() {\n\tlog.Println(http.ListenAndServe(\"localhost:6060\", nil))\n}()\n\n```\nIf you are not using DefaultServeMux, you will have to register handlers\nwith the mux you are using.\n\nThen use the pprof tool to look at the heap profile:\n\n```\ngo tool pprof http://localhost:6060/debug/pprof/heap\n\n```\nOr to look at a 30-second CPU profile:\n\n```\ngo tool pprof http://localhost:6060/debug/pprof/profile?seconds=30\n\n```\nOr to look at the goroutine blocking profile, after calling\nruntime.SetBlockProfileRate in your program:\n\n```\ngo tool pprof http://localhost:6060/debug/pprof/block\n\n```\nOr to look at the holders of contended mutexes, after calling\nruntime.SetMutexProfileFraction in your program:\n\n```\ngo tool pprof http://localhost:6060/debug/pprof/mutex\n\n```\nThe package also exports a handler that serves execution trace data\nfor the \"go tool trace\" command. To collect a 5-second execution trace:\n\n```\ncurl -o trace.out http://localhost:6060/debug/pprof/trace?seconds=5\ngo tool trace trace.out\n\n```\nTo view all available profiles, open http://localhost:6060/debug/pprof/\nin your browser.\n\nFor a study of the facility in action, visit\n\n```\nhttps://blog.golang.org/2011/06/profiling-go-programs.html\n\n[\"net/http/pprof\" on pkg.go.dev](https://pkg.go.dev/net/http/pprof)",
            "url": "https://pkg.go.dev/net/http/pprof",
            "path": "net/http/pprof",
            "children": []
          }
        ]
      },
      {
        "name": "mail",
        "synopsis": "Package mail implements parsing of mail messages.\n\nFor the most part, this package follows the syntax as specified by RFC 5322 and\nextended by RFC 6532.\nNotable divergences:\n```\n* Obsolete address formats are not parsed, including addresses with\n  embedded route information.\n* The full range of spacing (the CFWS syntax element) is not supported,\n  such as breaking addresses across lines.\n* No unicode normalization is performed.\n* The special characters ()[]:;@\\, are allowed to appear unquoted in names.\n\n[\"net/mail\" on pkg.go.dev](https://pkg.go.dev/net/mail)",
        "url": "https://pkg.go.dev/net/mail",
        "path": "net/mail",
        "children": []
      },
      {
        "name": "netip",
        "synopsis": "Package netip defines an IP address type that's a small value type.\nBuilding on that Addr type, the package also defines AddrPort (an\nIP address and a port), and Prefix (an IP address and a bit length\nprefix).\n\nCompared to the net.IP type, this package's Addr type takes less\nmemory, is immutable, and is comparable (supports == and being a\nmap key).\n\n[\"net/netip\" on pkg.go.dev](https://pkg.go.dev/net/netip)",
        "url": "https://pkg.go.dev/net/netip",
        "path": "net/netip",
        "children": []
      },
      {
        "name": "rpc",
        "synopsis": "```\nPackage rpc provides access to the exported methods of an object across a\nnetwork or other I/O connection.  A server registers an object, making it visible\nas a service with the name of the type of the object.  After registration, exported\nmethods of the object will be accessible remotely.  A server may register multiple\nobjects (services) of different types but it is an error to register multiple\nobjects of the same type.\n\nOnly methods that satisfy these criteria will be made available for remote access;\nother methods will be ignored:\n\n\t- the method's type is exported.\n\t- the method is exported.\n\t- the method has two arguments, both exported (or builtin) types.\n\t- the method's second argument is a pointer.\n\t- the method has return type error.\n\nIn effect, the method must look schematically like\n\n\tfunc (t *T) MethodName(argType T1, replyType *T2) error\n\nwhere T1 and T2 can be marshaled by encoding/gob.\nThese requirements apply even if a different codec is used.\n(In the future, these requirements may soften for custom codecs.)\n\nThe method's first argument represents the arguments provided by the caller; the\nsecond argument represents the result parameters to be returned to the caller.\nThe method's return value, if non-nil, is passed back as a string that the client\nsees as if created by errors.New.  If an error is returned, the reply parameter\nwill not be sent back to the client.\n\nThe server may handle requests on a single connection by calling ServeConn.  More\ntypically it will create a network listener and call Accept or, for an HTTP\nlistener, HandleHTTP and http.Serve.\n\nA client wishing to use the service establishes a connection and then invokes\nNewClient on the connection.  The convenience function Dial (DialHTTP) performs\nboth steps for a raw network connection (an HTTP connection).  The resulting\nClient object has two methods, Call and Go, that specify the service and method to\ncall, a pointer containing the arguments, and a pointer to receive the result\nparameters.\n\nThe Call method waits for the remote call to complete while the Go method\nlaunches the call asynchronously and signals completion using the Call\nstructure's Done channel.\n\nUnless an explicit codec is set up, package encoding/gob is used to\ntransport the data.\n\nHere is a simple example.  A server wishes to export an object of type Arith:\n\n\tpackage server\n\n\timport \"errors\"\n\n\ttype Args struct {\n\t\tA, B int\n\t}\n\n\ttype Quotient struct {\n\t\tQuo, Rem int\n\t}\n\n\ttype Arith int\n\n\tfunc (t *Arith) Multiply(args *Args, reply *int) error {\n\t\t*reply = args.A * args.B\n\t\treturn nil\n\t}\n\n\tfunc (t *Arith) Divide(args *Args, quo *Quotient) error {\n\t\tif args.B == 0 {\n\t\t\treturn errors.New(\"divide by zero\")\n\t\t}\n\t\tquo.Quo = args.A / args.B\n\t\tquo.Rem = args.A % args.B\n\t\treturn nil\n\t}\n\nThe server calls (for HTTP service):\n\n\tarith := new(Arith)\n\trpc.Register(arith)\n\trpc.HandleHTTP()\n\tl, e := net.Listen(\"tcp\", \":1234\")\n\tif e != nil {\n\t\tlog.Fatal(\"listen error:\", e)\n\t}\n\tgo http.Serve(l, nil)\n\nAt this point, clients can see a service \"Arith\" with methods \"Arith.Multiply\" and\n\"Arith.Divide\".  To invoke one, a client first dials the server:\n\n\tclient, err := rpc.DialHTTP(\"tcp\", serverAddress + \":1234\")\n\tif err != nil {\n\t\tlog.Fatal(\"dialing:\", err)\n\t}\n\nThen it can make a remote call:\n\n\t// Synchronous call\n\targs := \u0026server.Args{7,8}\n\tvar reply int\n\terr = client.Call(\"Arith.Multiply\", args, \u0026reply)\n\tif err != nil {\n\t\tlog.Fatal(\"arith error:\", err)\n\t}\n\tfmt.Printf(\"Arith: %d*%d=%d\", args.A, args.B, reply)\n\nor\n\n\t// Asynchronous call\n\tquotient := new(Quotient)\n\tdivCall := client.Go(\"Arith.Divide\", args, quotient, nil)\n\treplyCall := \u003c-divCall.Done\t// will be equal to divCall\n\t// check errors, print, etc.\n\nA server implementation will often provide a simple, type-safe wrapper for the\nclient.\n\nThe net/rpc package is frozen and is not accepting new features.\n\n[\"net/rpc\" on pkg.go.dev](https://pkg.go.dev/net/rpc)",
        "url": "https://pkg.go.dev/net/rpc",
        "path": "net/rpc",
        "children": [
          {
            "name": "jsonrpc",
            "synopsis": "Package jsonrpc implements a JSON-RPC 1.0 ClientCodec and ServerCodec\nfor the rpc package.\nFor JSON-RPC 2.0 support, see https://godoc.org/?q=json-rpc+2.0\n\n[\"net/rpc/jsonrpc\" on pkg.go.dev](https://pkg.go.dev/net/rpc/jsonrpc)",
            "url": "https://pkg.go.dev/net/rpc/jsonrpc",
            "path": "net/rpc/jsonrpc",
            "children": []
          }
        ]
      },
      {
        "name": "smtp",
        "synopsis": "Package smtp implements the Simple Mail Transfer Protocol as defined in RFC 5321.\nIt also implements the following extensions:\n```\n8BITMIME  RFC 1652\nAUTH      RFC 2554\nSTARTTLS  RFC 3207\n```\nAdditional extensions may be handled by clients.\n\nThe smtp package is frozen and is not accepting new features.\nSome external packages provide more functionality. See:\n\n  https://godoc.org/?q=smtp\n\n[\"net/smtp\" on pkg.go.dev](https://pkg.go.dev/net/smtp)",
        "url": "https://pkg.go.dev/net/smtp",
        "path": "net/smtp",
        "children": []
      },
      {
        "name": "textproto",
        "synopsis": "Package textproto implements generic support for text-based request/response\nprotocols in the style of HTTP, NNTP, and SMTP.\n\nThe package provides:\n\nError, which represents a numeric error response from\na server.\n\nPipeline, to manage pipelined requests and responses\nin a client.\n\nReader, to read numeric response code lines,\nkey: value headers, lines wrapped with leading spaces\non continuation lines, and whole text blocks ending\nwith a dot on a line by itself.\n\nWriter, to write dot-encoded text blocks.\n\nConn, a convenient packaging of Reader, Writer, and Pipeline for use\nwith a single network connection.\n\n[\"net/textproto\" on pkg.go.dev](https://pkg.go.dev/net/textproto)",
        "url": "https://pkg.go.dev/net/textproto",
        "path": "net/textproto",
        "children": []
      },
      {
        "name": "url",
        "synopsis": "Package url parses URLs and implements query escaping.\n\n[\"net/url\" on pkg.go.dev](https://pkg.go.dev/net/url)",
        "url": "https://pkg.go.dev/net/url",
        "path": "net/url",
        "children": []
      }
    ]
  },
  {
    "name": "os",
    "synopsis": "Package os provides a platform-independent interface to operating system\nfunctionality. The design is Unix-like, although the error handling is\nGo-like; failing calls return values of type error rather than error numbers.\nOften, more information is available within the error. For example,\nif a call that takes a file name fails, such as Open or Stat, the error\nwill include the failing file name when printed and will be of type\n*PathError, which may be unpacked for more information.\n\nThe os interface is intended to be uniform across all operating systems.\nFeatures not generally available appear in the system-specific package syscall.\n\nHere is a simple example, opening a file and reading some of it.\n\n```\nfile, err := os.Open(\"file.go\") // For read access.\nif err != nil {\n\tlog.Fatal(err)\n}\n\n```\nIf the open fails, the error string will be self-explanatory, like\n\n```\nopen file.go: no such file or directory\n\n```\nThe file's data can then be read into a slice of bytes. Read and\nWrite take their byte counts from the length of the argument slice.\n\n```\ndata := make([]byte, 100)\ncount, err := file.Read(data)\nif err != nil {\n\tlog.Fatal(err)\n}\nfmt.Printf(\"read %d bytes: %q\\n\", count, data[:count])\n\n```\nNote: The maximum number of concurrent operations on a File may be limited by\nthe OS or the system. The number should be high, but exceeding it may degrade\nperformance or cause other issues.\n\n[\"os\" on pkg.go.dev](https://pkg.go.dev/os)",
    "url": "https://pkg.go.dev/os",
    "path": "os",
    "children": [
      {
        "name": "exec",
        "synopsis": "Package exec runs external commands. It wraps os.StartProcess to make it\neasier to remap stdin and stdout, connect I/O with pipes, and do other\nadjustments.\n\nUnlike the \"system\" library call from C and other languages, the\nos/exec package intentionally does not invoke the system shell and\ndoes not expand any glob patterns or handle other expansions,\npipelines, or redirections typically done by shells. The package\nbehaves more like C's \"exec\" family of functions. To expand glob\npatterns, either call the shell directly, taking care to escape any\ndangerous input, or use the path/filepath package's Glob function.\nTo expand environment variables, use package os's ExpandEnv.\n\nNote that the examples in this package assume a Unix system.\nThey may not run on Windows, and they do not run in the Go Playground\nused by golang.org and godoc.org.\n\n[\"os/exec\" on pkg.go.dev](https://pkg.go.dev/os/exec)",
        "url": "https://pkg.go.dev/os/exec",
        "path": "os/exec",
        "children": []
      },
      {
        "name": "signal",
        "synopsis": "Package signal implements access to incoming signals.\n\nSignals are primarily used on Unix-like systems. For the use of this\npackage on Windows and Plan 9, see below.\n\nTypes of signals\n\nThe signals SIGKILL and SIGSTOP may not be caught by a program, and\ntherefore cannot be affected by this package.\n\nSynchronous signals are signals triggered by errors in program\nexecution: SIGBUS, SIGFPE, and SIGSEGV. These are only considered\nsynchronous when caused by program execution, not when sent using\nos.Process.Kill or the kill program or some similar mechanism. In\ngeneral, except as discussed below, Go programs will convert a\nsynchronous signal into a run-time panic.\n\nThe remaining signals are asynchronous signals. They are not\ntriggered by program errors, but are instead sent from the kernel or\nfrom some other program.\n\nOf the asynchronous signals, the SIGHUP signal is sent when a program\nloses its controlling terminal. The SIGINT signal is sent when the\nuser at the controlling terminal presses the interrupt character,\nwhich by default is ^C (Control-C). The SIGQUIT signal is sent when\nthe user at the controlling terminal presses the quit character, which\nby default is ^\\ (Control-Backslash). In general you can cause a\nprogram to simply exit by pressing ^C, and you can cause it to exit\nwith a stack dump by pressing ^\\.\n\nDefault behavior of signals in Go programs\n\nBy default, a synchronous signal is converted into a run-time panic. A\nSIGHUP, SIGINT, or SIGTERM signal causes the program to exit. A\nSIGQUIT, SIGILL, SIGTRAP, SIGABRT, SIGSTKFLT, SIGEMT, or SIGSYS signal\ncauses the program to exit with a stack dump. A SIGTSTP, SIGTTIN, or\nSIGTTOU signal gets the system default behavior (these signals are\nused by the shell for job control). The SIGPROF signal is handled\ndirectly by the Go runtime to implement runtime.CPUProfile. Other\nsignals will be caught but no action will be taken.\n\nIf the Go program is started with either SIGHUP or SIGINT ignored\n(signal handler set to SIG_IGN), they will remain ignored.\n\nIf the Go program is started with a non-empty signal mask, that will\ngenerally be honored. However, some signals are explicitly unblocked:\nthe synchronous signals, SIGILL, SIGTRAP, SIGSTKFLT, SIGCHLD, SIGPROF,\nand, on Linux, signals 32 (SIGCANCEL) and 33 (SIGSETXID)\n(SIGCANCEL and SIGSETXID are used internally by glibc). Subprocesses\nstarted by os.Exec, or by the os/exec package, will inherit the\nmodified signal mask.\n\nChanging the behavior of signals in Go programs\n\nThe functions in this package allow a program to change the way Go\nprograms handle signals.\n\nNotify disables the default behavior for a given set of asynchronous\nsignals and instead delivers them over one or more registered\nchannels. Specifically, it applies to the signals SIGHUP, SIGINT,\nSIGQUIT, SIGABRT, and SIGTERM. It also applies to the job control\nsignals SIGTSTP, SIGTTIN, and SIGTTOU, in which case the system\ndefault behavior does not occur. It also applies to some signals that\notherwise cause no action: SIGUSR1, SIGUSR2, SIGPIPE, SIGALRM,\nSIGCHLD, SIGCONT, SIGURG, SIGXCPU, SIGXFSZ, SIGVTALRM, SIGWINCH,\nSIGIO, SIGPWR, SIGSYS, SIGINFO, SIGTHR, SIGWAITING, SIGLWP, SIGFREEZE,\nSIGTHAW, SIGLOST, SIGXRES, SIGJVM1, SIGJVM2, and any real time signals\nused on the system. Note that not all of these signals are available\non all systems.\n\nIf the program was started with SIGHUP or SIGINT ignored, and Notify\nis called for either signal, a signal handler will be installed for\nthat signal and it will no longer be ignored. If, later, Reset or\nIgnore is called for that signal, or Stop is called on all channels\npassed to Notify for that signal, the signal will once again be\nignored. Reset will restore the system default behavior for the\nsignal, while Ignore will cause the system to ignore the signal\nentirely.\n\nIf the program is started with a non-empty signal mask, some signals\nwill be explicitly unblocked as described above. If Notify is called\nfor a blocked signal, it will be unblocked. If, later, Reset is\ncalled for that signal, or Stop is called on all channels passed to\nNotify for that signal, the signal will once again be blocked.\n\nSIGPIPE\n\nWhen a Go program writes to a broken pipe, the kernel will raise a\nSIGPIPE signal.\n\nIf the program has not called Notify to receive SIGPIPE signals, then\nthe behavior depends on the file descriptor number. A write to a\nbroken pipe on file descriptors 1 or 2 (standard output or standard\nerror) will cause the program to exit with a SIGPIPE signal. A write\nto a broken pipe on some other file descriptor will take no action on\nthe SIGPIPE signal, and the write will fail with an EPIPE error.\n\nIf the program has called Notify to receive SIGPIPE signals, the file\ndescriptor number does not matter. The SIGPIPE signal will be\ndelivered to the Notify channel, and the write will fail with an EPIPE\nerror.\n\nThis means that, by default, command line programs will behave like\ntypical Unix command line programs, while other programs will not\ncrash with SIGPIPE when writing to a closed network connection.\n\nGo programs that use cgo or SWIG\n\nIn a Go program that includes non-Go code, typically C/C++ code\naccessed using cgo or SWIG, Go's startup code normally runs first. It\nconfigures the signal handlers as expected by the Go runtime, before\nthe non-Go startup code runs. If the non-Go startup code wishes to\ninstall its own signal handlers, it must take certain steps to keep Go\nworking well. This section documents those steps and the overall\neffect changes to signal handler settings by the non-Go code can have\non Go programs. In rare cases, the non-Go code may run before the Go\ncode, in which case the next section also applies.\n\nIf the non-Go code called by the Go program does not change any signal\nhandlers or masks, then the behavior is the same as for a pure Go\nprogram.\n\nIf the non-Go code installs any signal handlers, it must use the\nSA_ONSTACK flag with sigaction. Failing to do so is likely to cause\nthe program to crash if the signal is received. Go programs routinely\nrun with a limited stack, and therefore set up an alternate signal\nstack.\n\nIf the non-Go code installs a signal handler for any of the\nsynchronous signals (SIGBUS, SIGFPE, SIGSEGV), then it should record\nthe existing Go signal handler. If those signals occur while\nexecuting Go code, it should invoke the Go signal handler (whether the\nsignal occurs while executing Go code can be determined by looking at\nthe PC passed to the signal handler). Otherwise some Go run-time\npanics will not occur as expected.\n\nIf the non-Go code installs a signal handler for any of the\nasynchronous signals, it may invoke the Go signal handler or not as it\nchooses. Naturally, if it does not invoke the Go signal handler, the\nGo behavior described above will not occur. This can be an issue with\nthe SIGPROF signal in particular.\n\nThe non-Go code should not change the signal mask on any threads\ncreated by the Go runtime. If the non-Go code starts new threads of\nits own, it may set the signal mask as it pleases.\n\nIf the non-Go code starts a new thread, changes the signal mask, and\nthen invokes a Go function in that thread, the Go runtime will\nautomatically unblock certain signals: the synchronous signals,\nSIGILL, SIGTRAP, SIGSTKFLT, SIGCHLD, SIGPROF, SIGCANCEL, and\nSIGSETXID. When the Go function returns, the non-Go signal mask will\nbe restored.\n\nIf the Go signal handler is invoked on a non-Go thread not running Go\ncode, the handler generally forwards the signal to the non-Go code, as\nfollows. If the signal is SIGPROF, the Go handler does\nnothing. Otherwise, the Go handler removes itself, unblocks the\nsignal, and raises it again, to invoke any non-Go handler or default\nsystem handler. If the program does not exit, the Go handler then\nreinstalls itself and continues execution of the program.\n\nNon-Go programs that call Go code\n\nWhen Go code is built with options like -buildmode=c-shared, it will\nbe run as part of an existing non-Go program. The non-Go code may\nhave already installed signal handlers when the Go code starts (that\nmay also happen in unusual cases when using cgo or SWIG; in that case,\nthe discussion here applies).  For -buildmode=c-archive the Go runtime\nwill initialize signals at global constructor time.  For\n-buildmode=c-shared the Go runtime will initialize signals when the\nshared library is loaded.\n\nIf the Go runtime sees an existing signal handler for the SIGCANCEL or\nSIGSETXID signals (which are used only on Linux), it will turn on\nthe SA_ONSTACK flag and otherwise keep the signal handler.\n\nFor the synchronous signals and SIGPIPE, the Go runtime will install a\nsignal handler. It will save any existing signal handler. If a\nsynchronous signal arrives while executing non-Go code, the Go runtime\nwill invoke the existing signal handler instead of the Go signal\nhandler.\n\nGo code built with -buildmode=c-archive or -buildmode=c-shared will\nnot install any other signal handlers by default. If there is an\nexisting signal handler, the Go runtime will turn on the SA_ONSTACK\nflag and otherwise keep the signal handler. If Notify is called for an\nasynchronous signal, a Go signal handler will be installed for that\nsignal. If, later, Reset is called for that signal, the original\nhandling for that signal will be reinstalled, restoring the non-Go\nsignal handler if any.\n\nGo code built without -buildmode=c-archive or -buildmode=c-shared will\ninstall a signal handler for the asynchronous signals listed above,\nand save any existing signal handler. If a signal is delivered to a\nnon-Go thread, it will act as described above, except that if there is\nan existing non-Go signal handler, that handler will be installed\nbefore raising the signal.\n\nWindows\n\nOn Windows a ^C (Control-C) or ^BREAK (Control-Break) normally cause\nthe program to exit. If Notify is called for os.Interrupt, ^C or ^BREAK\nwill cause os.Interrupt to be sent on the channel, and the program will\nnot exit. If Reset is called, or Stop is called on all channels passed\nto Notify, then the default behavior will be restored.\n\nAdditionally, if Notify is called, and Windows sends CTRL_CLOSE_EVENT,\nCTRL_LOGOFF_EVENT or CTRL_SHUTDOWN_EVENT to the process, Notify will\nreturn syscall.SIGTERM. Unlike Control-C and Control-Break, Notify does\nnot change process behavior when either CTRL_CLOSE_EVENT,\nCTRL_LOGOFF_EVENT or CTRL_SHUTDOWN_EVENT is received - the process will\nstill get terminated unless it exits. But receiving syscall.SIGTERM will\ngive the process an opportunity to clean up before termination.\n\nPlan 9\n\nOn Plan 9, signals have type syscall.Note, which is a string. Calling\nNotify with a syscall.Note will cause that value to be sent on the\nchannel when that string is posted as a note.\n\n[\"os/signal\" on pkg.go.dev](https://pkg.go.dev/os/signal)",
        "url": "https://pkg.go.dev/os/signal",
        "path": "os/signal",
        "children": []
      },
      {
        "name": "user",
        "synopsis": "Package user allows user account lookups by name or id.\n\nFor most Unix systems, this package has two internal implementations of\nresolving user and group ids to names, and listing supplementary group IDs.\nOne is written in pure Go and parses /etc/passwd and /etc/group. The other\nis cgo-based and relies on the standard C library (libc) routines such as\ngetpwuid_r, getgrnam_r, and getgrouplist.\n\nWhen cgo is available, and the required routines are implemented in libc\nfor a particular platform, cgo-based (libc-backed) code is used.\nThis can be overridden by using osusergo build tag, which enforces\nthe pure Go implementation.\n\n[\"os/user\" on pkg.go.dev](https://pkg.go.dev/os/user)",
        "url": "https://pkg.go.dev/os/user",
        "path": "os/user",
        "children": []
      }
    ]
  },
  {
    "name": "path",
    "synopsis": "Package path implements utility routines for manipulating slash-separated\npaths.\n\nThe path package should only be used for paths separated by forward\nslashes, such as the paths in URLs. This package does not deal with\nWindows paths with drive letters or backslashes; to manipulate\noperating system paths, use the path/filepath package.\n\n[\"path\" on pkg.go.dev](https://pkg.go.dev/path)",
    "url": "https://pkg.go.dev/path",
    "path": "path",
    "children": [
      {
        "name": "filepath",
        "synopsis": "Package filepath implements utility routines for manipulating filename paths\nin a way compatible with the target operating system-defined file paths.\n\nThe filepath package uses either forward slashes or backslashes,\ndepending on the operating system. To process paths such as URLs\nthat always use forward slashes regardless of the operating\nsystem, see the path package.\n\n[\"path/filepath\" on pkg.go.dev](https://pkg.go.dev/path/filepath)",
        "url": "https://pkg.go.dev/path/filepath",
        "path": "path/filepath",
        "children": []
      }
    ]
  },
  {
    "name": "plugin",
    "synopsis": "Package plugin implements loading and symbol resolution of Go plugins.\n\nA plugin is a Go main package with exported functions and variables that\nhas been built with:\n\n```\ngo build -buildmode=plugin\n\n```\nWhen a plugin is first opened, the init functions of all packages not\nalready part of the program are called. The main function is not run.\nA plugin is only initialized once, and cannot be closed.\n\nCurrently plugins are only supported on Linux, FreeBSD, and macOS.\nPlease report any issues.\n\n[\"plugin\" on pkg.go.dev](https://pkg.go.dev/plugin)",
    "url": "https://pkg.go.dev/plugin",
    "path": "plugin",
    "children": []
  },
  {
    "name": "reflect",
    "synopsis": "Package reflect implements run-time reflection, allowing a program to\nmanipulate objects with arbitrary types. The typical use is to take a value\nwith static type interface{} and extract its dynamic type information by\ncalling TypeOf, which returns a Type.\n\nA call to ValueOf returns a Value representing the run-time data.\nZero takes a Type and returns a Value representing a zero value\nfor that type.\n\nSee \"The Laws of Reflection\" for an introduction to reflection in Go:\nhttps://golang.org/doc/articles/laws_of_reflection.html\n\n[\"reflect\" on pkg.go.dev](https://pkg.go.dev/reflect)",
    "url": "https://pkg.go.dev/reflect",
    "path": "reflect",
    "children": []
  },
  {
    "name": "regexp",
    "synopsis": "Package regexp implements regular expression search.\n\nThe syntax of the regular expressions accepted is the same\ngeneral syntax used by Perl, Python, and other languages.\nMore precisely, it is the syntax accepted by RE2 and described at\nhttps://golang.org/s/re2syntax, except for \\C.\nFor an overview of the syntax, run\n  go doc regexp/syntax\n\nThe regexp implementation provided by this package is\nguaranteed to run in time linear in the size of the input.\n(This is a property not guaranteed by most open source\nimplementations of regular expressions.) For more information\nabout this property, see\n```\nhttps://swtch.com/~rsc/regexp/regexp1.html\n```\nor any book about automata theory.\n\nAll characters are UTF-8-encoded code points.\nFollowing utf8.DecodeRune, each byte of an invalid UTF-8 sequence\nis treated as if it encoded utf8.RuneError (U+FFFD).\n\nThere are 16 methods of Regexp that match a regular expression and identify\nthe matched text. Their names are matched by this regular expression:\n\n```\nFind(All)?(String)?(Submatch)?(Index)?\n\n```\nIf 'All' is present, the routine matches successive non-overlapping\nmatches of the entire expression. Empty matches abutting a preceding\nmatch are ignored. The return value is a slice containing the successive\nreturn values of the corresponding non-'All' routine. These routines take\nan extra integer argument, n. If n \u003e= 0, the function returns at most n\nmatches/submatches; otherwise, it returns all of them.\n\nIf 'String' is present, the argument is a string; otherwise it is a slice\nof bytes; return values are adjusted as appropriate.\n\nIf 'Submatch' is present, the return value is a slice identifying the\nsuccessive submatches of the expression. Submatches are matches of\nparenthesized subexpressions (also known as capturing groups) within the\nregular expression, numbered from left to right in order of opening\nparenthesis. Submatch 0 is the match of the entire expression, submatch 1 is\nthe match of the first parenthesized subexpression, and so on.\n\nIf 'Index' is present, matches and submatches are identified by byte index\npairs within the input string: result[2*n:2*n+1] identifies the indexes of\nthe nth submatch. The pair for n==0 identifies the match of the entire\nexpression. If 'Index' is not present, the match is identified by the text\nof the match/submatch. If an index is negative or text is nil, it means that\nsubexpression did not match any string in the input. For 'String' versions\nan empty string means either no match or an empty match.\n\nThere is also a subset of the methods that can be applied to text read\nfrom a RuneReader:\n\n```\nMatchReader, FindReaderIndex, FindReaderSubmatchIndex\n\n```\nThis set may grow. Note that regular expression matches may need to\nexamine text beyond the text returned by a match, so the methods that\nmatch text from a RuneReader may read arbitrarily far into the input\nbefore returning.\n\n(There are a few other methods that do not match this pattern.)\n\n[\"regexp\" on pkg.go.dev](https://pkg.go.dev/regexp)",
    "url": "https://pkg.go.dev/regexp",
    "path": "regexp",
    "children": [
      {
        "name": "syntax",
        "synopsis": "Package syntax parses regular expressions into parse trees and compiles\nparse trees into programs. Most clients of regular expressions will use the\nfacilities of package regexp (such as Compile and Match) instead of this package.\n\nSyntax\n\nThe regular expression syntax understood by this package when parsing with the Perl flag is as follows.\nParts of the syntax can be disabled by passing alternate flags to Parse.\n\nSingle characters:\n  .              any character, possibly including newline (flag s=true)\n  [xyz]          character class\n  [^xyz]         negated character class\n  \\d             Perl character class\n  \\D             negated Perl character class\n  [[:alpha:]]    ASCII character class\n  [[:^alpha:]]   negated ASCII character class\n  \\pN            Unicode character class (one-letter name)\n  \\p{Greek}      Unicode character class\n  \\PN            negated Unicode character class (one-letter name)\n  \\P{Greek}      negated Unicode character class\n\nComposites:\n  xy             x followed by y\n  x|y            x or y (prefer x)\n\nRepetitions:\n  x*             zero or more x, prefer more\n  x+             one or more x, prefer more\n  x?             zero or one x, prefer one\n  x{n,m}         n or n+1 or ... or m x, prefer more\n  x{n,}          n or more x, prefer more\n  x{n}           exactly n x\n  x*?            zero or more x, prefer fewer\n  x+?            one or more x, prefer fewer\n  x??            zero or one x, prefer zero\n  x{n,m}?        n or n+1 or ... or m x, prefer fewer\n  x{n,}?         n or more x, prefer fewer\n  x{n}?          exactly n x\n\nImplementation restriction: The counting forms x{n,m}, x{n,}, and x{n}\nreject forms that create a minimum or maximum repetition count above 1000.\nUnlimited repetitions are not subject to this restriction.\n\nGrouping:\n  (re)           numbered capturing group (submatch)\n  (?P\u003cname\u003ere)   named \u0026 numbered capturing group (submatch)\n  (?:re)         non-capturing group\n  (?flags)       set flags within current group; non-capturing\n  (?flags:re)    set flags during re; non-capturing\n\n  Flag syntax is xyz (set) or -xyz (clear) or xy-z (set xy, clear z). The flags are:\n\n  i              case-insensitive (default false)\n  m              multi-line mode: ^ and $ match begin/end line in addition to begin/end text (default false)\n  s              let . match \\n (default false)\n  U              ungreedy: swap meaning of x* and x*?, x+ and x+?, etc (default false)\n\nEmpty strings:\n  ^              at beginning of text or line (flag m=true)\n  $              at end of text (like \\z not \\Z) or line (flag m=true)\n  \\A             at beginning of text\n  \\b             at ASCII word boundary (\\w on one side and \\W, \\A, or \\z on the other)\n  \\B             not at ASCII word boundary\n  \\z             at end of text\n\nEscape sequences:\n  \\a             bell (== \\007)\n  \\f             form feed (== \\014)\n  \\t             horizontal tab (== \\011)\n  \\n             newline (== \\012)\n  \\r             carriage return (== \\015)\n  \\v             vertical tab character (== \\013)\n  \\*             literal *, for any punctuation character *\n  \\123           octal character code (up to three digits)\n  \\x7F           hex character code (exactly two digits)\n  \\x{10FFFF}     hex character code\n  \\Q...\\E        literal text ... even if ... has punctuation\n\nCharacter class elements:\n  x              single character\n  A-Z            character range (inclusive)\n  \\d             Perl character class\n  [:foo:]        ASCII character class foo\n  \\p{Foo}        Unicode character class Foo\n  \\pF            Unicode character class F (one-letter name)\n\nNamed character classes as character class elements:\n  [\\d]           digits (== \\d)\n  [^\\d]          not digits (== \\D)\n  [\\D]           not digits (== \\D)\n  [^\\D]          not not digits (== \\d)\n  [[:name:]]     named ASCII class inside character class (== [:name:])\n  [^[:name:]]    named ASCII class inside negated character class (== [:^name:])\n  [\\p{Name}]     named Unicode property inside character class (== \\p{Name})\n  [^\\p{Name}]    named Unicode property inside negated character class (== \\P{Name})\n\nPerl character classes (all ASCII-only):\n  \\d             digits (== [0-9])\n  \\D             not digits (== [^0-9])\n  \\s             whitespace (== [\\t\\n\\f\\r ])\n  \\S             not whitespace (== [^\\t\\n\\f\\r ])\n  \\w             word characters (== [0-9A-Za-z_])\n  \\W             not word characters (== [^0-9A-Za-z_])\n\nASCII character classes:\n  [[:alnum:]]    alphanumeric (== [0-9A-Za-z])\n  [[:alpha:]]    alphabetic (== [A-Za-z])\n  [[:ascii:]]    ASCII (== [\\x00-\\x7F])\n  [[:blank:]]    blank (== [\\t ])\n  [[:cntrl:]]    control (== [\\x00-\\x1F\\x7F])\n  [[:digit:]]    digits (== [0-9])\n  [[:graph:]]    graphical (== [!-~] == [A-Za-z0-9!\"#$%\u0026'()*+,\\-./:;\u003c=\u003e?@[\\\\\\]^_`{|}~])\n  [[:lower:]]    lower case (== [a-z])\n  [[:print:]]    printable (== [ -~] == [ [:graph:]])\n  [[:punct:]]    punctuation (== [!-/:-@[-`{-~])\n  [[:space:]]    whitespace (== [\\t\\n\\v\\f\\r ])\n  [[:upper:]]    upper case (== [A-Z])\n  [[:word:]]     word characters (== [0-9A-Za-z_])\n  [[:xdigit:]]   hex digit (== [0-9A-Fa-f])\n\nUnicode character classes are those in unicode.Categories and unicode.Scripts.\n\n[\"regexp/syntax\" on pkg.go.dev](https://pkg.go.dev/regexp/syntax)",
        "url": "https://pkg.go.dev/regexp/syntax",
        "path": "regexp/syntax",
        "children": []
      }
    ]
  },
  {
    "name": "runtime",
    "synopsis": "Package runtime contains operations that interact with Go's runtime system,\nsuch as functions to control goroutines. It also includes the low-level type information\nused by the reflect package; see reflect's documentation for the programmable\ninterface to the run-time type system.\n\nEnvironment Variables\n\nThe following environment variables ($name or %name%, depending on the host\noperating system) control the run-time behavior of Go programs. The meanings\nand use may change from release to release.\n\nThe GOGC variable sets the initial garbage collection target percentage.\nA collection is triggered when the ratio of freshly allocated data to live data\nremaining after the previous collection reaches this percentage. The default\nis GOGC=100. Setting GOGC=off disables the garbage collector entirely.\nThe runtime/debug package's SetGCPercent function allows changing this\npercentage at run time. See https://golang.org/pkg/runtime/debug/#SetGCPercent.\n\nThe GODEBUG variable controls debugging variables within the runtime.\nIt is a comma-separated list of name=val pairs setting these named variables:\n\n```\nallocfreetrace: setting allocfreetrace=1 causes every allocation to be\nprofiled and a stack trace printed on each object's allocation and free.\n\nclobberfree: setting clobberfree=1 causes the garbage collector to\nclobber the memory content of an object with bad content when it frees\nthe object.\n\ncgocheck: setting cgocheck=0 disables all checks for packages\nusing cgo to incorrectly pass Go pointers to non-Go code.\nSetting cgocheck=1 (the default) enables relatively cheap\nchecks that may miss some errors.  Setting cgocheck=2 enables\nexpensive checks that should not miss any errors, but will\ncause your program to run slower.\n\nefence: setting efence=1 causes the allocator to run in a mode\nwhere each object is allocated on a unique page and addresses are\nnever recycled.\n\ngccheckmark: setting gccheckmark=1 enables verification of the\ngarbage collector's concurrent mark phase by performing a\nsecond mark pass while the world is stopped.  If the second\npass finds a reachable object that was not found by concurrent\nmark, the garbage collector will panic.\n\ngcpacertrace: setting gcpacertrace=1 causes the garbage collector to\nprint information about the internal state of the concurrent pacer.\n\ngcshrinkstackoff: setting gcshrinkstackoff=1 disables moving goroutines\nonto smaller stacks. In this mode, a goroutine's stack can only grow.\n\ngcstoptheworld: setting gcstoptheworld=1 disables concurrent garbage collection,\nmaking every garbage collection a stop-the-world event. Setting gcstoptheworld=2\nalso disables concurrent sweeping after the garbage collection finishes.\n\ngctrace: setting gctrace=1 causes the garbage collector to emit a single line to standard\nerror at each collection, summarizing the amount of memory collected and the\nlength of the pause. The format of this line is subject to change.\nCurrently, it is:\n\tgc # @#s #%: #+#+# ms clock, #+#/#/#+# ms cpu, #-\u003e#-\u003e# MB, # MB goal, # P\nwhere the fields are as follows:\n\tgc #        the GC number, incremented at each GC\n\t@#s         time in seconds since program start\n\t#%          percentage of time spent in GC since program start\n\t#+...+#     wall-clock/CPU times for the phases of the GC\n\t#-\u003e#-\u003e# MB  heap size at GC start, at GC end, and live heap\n\t# MB goal   goal heap size\n\t# P         number of processors used\nThe phases are stop-the-world (STW) sweep termination, concurrent\nmark and scan, and STW mark termination. The CPU times\nfor mark/scan are broken down in to assist time (GC performed in\nline with allocation), background GC time, and idle GC time.\nIf the line ends with \"(forced)\", this GC was forced by a\nruntime.GC() call.\n\nharddecommit: setting harddecommit=1 causes memory that is returned to the OS to\nalso have protections removed on it. This is the only mode of operation on Windows,\nbut is helpful in debugging scavenger-related issues on other platforms. Currently,\nonly supported on Linux.\n\ninittrace: setting inittrace=1 causes the runtime to emit a single line to standard\nerror for each package with init work, summarizing the execution time and memory\nallocation. No information is printed for inits executed as part of plugin loading\nand for packages without both user defined and compiler generated init work.\nThe format of this line is subject to change. Currently, it is:\n\tinit # @#ms, # ms clock, # bytes, # allocs\nwhere the fields are as follows:\n\tinit #      the package name\n\t@# ms       time in milliseconds when the init started since program start\n\t# clock     wall-clock time for package initialization work\n\t# bytes     memory allocated on the heap\n\t# allocs    number of heap allocations\n\nmadvdontneed: setting madvdontneed=0 will use MADV_FREE\ninstead of MADV_DONTNEED on Linux when returning memory to the\nkernel. This is more efficient, but means RSS numbers will\ndrop only when the OS is under memory pressure.\n\nmemprofilerate: setting memprofilerate=X will update the value of runtime.MemProfileRate.\nWhen set to 0 memory profiling is disabled.  Refer to the description of\nMemProfileRate for the default value.\n\ninvalidptr: invalidptr=1 (the default) causes the garbage collector and stack\ncopier to crash the program if an invalid pointer value (for example, 1)\nis found in a pointer-typed location. Setting invalidptr=0 disables this check.\nThis should only be used as a temporary workaround to diagnose buggy code.\nThe real fix is to not store integers in pointer-typed locations.\n\nsbrk: setting sbrk=1 replaces the memory allocator and garbage collector\nwith a trivial allocator that obtains memory from the operating system and\nnever reclaims any memory.\n\nscavtrace: setting scavtrace=1 causes the runtime to emit a single line to standard\nerror, roughly once per GC cycle, summarizing the amount of work done by the\nscavenger as well as the total amount of memory returned to the operating system\nand an estimate of physical memory utilization. The format of this line is subject\nto change, but currently it is:\n\tscav # # KiB work, # KiB total, #% util\nwhere the fields are as follows:\n\tscav #       the scavenge cycle number\n\t# KiB work   the amount of memory returned to the OS since the last line\n\t# KiB total  the total amount of memory returned to the OS\n\t#% util      the fraction of all unscavenged memory which is in-use\nIf the line ends with \"(forced)\", then scavenging was forced by a\ndebug.FreeOSMemory() call.\n\nscheddetail: setting schedtrace=X and scheddetail=1 causes the scheduler to emit\ndetailed multiline info every X milliseconds, describing state of the scheduler,\nprocessors, threads and goroutines.\n\nschedtrace: setting schedtrace=X causes the scheduler to emit a single line to standard\nerror every X milliseconds, summarizing the scheduler state.\n\ntracebackancestors: setting tracebackancestors=N extends tracebacks with the stacks at\nwhich goroutines were created, where N limits the number of ancestor goroutines to\nreport. This also extends the information returned by runtime.Stack. Ancestor's goroutine\nIDs will refer to the ID of the goroutine at the time of creation; it's possible for this\nID to be reused for another goroutine. Setting N to 0 will report no ancestry information.\n\nasyncpreemptoff: asyncpreemptoff=1 disables signal-based\nasynchronous goroutine preemption. This makes some loops\nnon-preemptible for long periods, which may delay GC and\ngoroutine scheduling. This is useful for debugging GC issues\nbecause it also disables the conservative stack scanning used\nfor asynchronously preempted goroutines.\n\n```\nThe net and net/http packages also refer to debugging variables in GODEBUG.\nSee the documentation for those packages for details.\n\nThe GOMAXPROCS variable limits the number of operating system threads that\ncan execute user-level Go code simultaneously. There is no limit to the number of threads\nthat can be blocked in system calls on behalf of Go code; those do not count against\nthe GOMAXPROCS limit. This package's GOMAXPROCS function queries and changes\nthe limit.\n\nThe GORACE variable configures the race detector, for programs built using -race.\nSee https://golang.org/doc/articles/race_detector.html for details.\n\nThe GOTRACEBACK variable controls the amount of output generated when a Go\nprogram fails due to an unrecovered panic or an unexpected runtime condition.\nBy default, a failure prints a stack trace for the current goroutine,\neliding functions internal to the run-time system, and then exits with exit code 2.\nThe failure prints stack traces for all goroutines if there is no current goroutine\nor the failure is internal to the run-time.\nGOTRACEBACK=none omits the goroutine stack traces entirely.\nGOTRACEBACK=single (the default) behaves as described above.\nGOTRACEBACK=all adds stack traces for all user-created goroutines.\nGOTRACEBACK=system is like ``all'' but adds stack frames for run-time functions\nand shows goroutines created internally by the run-time.\nGOTRACEBACK=crash is like ``system'' but crashes in an operating system-specific\nmanner instead of exiting. For example, on Unix systems, the crash raises\nSIGABRT to trigger a core dump.\nFor historical reasons, the GOTRACEBACK settings 0, 1, and 2 are synonyms for\nnone, all, and system, respectively.\nThe runtime/debug package's SetTraceback function allows increasing the\namount of output at run time, but it cannot reduce the amount below that\nspecified by the environment variable.\nSee https://golang.org/pkg/runtime/debug/#SetTraceback.\n\nThe GOARCH, GOOS, GOPATH, and GOROOT environment variables complete\nthe set of Go environment variables. They influence the building of Go programs\n(see https://golang.org/cmd/go and https://golang.org/pkg/go/build).\nGOARCH, GOOS, and GOROOT are recorded at compile time and made available by\nconstants or functions in this package, but they do not influence the execution\nof the run-time system.\n\n[\"runtime\" on pkg.go.dev](https://pkg.go.dev/runtime)",
    "url": "https://pkg.go.dev/runtime",
    "path": "runtime",
    "children": [
      {
        "name": "asan",
        "synopsis": "\n[\"runtime/asan\" on pkg.go.dev](https://pkg.go.dev/runtime/asan)",
        "url": "https://pkg.go.dev/runtime/asan",
        "path": "runtime/asan",
        "children": []
      },
      {
        "name": "cgo",
        "synopsis": "Package cgo contains runtime support for code generated\nby the cgo tool.  See the documentation for the cgo command\nfor details on using cgo.\n\n[\"runtime/cgo\" on pkg.go.dev](https://pkg.go.dev/runtime/cgo)",
        "url": "https://pkg.go.dev/runtime/cgo",
        "path": "runtime/cgo",
        "children": []
      },
      {
        "name": "debug",
        "synopsis": "Package debug contains facilities for programs to debug themselves while\nthey are running.\n\n[\"runtime/debug\" on pkg.go.dev](https://pkg.go.dev/runtime/debug)",
        "url": "https://pkg.go.dev/runtime/debug",
        "path": "runtime/debug",
        "children": []
      },
      {
        "name": "metrics",
        "synopsis": "Package metrics provides a stable interface to access implementation-defined\nmetrics exported by the Go runtime. This package is similar to existing functions\nlike runtime.ReadMemStats and debug.ReadGCStats, but significantly more general.\n\nThe set of metrics defined by this package may evolve as the runtime itself\nevolves, and also enables variation across Go implementations, whose relevant\nmetric sets may not intersect.\n\nInterface\n\nMetrics are designated by a string key, rather than, for example, a field name in\na struct. The full list of supported metrics is always available in the slice of\nDescriptions returned by All. Each Description also includes useful information\nabout the metric.\n\nThus, users of this API are encouraged to sample supported metrics defined by the\nslice returned by All to remain compatible across Go versions. Of course, situations\narise where reading specific metrics is critical. For these cases, users are\nencouraged to use build tags, and although metrics may be deprecated and removed,\nusers should consider this to be an exceptional and rare event, coinciding with a\nvery large change in a particular Go implementation.\n\nEach metric key also has a \"kind\" that describes the format of the metric's value.\nIn the interest of not breaking users of this package, the \"kind\" for a given metric\nis guaranteed not to change. If it must change, then a new metric will be introduced\nwith a new key and a new \"kind.\"\n\nMetric key format\n\nAs mentioned earlier, metric keys are strings. Their format is simple and well-defined,\ndesigned to be both human and machine readable. It is split into two components,\nseparated by a colon: a rooted path and a unit. The choice to include the unit in\nthe key is motivated by compatibility: if a metric's unit changes, its semantics likely\ndid also, and a new key should be introduced.\n\nFor more details on the precise definition of the metric key's path and unit formats, see\nthe documentation of the Name field of the Description struct.\n\nA note about floats\n\nThis package supports metrics whose values have a floating-point representation. In\norder to improve ease-of-use, this package promises to never produce the following\nclasses of floating-point values: NaN, infinity.\n\nSupported metrics\n\nBelow is the full list of supported metrics, ordered lexicographically.\n\n```\n/gc/cycles/automatic:gc-cycles\n\tCount of completed GC cycles generated by the Go runtime.\n\n/gc/cycles/forced:gc-cycles\n\tCount of completed GC cycles forced by the application.\n\n/gc/cycles/total:gc-cycles\n\tCount of all completed GC cycles.\n\n/gc/heap/allocs-by-size:bytes\n\tDistribution of heap allocations by approximate size.\n\tNote that this does not include tiny objects as defined by /gc/heap/tiny/allocs:objects,\n\tonly tiny blocks.\n\n/gc/heap/allocs:bytes\n\tCumulative sum of memory allocated to the heap by the application.\n\n/gc/heap/allocs:objects\n\tCumulative count of heap allocations triggered by the application.\n\tNote that this does not include tiny objects as defined by /gc/heap/tiny/allocs:objects,\n\tonly tiny blocks.\n\n/gc/heap/frees-by-size:bytes\n\tDistribution of freed heap allocations by approximate size.\n\tNote that this does not include tiny objects as defined by /gc/heap/tiny/allocs:objects,\n\tonly tiny blocks.\n\n/gc/heap/frees:bytes\n\tCumulative sum of heap memory freed by the garbage collector.\n\n/gc/heap/frees:objects\n\tCumulative count of heap allocations whose storage was freed by the garbage collector.\n\tNote that this does not include tiny objects as defined by /gc/heap/tiny/allocs:objects,\n\tonly tiny blocks.\n\n/gc/heap/goal:bytes\n\tHeap size target for the end of the GC cycle.\n\n/gc/heap/objects:objects\n\tNumber of objects, live or unswept, occupying heap memory.\n\n/gc/heap/tiny/allocs:objects\n\tCount of small allocations that are packed together into blocks.\n\tThese allocations are counted separately from other allocations\n\tbecause each individual allocation is not tracked by the runtime,\n\tonly their block. Each block is already accounted for in\n\tallocs-by-size and frees-by-size.\n\n/gc/pauses:seconds\n\tDistribution individual GC-related stop-the-world pause latencies.\n\n/memory/classes/heap/free:bytes\n\tMemory that is completely free and eligible to be returned to\n\tthe underlying system, but has not been. This metric is the\n\truntime's estimate of free address space that is backed by\n\tphysical memory.\n\n/memory/classes/heap/objects:bytes\n\tMemory occupied by live objects and dead objects that have\n\tnot yet been marked free by the garbage collector.\n\n/memory/classes/heap/released:bytes\n\tMemory that is completely free and has been returned to\n\tthe underlying system. This metric is the runtime's estimate of\n\tfree address space that is still mapped into the process, but\n\tis not backed by physical memory.\n\n/memory/classes/heap/stacks:bytes\n\tMemory allocated from the heap that is reserved for stack\n\tspace, whether or not it is currently in-use.\n\n/memory/classes/heap/unused:bytes\n\tMemory that is reserved for heap objects but is not currently\n\tused to hold heap objects.\n\n/memory/classes/metadata/mcache/free:bytes\n\tMemory that is reserved for runtime mcache structures, but\n\tnot in-use.\n\n/memory/classes/metadata/mcache/inuse:bytes\n\tMemory that is occupied by runtime mcache structures that\n\tare currently being used.\n\n/memory/classes/metadata/mspan/free:bytes\n\tMemory that is reserved for runtime mspan structures, but\n\tnot in-use.\n\n/memory/classes/metadata/mspan/inuse:bytes\n\tMemory that is occupied by runtime mspan structures that are\n\tcurrently being used.\n\n/memory/classes/metadata/other:bytes\n\tMemory that is reserved for or used to hold runtime\n\tmetadata.\n\n/memory/classes/os-stacks:bytes\n\tStack memory allocated by the underlying operating system.\n\n/memory/classes/other:bytes\n\tMemory used by execution trace buffers, structures for\n\tdebugging the runtime, finalizer and profiler specials, and\n\tmore.\n\n/memory/classes/profiling/buckets:bytes\n\tMemory that is used by the stack trace hash map used for\n\tprofiling.\n\n/memory/classes/total:bytes\n\tAll memory mapped by the Go runtime into the current process\n\tas read-write. Note that this does not include memory mapped\n\tby code called via cgo or via the syscall package.\n\tSum of all metrics in /memory/classes.\n\n/sched/goroutines:goroutines\n\tCount of live goroutines.\n\n/sched/latencies:seconds\n\tDistribution of the time goroutines have spent in the scheduler\n\tin a runnable state before actually running.\n\n[\"runtime/metrics\" on pkg.go.dev](https://pkg.go.dev/runtime/metrics)",
        "url": "https://pkg.go.dev/runtime/metrics",
        "path": "runtime/metrics",
        "children": []
      },
      {
        "name": "msan",
        "synopsis": "\n[\"runtime/msan\" on pkg.go.dev](https://pkg.go.dev/runtime/msan)",
        "url": "https://pkg.go.dev/runtime/msan",
        "path": "runtime/msan",
        "children": []
      },
      {
        "name": "pprof",
        "synopsis": "Package pprof writes runtime profiling data in the format expected\nby the pprof visualization tool.\n\nProfiling a Go program\n\nThe first step to profiling a Go program is to enable profiling.\nSupport for profiling benchmarks built with the standard testing\npackage is built into go test. For example, the following command\nruns benchmarks in the current directory and writes the CPU and\nmemory profiles to cpu.prof and mem.prof:\n\n    go test -cpuprofile cpu.prof -memprofile mem.prof -bench .\n\nTo add equivalent profiling support to a standalone program, add\ncode like the following to your main function:\n\n   var cpuprofile = flag.String(\"cpuprofile\", \"\", \"write cpu profile to `file`\")\n   var memprofile = flag.String(\"memprofile\", \"\", \"write memory profile to `file`\")\n\n   func main() {\n       flag.Parse()\n       if *cpuprofile != \"\" {\n           f, err := os.Create(*cpuprofile)\n           if err != nil {\n               log.Fatal(\"could not create CPU profile: \", err)\n           }\n           defer f.Close() // error handling omitted for example\n           if err := pprof.StartCPUProfile(f); err != nil {\n               log.Fatal(\"could not start CPU profile: \", err)\n           }\n           defer pprof.StopCPUProfile()\n       }\n\n       // ... rest of the program ...\n\n       if *memprofile != \"\" {\n           f, err := os.Create(*memprofile)\n           if err != nil {\n               log.Fatal(\"could not create memory profile: \", err)\n           }\n           defer f.Close() // error handling omitted for example\n           runtime.GC() // get up-to-date statistics\n           if err := pprof.WriteHeapProfile(f); err != nil {\n               log.Fatal(\"could not write memory profile: \", err)\n           }\n       }\n   }\n\nThere is also a standard HTTP interface to profiling data. Adding\nthe following line will install handlers under the /debug/pprof/\nURL to download live profiles:\n\n   import _ \"net/http/pprof\"\n\nSee the net/http/pprof package for more details.\n\nProfiles can then be visualized with the pprof tool:\n\n   go tool pprof cpu.prof\n\nThere are many commands available from the pprof command line.\nCommonly used commands include \"top\", which prints a summary of the\ntop program hot-spots, and \"web\", which opens an interactive graph\nof hot-spots and their call graphs. Use \"help\" for information on\nall pprof commands.\n\nFor more information about pprof, see\nhttps://github.com/google/pprof/blob/master/doc/README.md.\n\n[\"runtime/pprof\" on pkg.go.dev](https://pkg.go.dev/runtime/pprof)",
        "url": "https://pkg.go.dev/runtime/pprof",
        "path": "runtime/pprof",
        "children": []
      },
      {
        "name": "race",
        "synopsis": "Package race implements data race detection logic.\nNo public interface is provided.\nFor details about the race detector see\nhttps://golang.org/doc/articles/race_detector.html\n\n[\"runtime/race\" on pkg.go.dev](https://pkg.go.dev/runtime/race)",
        "url": "https://pkg.go.dev/runtime/race",
        "path": "runtime/race",
        "children": []
      },
      {
        "name": "trace",
        "synopsis": "Package trace contains facilities for programs to generate traces\nfor the Go execution tracer.\n\nTracing runtime activities\n\nThe execution trace captures a wide range of execution events such as\ngoroutine creation/blocking/unblocking, syscall enter/exit/block,\nGC-related events, changes of heap size, processor start/stop, etc.\nA precise nanosecond-precision timestamp and a stack trace is\ncaptured for most events. The generated trace can be interpreted\nusing `go tool trace`.\n\nSupport for tracing tests and benchmarks built with the standard\ntesting package is built into `go test`. For example, the following\ncommand runs the test in the current directory and writes the trace\nfile (trace.out).\n\n   go test -trace=trace.out\n\nThis runtime/trace package provides APIs to add equivalent tracing\nsupport to a standalone program. See the Example that demonstrates\nhow to use this API to enable tracing.\n\nThere is also a standard HTTP interface to trace data. Adding the\nfollowing line will install a handler under the /debug/pprof/trace URL\nto download a live trace:\n\n    import _ \"net/http/pprof\"\n\nSee the net/http/pprof package for more details about all of the\ndebug endpoints installed by this import.\n\nUser annotation\n\nPackage trace provides user annotation APIs that can be used to\nlog interesting events during execution.\n\nThere are three types of user annotations: log messages, regions,\nand tasks.\n\nLog emits a timestamped message to the execution trace along with\nadditional information such as the category of the message and\nwhich goroutine called Log. The execution tracer provides UIs to filter\nand group goroutines using the log category and the message supplied\nin Log.\n\nA region is for logging a time interval during a goroutine's execution.\nBy definition, a region starts and ends in the same goroutine.\nRegions can be nested to represent subintervals.\nFor example, the following code records four regions in the execution\ntrace to trace the durations of sequential steps in a cappuccino making\noperation.\n\n  trace.WithRegion(ctx, \"makeCappuccino\", func() {\n\n     // orderID allows to identify a specific order\n     // among many cappuccino order region records.\n     trace.Log(ctx, \"orderID\", orderID)\n\n     trace.WithRegion(ctx, \"steamMilk\", steamMilk)\n     trace.WithRegion(ctx, \"extractCoffee\", extractCoffee)\n     trace.WithRegion(ctx, \"mixMilkCoffee\", mixMilkCoffee)\n  })\n\nA task is a higher-level component that aids tracing of logical\noperations such as an RPC request, an HTTP request, or an\ninteresting local operation which may require multiple goroutines\nworking together. Since tasks can involve multiple goroutines,\nthey are tracked via a context.Context object. NewTask creates\na new task and embeds it in the returned context.Context object.\nLog messages and regions are attached to the task, if any, in the\nContext passed to Log and WithRegion.\n\nFor example, assume that we decided to froth milk, extract coffee,\nand mix milk and coffee in separate goroutines. With a task,\nthe trace tool can identify the goroutines involved in a specific\ncappuccino order.\n\n     ctx, task := trace.NewTask(ctx, \"makeCappuccino\")\n     trace.Log(ctx, \"orderID\", orderID)\n\n     milk := make(chan bool)\n     espresso := make(chan bool)\n\n     go func() {\n             trace.WithRegion(ctx, \"steamMilk\", steamMilk)\n             milk \u003c- true\n     }()\n     go func() {\n             trace.WithRegion(ctx, \"extractCoffee\", extractCoffee)\n             espresso \u003c- true\n     }()\n     go func() {\n             defer task.End() // When assemble is done, the order is complete.\n             \u003c-espresso\n             \u003c-milk\n             trace.WithRegion(ctx, \"mixMilkCoffee\", mixMilkCoffee)\n     }()\n\nThe trace tool computes the latency of a task by measuring the\ntime between the task creation and the task end and provides\nlatency distributions for each task type found in the trace.\n\n[\"runtime/trace\" on pkg.go.dev](https://pkg.go.dev/runtime/trace)",
        "url": "https://pkg.go.dev/runtime/trace",
        "path": "runtime/trace",
        "children": []
      }
    ]
  },
  {
    "name": "sort",
    "synopsis": "Package sort provides primitives for sorting slices and user-defined collections.\n\n[\"sort\" on pkg.go.dev](https://pkg.go.dev/sort)",
    "url": "https://pkg.go.dev/sort",
    "path": "sort",
    "children": []
  },
  {
    "name": "strconv",
    "synopsis": "Package strconv implements conversions to and from string representations\nof basic data types.\n\nNumeric Conversions\n\nThe most common numeric conversions are Atoi (string to int) and Itoa (int to string).\n\n```\ni, err := strconv.Atoi(\"-42\")\ns := strconv.Itoa(-42)\n\n```\nThese assume decimal and the Go int type.\n\nParseBool, ParseFloat, ParseInt, and ParseUint convert strings to values:\n\n```\nb, err := strconv.ParseBool(\"true\")\nf, err := strconv.ParseFloat(\"3.1415\", 64)\ni, err := strconv.ParseInt(\"-42\", 10, 64)\nu, err := strconv.ParseUint(\"42\", 10, 64)\n\n```\nThe parse functions return the widest type (float64, int64, and uint64),\nbut if the size argument specifies a narrower width the result can be\nconverted to that narrower type without data loss:\n\n```\ns := \"2147483647\" // biggest int32\ni64, err := strconv.ParseInt(s, 10, 32)\n...\ni := int32(i64)\n\n```\nFormatBool, FormatFloat, FormatInt, and FormatUint convert values to strings:\n\n```\ns := strconv.FormatBool(true)\ns := strconv.FormatFloat(3.1415, 'E', -1, 64)\ns := strconv.FormatInt(-42, 16)\ns := strconv.FormatUint(42, 16)\n\n```\nAppendBool, AppendFloat, AppendInt, and AppendUint are similar but\nappend the formatted value to a destination slice.\n\nString Conversions\n\nQuote and QuoteToASCII convert strings to quoted Go string literals.\nThe latter guarantees that the result is an ASCII string, by escaping\nany non-ASCII Unicode with \\u:\n\n```\nq := strconv.Quote(\"Hello, 世界\")\nq := strconv.QuoteToASCII(\"Hello, 世界\")\n\n```\nQuoteRune and QuoteRuneToASCII are similar but accept runes and\nreturn quoted Go rune literals.\n\nUnquote and UnquoteChar unquote Go string and rune literals.\n\n[\"strconv\" on pkg.go.dev](https://pkg.go.dev/strconv)",
    "url": "https://pkg.go.dev/strconv",
    "path": "strconv",
    "children": []
  },
  {
    "name": "strings",
    "synopsis": "Package strings implements simple functions to manipulate UTF-8 encoded strings.\n\nFor information about UTF-8 strings in Go, see https://blog.golang.org/strings.\n\n[\"strings\" on pkg.go.dev](https://pkg.go.dev/strings)",
    "url": "https://pkg.go.dev/strings",
    "path": "strings",
    "children": []
  },
  {
    "name": "sync",
    "synopsis": "Package sync provides basic synchronization primitives such as mutual\nexclusion locks. Other than the Once and WaitGroup types, most are intended\nfor use by low-level library routines. Higher-level synchronization is\nbetter done via channels and communication.\n\nValues containing the types defined in this package should not be copied.\n\n[\"sync\" on pkg.go.dev](https://pkg.go.dev/sync)",
    "url": "https://pkg.go.dev/sync",
    "path": "sync",
    "children": [
      {
        "name": "atomic",
        "synopsis": "Package atomic provides low-level atomic memory primitives\nuseful for implementing synchronization algorithms.\n\nThese functions require great care to be used correctly.\nExcept for special, low-level applications, synchronization is better\ndone with channels or the facilities of the sync package.\nShare memory by communicating;\ndon't communicate by sharing memory.\n\nThe swap operation, implemented by the SwapT functions, is the atomic\nequivalent of:\n\n```\nold = *addr\n*addr = new\nreturn old\n\n```\nThe compare-and-swap operation, implemented by the CompareAndSwapT\nfunctions, is the atomic equivalent of:\n\n```\nif *addr == old {\n\t*addr = new\n\treturn true\n}\nreturn false\n\n```\nThe add operation, implemented by the AddT functions, is the atomic\nequivalent of:\n\n```\n*addr += delta\nreturn *addr\n\n```\nThe load and store operations, implemented by the LoadT and StoreT\nfunctions, are the atomic equivalents of \"return *addr\" and\n\"*addr = val\".\n\n[\"sync/atomic\" on pkg.go.dev](https://pkg.go.dev/sync/atomic)",
        "url": "https://pkg.go.dev/sync/atomic",
        "path": "sync/atomic",
        "children": []
      }
    ]
  },
  {
    "name": "syscall",
    "synopsis": "Package syscall contains an interface to the low-level operating system\nprimitives. The details vary depending on the underlying system, and\nby default, godoc will display the syscall documentation for the current\nsystem. If you want godoc to display syscall documentation for another\nsystem, set $GOOS and $GOARCH to the desired system. For example, if\nyou want to view documentation for freebsd/arm on linux/amd64, set $GOOS\nto freebsd and $GOARCH to arm.\nThe primary use of syscall is inside other packages that provide a more\nportable interface to the system, such as \"os\", \"time\" and \"net\".  Use\nthose packages rather than this one if you can.\nFor details of the functions and data types in this package consult\nthe manuals for the appropriate operating system.\nThese calls return err == nil to indicate success; otherwise\nerr is an operating system error describing the failure.\nOn most systems, that error has type syscall.Errno.\n\nDeprecated: this package is locked down. Callers should use the\ncorresponding package in the golang.org/x/sys repository instead.\nThat is also where updates required by new systems or versions\nshould be applied. See https://golang.org/s/go1.4-syscall for more\ninformation.\n\n[\"syscall\" on pkg.go.dev](https://pkg.go.dev/syscall)",
    "url": "https://pkg.go.dev/syscall",
    "path": "syscall",
    "children": [
      {
        "name": "js",
        "synopsis": "Package js gives access to the WebAssembly host environment when using the js/wasm architecture.\nIts API is based on JavaScript semantics.\n\nThis package is EXPERIMENTAL. Its current scope is only to allow tests to run, but not yet to provide a\ncomprehensive API for users. It is exempt from the Go compatibility promise.\n\n[\"syscall/js\" on pkg.go.dev](https://pkg.go.dev/syscall/js)",
        "url": "https://pkg.go.dev/syscall/js",
        "path": "syscall/js",
        "children": []
      }
    ]
  },
  {
    "name": "testing",
    "synopsis": "Package testing provides support for automated testing of Go packages.\nIt is intended to be used in concert with the \"go test\" command, which automates\nexecution of any function of the form\n    func TestXxx(*testing.T)\nwhere Xxx does not start with a lowercase letter. The function name\nserves to identify the test routine.\n\nWithin these functions, use the Error, Fail or related methods to signal failure.\n\nTo write a new test suite, create a file whose name ends _test.go that\ncontains the TestXxx functions as described here. Put the file in the same\npackage as the one being tested. The file will be excluded from regular\npackage builds but will be included when the \"go test\" command is run.\nFor more detail, run \"go help test\" and \"go help testflag\".\n\nA simple test function looks like this:\n\n    func TestAbs(t *testing.T) {\n        got := Abs(-1)\n        if got != 1 {\n            t.Errorf(\"Abs(-1) = %d; want 1\", got)\n        }\n    }\n\nBenchmarks\n\nFunctions of the form\n    func BenchmarkXxx(*testing.B)\nare considered benchmarks, and are executed by the \"go test\" command when\nits -bench flag is provided. Benchmarks are run sequentially.\n\nFor a description of the testing flags, see\nhttps://golang.org/cmd/go/#hdr-Testing_flags.\n\nA sample benchmark function looks like this:\n    func BenchmarkRandInt(b *testing.B) {\n        for i := 0; i \u003c b.N; i++ {\n            rand.Int()\n        }\n    }\n\nThe benchmark function must run the target code b.N times.\nDuring benchmark execution, b.N is adjusted until the benchmark function lasts\nlong enough to be timed reliably. The output\n    BenchmarkRandInt-8   \t68453040\t        17.8 ns/op\nmeans that the loop ran 68453040 times at a speed of 17.8 ns per loop.\n\nIf a benchmark needs some expensive setup before running, the timer\nmay be reset:\n\n    func BenchmarkBigLen(b *testing.B) {\n        big := NewBig()\n        b.ResetTimer()\n        for i := 0; i \u003c b.N; i++ {\n            big.Len()\n        }\n    }\n\nIf a benchmark needs to test performance in a parallel setting, it may use\nthe RunParallel helper function; such benchmarks are intended to be used with\nthe go test -cpu flag:\n\n    func BenchmarkTemplateParallel(b *testing.B) {\n        templ := template.Must(template.New(\"test\").Parse(\"Hello, {{.}}!\"))\n        b.RunParallel(func(pb *testing.PB) {\n            var buf bytes.Buffer\n            for pb.Next() {\n                buf.Reset()\n                templ.Execute(\u0026buf, \"World\")\n            }\n        })\n    }\n\nA detailed specification of the benchmark results format is given\nin https://golang.org/design/14313-benchmark-format.\n\nThere are standard tools for working with benchmark results at\nhttps://golang.org/x/perf/cmd.\nIn particular, https://golang.org/x/perf/cmd/benchstat performs\nstatistically robust A/B comparisons.\n\nExamples\n\nThe package also runs and verifies example code. Example functions may\ninclude a concluding line comment that begins with \"Output:\" and is compared with\nthe standard output of the function when the tests are run. (The comparison\nignores leading and trailing space.) These are examples of an example:\n\n    func ExampleHello() {\n        fmt.Println(\"hello\")\n        // Output: hello\n    }\n\n    func ExampleSalutations() {\n        fmt.Println(\"hello, and\")\n        fmt.Println(\"goodbye\")\n        // Output:\n        // hello, and\n        // goodbye\n    }\n\nThe comment prefix \"Unordered output:\" is like \"Output:\", but matches any\nline order:\n\n    func ExamplePerm() {\n        for _, value := range Perm(5) {\n            fmt.Println(value)\n        }\n        // Unordered output: 4\n        // 2\n        // 1\n        // 3\n        // 0\n    }\n\nExample functions without output comments are compiled but not executed.\n\nThe naming convention to declare examples for the package, a function F, a type T and\nmethod M on type T are:\n\n    func Example() { ... }\n    func ExampleF() { ... }\n    func ExampleT() { ... }\n    func ExampleT_M() { ... }\n\nMultiple example functions for a package/type/function/method may be provided by\nappending a distinct suffix to the name. The suffix must start with a\nlower-case letter.\n\n    func Example_suffix() { ... }\n    func ExampleF_suffix() { ... }\n    func ExampleT_suffix() { ... }\n    func ExampleT_M_suffix() { ... }\n\nThe entire test file is presented as the example when it contains a single\nexample function, at least one other function, type, variable, or constant\ndeclaration, and no test or benchmark functions.\n\nFuzzing\n\n'go test' and the testing package support fuzzing, a testing technique where\na function is called with randomly generated inputs to find bugs not\nanticipated by unit tests.\n\nFunctions of the form\n    func FuzzXxx(*testing.F)\nare considered fuzz tests.\n\nFor example:\n\n    func FuzzHex(f *testing.F) {\n      for _, seed := range [][]byte{{}, {0}, {9}, {0xa}, {0xf}, {1, 2, 3, 4}} {\n        f.Add(seed)\n      }\n      f.Fuzz(func(t *testing.T, in []byte) {\n        enc := hex.EncodeToString(in)\n        out, err := hex.DecodeString(enc)\n        if err != nil {\n          t.Fatalf(\"%v: decode: %v\", in, err)\n        }\n        if !bytes.Equal(in, out) {\n          t.Fatalf(\"%v: not equal after round trip: %v\", in, out)\n        }\n      })\n    }\n\nA fuzz test maintains a seed corpus, or a set of inputs which are run by\ndefault, and can seed input generation. Seed inputs may be registered by\ncalling (*F).Add or by storing files in the directory testdata/fuzz/\u003cName\u003e\n(where \u003cName\u003e is the name of the fuzz test) within the package containing\nthe fuzz test. Seed inputs are optional, but the fuzzing engine may find\nbugs more efficiently when provided with a set of small seed inputs with good\ncode coverage. These seed inputs can also serve as regression tests for bugs\nidentified through fuzzing.\n\nThe function passed to (*F).Fuzz within the fuzz test is considered the fuzz\ntarget. A fuzz target must accept a *T parameter, followed by one or more\nparameters for random inputs. The types of arguments passed to (*F).Add must\nbe identical to the types of these parameters. The fuzz target may signal\nthat it's found a problem the same way tests do: by calling T.Fail (or any\nmethod that calls it like T.Error or T.Fatal) or by panicking.\n\nWhen fuzzing is enabled (by setting the -fuzz flag to a regular expression\nthat matches a specific fuzz test), the fuzz target is called with arguments\ngenerated by repeatedly making random changes to the seed inputs. On\nsupported platforms, 'go test' compiles the test executable with fuzzing\ncoverage instrumentation. The fuzzing engine uses that instrumentation to\nfind and cache inputs that expand coverage, increasing the likelihood of\nfinding bugs. If the fuzz target fails for a given input, the fuzzing engine\nwrites the inputs that caused the failure to a file in the directory\ntestdata/fuzz/\u003cName\u003e within the package directory. This file later serves as\na seed input. If the file can't be written at that location (for example,\nbecause the directory is read-only), the fuzzing engine writes the file to\nthe fuzz cache directory within the build cache instead.\n\nWhen fuzzing is disabled, the fuzz target is called with the seed inputs\nregistered with F.Add and seed inputs from testdata/fuzz/\u003cName\u003e. In this\nmode, the fuzz test acts much like a regular test, with subtests started\nwith F.Fuzz instead of T.Run.\n\nSee https://go.dev/doc/fuzz for documentation about fuzzing.\n\nSkipping\n\nTests or benchmarks may be skipped at run time with a call to\nthe Skip method of *T or *B:\n\n    func TestTimeConsuming(t *testing.T) {\n        if testing.Short() {\n            t.Skip(\"skipping test in short mode.\")\n        }\n        ...\n    }\n\nThe Skip method of *T can be used in a fuzz target if the input is invalid,\nbut should not be considered a failing input. For example:\n\n    func FuzzJSONMarshalling(f *testing.F) {\n        f.Fuzz(func(t *testing.T, b []byte) {\n            var v interface{}\n            if err := json.Unmarshal(b, \u0026v); err != nil {\n                t.Skip()\n            }\n            if _, err := json.Marshal(v); err != nil {\n                t.Error(\"Marshal: %v\", err)\n            }\n        })\n    }\n\nSubtests and Sub-benchmarks\n\nThe Run methods of T and B allow defining subtests and sub-benchmarks,\nwithout having to define separate functions for each. This enables uses\nlike table-driven benchmarks and creating hierarchical tests.\nIt also provides a way to share common setup and tear-down code:\n\n    func TestFoo(t *testing.T) {\n        // \u003csetup code\u003e\n        t.Run(\"A=1\", func(t *testing.T) { ... })\n        t.Run(\"A=2\", func(t *testing.T) { ... })\n        t.Run(\"B=1\", func(t *testing.T) { ... })\n        // \u003ctear-down code\u003e\n    }\n\nEach subtest and sub-benchmark has a unique name: the combination of the name\nof the top-level test and the sequence of names passed to Run, separated by\nslashes, with an optional trailing sequence number for disambiguation.\n\nThe argument to the -run, -bench, and -fuzz command-line flags is an unanchored regular\nexpression that matches the test's name. For tests with multiple slash-separated\nelements, such as subtests, the argument is itself slash-separated, with\nexpressions matching each name element in turn. Because it is unanchored, an\nempty expression matches any string.\nFor example, using \"matching\" to mean \"whose name contains\":\n\n    go test -run ''        # Run all tests.\n    go test -run Foo       # Run top-level tests matching \"Foo\", such as \"TestFooBar\".\n    go test -run Foo/A=    # For top-level tests matching \"Foo\", run subtests matching \"A=\".\n    go test -run /A=1      # For all top-level tests, run subtests matching \"A=1\".\n    go test -fuzz FuzzFoo  # Fuzz the target matching \"FuzzFoo\"\n\nThe -run argument can also be used to run a specific value in the seed\ncorpus, for debugging. For example:\n    go test -run=FuzzFoo/9ddb952d9814\n\nThe -fuzz and -run flags can both be set, in order to fuzz a target but\nskip the execution of all other tests.\n\nSubtests can also be used to control parallelism. A parent test will only\ncomplete once all of its subtests complete. In this example, all tests are\nrun in parallel with each other, and only with each other, regardless of\nother top-level tests that may be defined:\n\n    func TestGroupedParallel(t *testing.T) {\n        for _, tc := range tests {\n            tc := tc // capture range variable\n            t.Run(tc.Name, func(t *testing.T) {\n                t.Parallel()\n                ...\n            })\n        }\n    }\n\nThe race detector kills the program if it exceeds 8128 concurrent goroutines,\nso use care when running parallel tests with the -race flag set.\n\nRun does not return until parallel subtests have completed, providing a way\nto clean up after a group of parallel tests:\n\n    func TestTeardownParallel(t *testing.T) {\n        // This Run will not return until the parallel tests finish.\n        t.Run(\"group\", func(t *testing.T) {\n            t.Run(\"Test1\", parallelTest1)\n            t.Run(\"Test2\", parallelTest2)\n            t.Run(\"Test3\", parallelTest3)\n        })\n        // \u003ctear-down code\u003e\n    }\n\nMain\n\nIt is sometimes necessary for a test or benchmark program to do extra setup or teardown\nbefore or after it executes. It is also sometimes necessary to control\nwhich code runs on the main thread. To support these and other cases,\nif a test file contains a function:\n\n```\nfunc TestMain(m *testing.M)\n\n```\nthen the generated test will call TestMain(m) instead of running the tests or benchmarks\ndirectly. TestMain runs in the main goroutine and can do whatever setup\nand teardown is necessary around a call to m.Run. m.Run will return an exit\ncode that may be passed to os.Exit. If TestMain returns, the test wrapper\nwill pass the result of m.Run to os.Exit itself.\n\nWhen TestMain is called, flag.Parse has not been run. If TestMain depends on\ncommand-line flags, including those of the testing package, it should call\nflag.Parse explicitly. Command line flags are always parsed by the time test\nor benchmark functions run.\n\nA simple implementation of TestMain is:\n\n```\nfunc TestMain(m *testing.M) {\n\t// call flag.Parse() here if TestMain uses flags\n\tos.Exit(m.Run())\n}\n\n```\nTestMain is a low-level primitive and should not be necessary for casual\ntesting needs, where ordinary test functions suffice.\n\n[\"testing\" on pkg.go.dev](https://pkg.go.dev/testing)",
    "url": "https://pkg.go.dev/testing",
    "path": "testing",
    "children": [
      {
        "name": "fstest",
        "synopsis": "Package fstest implements support for testing implementations and users of file systems.\n\n[\"testing/fstest\" on pkg.go.dev](https://pkg.go.dev/testing/fstest)",
        "url": "https://pkg.go.dev/testing/fstest",
        "path": "testing/fstest",
        "children": []
      },
      {
        "name": "iotest",
        "synopsis": "Package iotest implements Readers and Writers useful mainly for testing.\n\n[\"testing/iotest\" on pkg.go.dev](https://pkg.go.dev/testing/iotest)",
        "url": "https://pkg.go.dev/testing/iotest",
        "path": "testing/iotest",
        "children": []
      },
      {
        "name": "quick",
        "synopsis": "Package quick implements utility functions to help with black box testing.\n\nThe testing/quick package is frozen and is not accepting new features.\n\n[\"testing/quick\" on pkg.go.dev](https://pkg.go.dev/testing/quick)",
        "url": "https://pkg.go.dev/testing/quick",
        "path": "testing/quick",
        "children": []
      }
    ]
  },
  {
    "name": "text",
    "synopsis": "",
    "url": "https://pkg.go.dev/text",
    "path": "text",
    "children": [
      {
        "name": "scanner",
        "synopsis": "Package scanner provides a scanner and tokenizer for UTF-8-encoded text.\nIt takes an io.Reader providing the source, which then can be tokenized\nthrough repeated calls to the Scan function. For compatibility with\nexisting tools, the NUL character is not allowed. If the first character\nin the source is a UTF-8 encoded byte order mark (BOM), it is discarded.\n\nBy default, a Scanner skips white space and Go comments and recognizes all\nliterals as defined by the Go language specification. It may be\ncustomized to recognize only a subset of those literals and to recognize\ndifferent identifier and white space characters.\n\n[\"text/scanner\" on pkg.go.dev](https://pkg.go.dev/text/scanner)",
        "url": "https://pkg.go.dev/text/scanner",
        "path": "text/scanner",
        "children": []
      },
      {
        "name": "tabwriter",
        "synopsis": "Package tabwriter implements a write filter (tabwriter.Writer) that\ntranslates tabbed columns in input into properly aligned text.\n\nThe package is using the Elastic Tabstops algorithm described at\nhttp://nickgravgaard.com/elastictabstops/index.html.\n\nThe text/tabwriter package is frozen and is not accepting new features.\n\n[\"text/tabwriter\" on pkg.go.dev](https://pkg.go.dev/text/tabwriter)",
        "url": "https://pkg.go.dev/text/tabwriter",
        "path": "text/tabwriter",
        "children": []
      },
      {
        "name": "template",
        "synopsis": "Package template implements data-driven templates for generating textual output.\n\nTo generate HTML output, see package html/template, which has the same interface\nas this package but automatically secures HTML output against certain attacks.\n\nTemplates are executed by applying them to a data structure. Annotations in the\ntemplate refer to elements of the data structure (typically a field of a struct\nor a key in a map) to control execution and derive values to be displayed.\nExecution of the template walks the structure and sets the cursor, represented\nby a period '.' and called \"dot\", to the value at the current location in the\nstructure as execution proceeds.\n\nThe input text for a template is UTF-8-encoded text in any format.\n\"Actions\"--data evaluations or control structures--are delimited by\n\"{{\" and \"}}\"; all text outside actions is copied to the output unchanged.\nExcept for raw strings, actions may not span newlines, although comments can.\n\nOnce parsed, a template may be executed safely in parallel, although if parallel\nexecutions share a Writer the output may be interleaved.\n\nHere is a trivial example that prints \"17 items are made of wool\".\n\n```\ntype Inventory struct {\n\tMaterial string\n\tCount    uint\n}\nsweaters := Inventory{\"wool\", 17}\ntmpl, err := template.New(\"test\").Parse(\"{{.Count}} items are made of {{.Material}}\")\nif err != nil { panic(err) }\nerr = tmpl.Execute(os.Stdout, sweaters)\nif err != nil { panic(err) }\n\n```\nMore intricate examples appear below.\n\nText and spaces\n\nBy default, all text between actions is copied verbatim when the template is\nexecuted. For example, the string \" items are made of \" in the example above\nappears on standard output when the program is run.\n\nHowever, to aid in formatting template source code, if an action's left\ndelimiter (by default \"{{\") is followed immediately by a minus sign and white\nspace, all trailing white space is trimmed from the immediately preceding text.\nSimilarly, if the right delimiter (\"}}\") is preceded by white space and a minus\nsign, all leading white space is trimmed from the immediately following text.\nIn these trim markers, the white space must be present:\n\"{{- 3}}\" is like \"{{3}}\" but trims the immediately preceding text, while\n\"{{-3}}\" parses as an action containing the number -3.\n\nFor instance, when executing the template whose source is\n\n```\n\"{{23 -}} \u003c {{- 45}}\"\n\n```\nthe generated output would be\n\n```\n\"23\u003c45\"\n\n```\nFor this trimming, the definition of white space characters is the same as in Go:\nspace, horizontal tab, carriage return, and newline.\n\nActions\n\nHere is the list of actions. \"Arguments\" and \"pipelines\" are evaluations of\ndata, defined in detail in the corresponding sections that follow.\n\n```\n{{/* a comment */}}\n{{- /* a comment with white space trimmed from preceding and following text */ -}}\n\tA comment; discarded. May contain newlines.\n\tComments do not nest and must start and end at the\n\tdelimiters, as shown here.\n\n{{pipeline}}\n\tThe default textual representation (the same as would be\n\tprinted by fmt.Print) of the value of the pipeline is copied\n\tto the output.\n\n{{if pipeline}} T1 {{end}}\n\tIf the value of the pipeline is empty, no output is generated;\n\totherwise, T1 is executed. The empty values are false, 0, any\n\tnil pointer or interface value, and any array, slice, map, or\n\tstring of length zero.\n\tDot is unaffected.\n\n{{if pipeline}} T1 {{else}} T0 {{end}}\n\tIf the value of the pipeline is empty, T0 is executed;\n\totherwise, T1 is executed. Dot is unaffected.\n\n{{if pipeline}} T1 {{else if pipeline}} T0 {{end}}\n\tTo simplify the appearance of if-else chains, the else action\n\tof an if may include another if directly; the effect is exactly\n\tthe same as writing\n\t\t{{if pipeline}} T1 {{else}}{{if pipeline}} T0 {{end}}{{end}}\n\n{{range pipeline}} T1 {{end}}\n\tThe value of the pipeline must be an array, slice, map, or channel.\n\tIf the value of the pipeline has length zero, nothing is output;\n\totherwise, dot is set to the successive elements of the array,\n\tslice, or map and T1 is executed. If the value is a map and the\n\tkeys are of basic type with a defined order, the elements will be\n\tvisited in sorted key order.\n\n{{range pipeline}} T1 {{else}} T0 {{end}}\n\tThe value of the pipeline must be an array, slice, map, or channel.\n\tIf the value of the pipeline has length zero, dot is unaffected and\n\tT0 is executed; otherwise, dot is set to the successive elements\n\tof the array, slice, or map and T1 is executed.\n\n{{break}}\n\tThe innermost {{range pipeline}} loop is ended early, stopping the\n\tcurrent iteration and bypassing all remaining iterations.\n\n{{continue}}\n\tThe current iteration of the innermost {{range pipeline}} loop is\n\tstopped, and the loop starts the next iteration.\n\n{{template \"name\"}}\n\tThe template with the specified name is executed with nil data.\n\n{{template \"name\" pipeline}}\n\tThe template with the specified name is executed with dot set\n\tto the value of the pipeline.\n\n{{block \"name\" pipeline}} T1 {{end}}\n\tA block is shorthand for defining a template\n\t\t{{define \"name\"}} T1 {{end}}\n\tand then executing it in place\n\t\t{{template \"name\" pipeline}}\n\tThe typical use is to define a set of root templates that are\n\tthen customized by redefining the block templates within.\n\n{{with pipeline}} T1 {{end}}\n\tIf the value of the pipeline is empty, no output is generated;\n\totherwise, dot is set to the value of the pipeline and T1 is\n\texecuted.\n\n{{with pipeline}} T1 {{else}} T0 {{end}}\n\tIf the value of the pipeline is empty, dot is unaffected and T0\n\tis executed; otherwise, dot is set to the value of the pipeline\n\tand T1 is executed.\n\n```\nArguments\n\nAn argument is a simple value, denoted by one of the following.\n\n```\n- A boolean, string, character, integer, floating-point, imaginary\n  or complex constant in Go syntax. These behave like Go's untyped\n  constants. Note that, as in Go, whether a large integer constant\n  overflows when assigned or passed to a function can depend on whether\n  the host machine's ints are 32 or 64 bits.\n- The keyword nil, representing an untyped Go nil.\n- The character '.' (period):\n\t.\n  The result is the value of dot.\n- A variable name, which is a (possibly empty) alphanumeric string\n  preceded by a dollar sign, such as\n\t$piOver2\n  or\n\t$\n  The result is the value of the variable.\n  Variables are described below.\n- The name of a field of the data, which must be a struct, preceded\n  by a period, such as\n\t.Field\n  The result is the value of the field. Field invocations may be\n  chained:\n    .Field1.Field2\n  Fields can also be evaluated on variables, including chaining:\n    $x.Field1.Field2\n- The name of a key of the data, which must be a map, preceded\n  by a period, such as\n\t.Key\n  The result is the map element value indexed by the key.\n  Key invocations may be chained and combined with fields to any\n  depth:\n    .Field1.Key1.Field2.Key2\n  Although the key must be an alphanumeric identifier, unlike with\n  field names they do not need to start with an upper case letter.\n  Keys can also be evaluated on variables, including chaining:\n    $x.key1.key2\n- The name of a niladic method of the data, preceded by a period,\n  such as\n\t.Method\n  The result is the value of invoking the method with dot as the\n  receiver, dot.Method(). Such a method must have one return value (of\n  any type) or two return values, the second of which is an error.\n  If it has two and the returned error is non-nil, execution terminates\n  and an error is returned to the caller as the value of Execute.\n  Method invocations may be chained and combined with fields and keys\n  to any depth:\n    .Field1.Key1.Method1.Field2.Key2.Method2\n  Methods can also be evaluated on variables, including chaining:\n    $x.Method1.Field\n- The name of a niladic function, such as\n\tfun\n  The result is the value of invoking the function, fun(). The return\n  types and values behave as in methods. Functions and function\n  names are described below.\n- A parenthesized instance of one the above, for grouping. The result\n  may be accessed by a field or map key invocation.\n\tprint (.F1 arg1) (.F2 arg2)\n\t(.StructValuedMethod \"arg\").Field\n\n```\nArguments may evaluate to any type; if they are pointers the implementation\nautomatically indirects to the base type when required.\nIf an evaluation yields a function value, such as a function-valued\nfield of a struct, the function is not invoked automatically, but it\ncan be used as a truth value for an if action and the like. To invoke\nit, use the call function, defined below.\n\nPipelines\n\nA pipeline is a possibly chained sequence of \"commands\". A command is a simple\nvalue (argument) or a function or method call, possibly with multiple arguments:\n\n```\nArgument\n\tThe result is the value of evaluating the argument.\n.Method [Argument...]\n\tThe method can be alone or the last element of a chain but,\n\tunlike methods in the middle of a chain, it can take arguments.\n\tThe result is the value of calling the method with the\n\targuments:\n\t\tdot.Method(Argument1, etc.)\nfunctionName [Argument...]\n\tThe result is the value of calling the function associated\n\twith the name:\n\t\tfunction(Argument1, etc.)\n\tFunctions and function names are described below.\n\n```\nA pipeline may be \"chained\" by separating a sequence of commands with pipeline\ncharacters '|'. In a chained pipeline, the result of each command is\npassed as the last argument of the following command. The output of the final\ncommand in the pipeline is the value of the pipeline.\n\nThe output of a command will be either one value or two values, the second of\nwhich has type error. If that second value is present and evaluates to\nnon-nil, execution terminates and the error is returned to the caller of\nExecute.\n\nVariables\n\nA pipeline inside an action may initialize a variable to capture the result.\nThe initialization has syntax\n\n```\n$variable := pipeline\n\n```\nwhere $variable is the name of the variable. An action that declares a\nvariable produces no output.\n\nVariables previously declared can also be assigned, using the syntax\n\n```\n$variable = pipeline\n\n```\nIf a \"range\" action initializes a variable, the variable is set to the\nsuccessive elements of the iteration. Also, a \"range\" may declare two\nvariables, separated by a comma:\n\n```\nrange $index, $element := pipeline\n\n```\nin which case $index and $element are set to the successive values of the\narray/slice index or map key and element, respectively. Note that if there is\nonly one variable, it is assigned the element; this is opposite to the\nconvention in Go range clauses.\n\nA variable's scope extends to the \"end\" action of the control structure (\"if\",\n\"with\", or \"range\") in which it is declared, or to the end of the template if\nthere is no such control structure. A template invocation does not inherit\nvariables from the point of its invocation.\n\nWhen execution begins, $ is set to the data argument passed to Execute, that is,\nto the starting value of dot.\n\nExamples\n\nHere are some example one-line templates demonstrating pipelines and variables.\nAll produce the quoted word \"output\":\n\n```\n{{\"\\\"output\\\"\"}}\n\tA string constant.\n{{`\"output\"`}}\n\tA raw string constant.\n{{printf \"%q\" \"output\"}}\n\tA function call.\n{{\"output\" | printf \"%q\"}}\n\tA function call whose final argument comes from the previous\n\tcommand.\n{{printf \"%q\" (print \"out\" \"put\")}}\n\tA parenthesized argument.\n{{\"put\" | printf \"%s%s\" \"out\" | printf \"%q\"}}\n\tA more elaborate call.\n{{\"output\" | printf \"%s\" | printf \"%q\"}}\n\tA longer chain.\n{{with \"output\"}}{{printf \"%q\" .}}{{end}}\n\tA with action using dot.\n{{with $x := \"output\" | printf \"%q\"}}{{$x}}{{end}}\n\tA with action that creates and uses a variable.\n{{with $x := \"output\"}}{{printf \"%q\" $x}}{{end}}\n\tA with action that uses the variable in another action.\n{{with $x := \"output\"}}{{$x | printf \"%q\"}}{{end}}\n\tThe same, but pipelined.\n\n```\nFunctions\n\nDuring execution functions are found in two function maps: first in the\ntemplate, then in the global function map. By default, no functions are defined\nin the template but the Funcs method can be used to add them.\n\nPredefined global functions are named as follows.\n\n```\nand\n\tReturns the boolean AND of its arguments by returning the\n\tfirst empty argument or the last argument. That is,\n\t\"and x y\" behaves as \"if x then y else x.\"\n\tEvaluation proceeds through the arguments left to right\n\tand returns when the result is determined.\ncall\n\tReturns the result of calling the first argument, which\n\tmust be a function, with the remaining arguments as parameters.\n\tThus \"call .X.Y 1 2\" is, in Go notation, dot.X.Y(1, 2) where\n\tY is a func-valued field, map entry, or the like.\n\tThe first argument must be the result of an evaluation\n\tthat yields a value of function type (as distinct from\n\ta predefined function such as print). The function must\n\treturn either one or two result values, the second of which\n\tis of type error. If the arguments don't match the function\n\tor the returned error value is non-nil, execution stops.\nhtml\n\tReturns the escaped HTML equivalent of the textual\n\trepresentation of its arguments. This function is unavailable\n\tin html/template, with a few exceptions.\nindex\n\tReturns the result of indexing its first argument by the\n\tfollowing arguments. Thus \"index x 1 2 3\" is, in Go syntax,\n\tx[1][2][3]. Each indexed item must be a map, slice, or array.\nslice\n\tslice returns the result of slicing its first argument by the\n\tremaining arguments. Thus \"slice x 1 2\" is, in Go syntax, x[1:2],\n\twhile \"slice x\" is x[:], \"slice x 1\" is x[1:], and \"slice x 1 2 3\"\n\tis x[1:2:3]. The first argument must be a string, slice, or array.\njs\n\tReturns the escaped JavaScript equivalent of the textual\n\trepresentation of its arguments.\nlen\n\tReturns the integer length of its argument.\nnot\n\tReturns the boolean negation of its single argument.\nor\n\tReturns the boolean OR of its arguments by returning the\n\tfirst non-empty argument or the last argument, that is,\n\t\"or x y\" behaves as \"if x then x else y\".\n\tEvaluation proceeds through the arguments left to right\n\tand returns when the result is determined.\nprint\n\tAn alias for fmt.Sprint\nprintf\n\tAn alias for fmt.Sprintf\nprintln\n\tAn alias for fmt.Sprintln\nurlquery\n\tReturns the escaped value of the textual representation of\n\tits arguments in a form suitable for embedding in a URL query.\n\tThis function is unavailable in html/template, with a few\n\texceptions.\n\n```\nThe boolean functions take any zero value to be false and a non-zero\nvalue to be true.\n\nThere is also a set of binary comparison operators defined as\nfunctions:\n\n```\neq\n\tReturns the boolean truth of arg1 == arg2\nne\n\tReturns the boolean truth of arg1 != arg2\nlt\n\tReturns the boolean truth of arg1 \u003c arg2\nle\n\tReturns the boolean truth of arg1 \u003c= arg2\ngt\n\tReturns the boolean truth of arg1 \u003e arg2\nge\n\tReturns the boolean truth of arg1 \u003e= arg2\n\n```\nFor simpler multi-way equality tests, eq (only) accepts two or more\narguments and compares the second and subsequent to the first,\nreturning in effect\n\n```\narg1==arg2 || arg1==arg3 || arg1==arg4 ...\n\n```\n(Unlike with || in Go, however, eq is a function call and all the\narguments will be evaluated.)\n\nThe comparison functions work on any values whose type Go defines as\ncomparable. For basic types such as integers, the rules are relaxed:\nsize and exact type are ignored, so any integer value, signed or unsigned,\nmay be compared with any other integer value. (The arithmetic value is compared,\nnot the bit pattern, so all negative integers are less than all unsigned integers.)\nHowever, as usual, one may not compare an int with a float32 and so on.\n\nAssociated templates\n\nEach template is named by a string specified when it is created. Also, each\ntemplate is associated with zero or more other templates that it may invoke by\nname; such associations are transitive and form a name space of templates.\n\nA template may use a template invocation to instantiate another associated\ntemplate; see the explanation of the \"template\" action above. The name must be\nthat of a template associated with the template that contains the invocation.\n\nNested template definitions\n\nWhen parsing a template, another template may be defined and associated with the\ntemplate being parsed. Template definitions must appear at the top level of the\ntemplate, much like global variables in a Go program.\n\nThe syntax of such definitions is to surround each template declaration with a\n\"define\" and \"end\" action.\n\nThe define action names the template being created by providing a string\nconstant. Here is a simple example:\n\n```\n`{{define \"T1\"}}ONE{{end}}\n{{define \"T2\"}}TWO{{end}}\n{{define \"T3\"}}{{template \"T1\"}} {{template \"T2\"}}{{end}}\n{{template \"T3\"}}`\n\n```\nThis defines two templates, T1 and T2, and a third T3 that invokes the other two\nwhen it is executed. Finally it invokes T3. If executed this template will\nproduce the text\n\n```\nONE TWO\n\n```\nBy construction, a template may reside in only one association. If it's\nnecessary to have a template addressable from multiple associations, the\ntemplate definition must be parsed multiple times to create distinct *Template\nvalues, or must be copied with the Clone or AddParseTree method.\n\nParse may be called multiple times to assemble the various associated templates;\nsee the ParseFiles and ParseGlob functions and methods for simple ways to parse\nrelated templates stored in files.\n\nA template may be executed directly or through ExecuteTemplate, which executes\nan associated template identified by name. To invoke our example above, we\nmight write,\n\n```\nerr := tmpl.Execute(os.Stdout, \"no data needed\")\nif err != nil {\n\tlog.Fatalf(\"execution failed: %s\", err)\n}\n\n```\nor to invoke a particular template explicitly by name,\n\n```\nerr := tmpl.ExecuteTemplate(os.Stdout, \"T2\", \"no data needed\")\nif err != nil {\n\tlog.Fatalf(\"execution failed: %s\", err)\n}\n\n[\"text/template\" on pkg.go.dev](https://pkg.go.dev/text/template)",
        "url": "https://pkg.go.dev/text/template",
        "path": "text/template",
        "children": [
          {
            "name": "parse",
            "synopsis": "Package parse builds parse trees for templates as defined by text/template\nand html/template. Clients should use those packages to construct templates\nrather than this one, which provides shared internal data structures not\nintended for general use.\n\n[\"text/template/parse\" on pkg.go.dev](https://pkg.go.dev/text/template/parse)",
            "url": "https://pkg.go.dev/text/template/parse",
            "path": "text/template/parse",
            "children": []
          }
        ]
      }
    ]
  },
  {
    "name": "time",
    "synopsis": "Package time provides functionality for measuring and displaying time.\n\nThe calendrical calculations always assume a Gregorian calendar, with\nno leap seconds.\n\nMonotonic Clocks\n\nOperating systems provide both a “wall clock,” which is subject to\nchanges for clock synchronization, and a “monotonic clock,” which is\nnot. The general rule is that the wall clock is for telling time and\nthe monotonic clock is for measuring time. Rather than split the API,\nin this package the Time returned by time.Now contains both a wall\nclock reading and a monotonic clock reading; later time-telling\noperations use the wall clock reading, but later time-measuring\noperations, specifically comparisons and subtractions, use the\nmonotonic clock reading.\n\nFor example, this code always computes a positive elapsed time of\napproximately 20 milliseconds, even if the wall clock is changed during\nthe operation being timed:\n\n```\nstart := time.Now()\n... operation that takes 20 milliseconds ...\nt := time.Now()\nelapsed := t.Sub(start)\n\n```\nOther idioms, such as time.Since(start), time.Until(deadline), and\ntime.Now().Before(deadline), are similarly robust against wall clock\nresets.\n\nThe rest of this section gives the precise details of how operations\nuse monotonic clocks, but understanding those details is not required\nto use this package.\n\nThe Time returned by time.Now contains a monotonic clock reading.\nIf Time t has a monotonic clock reading, t.Add adds the same duration to\nboth the wall clock and monotonic clock readings to compute the result.\nBecause t.AddDate(y, m, d), t.Round(d), and t.Truncate(d) are wall time\ncomputations, they always strip any monotonic clock reading from their results.\nBecause t.In, t.Local, and t.UTC are used for their effect on the interpretation\nof the wall time, they also strip any monotonic clock reading from their results.\nThe canonical way to strip a monotonic clock reading is to use t = t.Round(0).\n\nIf Times t and u both contain monotonic clock readings, the operations\nt.After(u), t.Before(u), t.Equal(u), and t.Sub(u) are carried out\nusing the monotonic clock readings alone, ignoring the wall clock\nreadings. If either t or u contains no monotonic clock reading, these\noperations fall back to using the wall clock readings.\n\nOn some systems the monotonic clock will stop if the computer goes to sleep.\nOn such a system, t.Sub(u) may not accurately reflect the actual\ntime that passed between t and u.\n\nBecause the monotonic clock reading has no meaning outside\nthe current process, the serialized forms generated by t.GobEncode,\nt.MarshalBinary, t.MarshalJSON, and t.MarshalText omit the monotonic\nclock reading, and t.Format provides no format for it. Similarly, the\nconstructors time.Date, time.Parse, time.ParseInLocation, and time.Unix,\nas well as the unmarshalers t.GobDecode, t.UnmarshalBinary.\nt.UnmarshalJSON, and t.UnmarshalText always create times with\nno monotonic clock reading.\n\nNote that the Go == operator compares not just the time instant but\nalso the Location and the monotonic clock reading. See the\ndocumentation for the Time type for a discussion of equality\ntesting for Time values.\n\nFor debugging, the result of t.String does include the monotonic\nclock reading if present. If t != u because of different monotonic clock readings,\nthat difference will be visible when printing t.String() and u.String().\n\n[\"time\" on pkg.go.dev](https://pkg.go.dev/time)",
    "url": "https://pkg.go.dev/time",
    "path": "time",
    "children": [
      {
        "name": "tzdata",
        "synopsis": "Package tzdata provides an embedded copy of the timezone database.\nIf this package is imported anywhere in the program, then if\nthe time package cannot find tzdata files on the system,\nit will use this embedded information.\n\nImporting this package will increase the size of a program by about\n450 KB.\n\nThis package should normally be imported by a program's main package,\nnot by a library. Libraries normally shouldn't decide whether to\ninclude the timezone database in a program.\n\nThis package will be automatically imported if you build with\n-tags timetzdata.\n\n[\"time/tzdata\" on pkg.go.dev](https://pkg.go.dev/time/tzdata)",
        "url": "https://pkg.go.dev/time/tzdata",
        "path": "time/tzdata",
        "children": []
      }
    ]
  },
  {
    "name": "unicode",
    "synopsis": "Package unicode provides data and functions to test some properties of\nUnicode code points.\n\n[\"unicode\" on pkg.go.dev](https://pkg.go.dev/unicode)",
    "url": "https://pkg.go.dev/unicode",
    "path": "unicode",
    "children": [
      {
        "name": "utf16",
        "synopsis": "Package utf16 implements encoding and decoding of UTF-16 sequences.\n\n[\"unicode/utf16\" on pkg.go.dev](https://pkg.go.dev/unicode/utf16)",
        "url": "https://pkg.go.dev/unicode/utf16",
        "path": "unicode/utf16",
        "children": []
      },
      {
        "name": "utf8",
        "synopsis": "Package utf8 implements functions and constants to support text encoded in\nUTF-8. It includes functions to translate between runes and UTF-8 byte sequences.\nSee https://en.wikipedia.org/wiki/UTF-8\n\n[\"unicode/utf8\" on pkg.go.dev](https://pkg.go.dev/unicode/utf8)",
        "url": "https://pkg.go.dev/unicode/utf8",
        "path": "unicode/utf8",
        "children": []
      }
    ]
  },
  {
    "name": "unsafe",
    "synopsis": "Package unsafe contains operations that step around the type safety of Go programs.\n\nPackages that import unsafe may be non-portable and are not protected by the\nGo 1 compatibility guidelines.\n\n[\"unsafe\" on pkg.go.dev](https://pkg.go.dev/unsafe)",
    "url": "https://pkg.go.dev/unsafe",
    "path": "unsafe",
    "children": []
  }
]
