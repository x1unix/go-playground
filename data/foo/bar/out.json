{
  "version": "1.22.4",
  "packages": [
    {
      "label": "hash",
      "documentation": {
        "value": "Package hash provides interfaces for hash functions.\n\n[hash on pkg.go.dev](https://pkg.go.dev/hash)",
        "isTrusted": true
      },
      "detail": "hash",
      "insertText": "hash",
      "kind": 8
    },
    {
      "label": "bufio",
      "documentation": {
        "value": "Package bufio implements buffered I/O. It wraps an io.Reader or io.Writer\nobject, creating another object (Reader or Writer) that also implements\nthe interface but provides buffering and some help for textual I/O.\n\n[bufio on pkg.go.dev](https://pkg.go.dev/bufio)",
        "isTrusted": true
      },
      "detail": "bufio",
      "insertText": "bufio",
      "kind": 8
    },
    {
      "label": "cmp",
      "documentation": {
        "value": "Package cmp provides types and functions related to comparing\nordered values.\n\n[cmp on pkg.go.dev](https://pkg.go.dev/cmp)",
        "isTrusted": true
      },
      "detail": "cmp",
      "insertText": "cmp",
      "kind": 8
    },
    {
      "label": "html",
      "documentation": {
        "value": "Package html provides functions for escaping and unescaping HTML text.\n\n[html on pkg.go.dev](https://pkg.go.dev/html)",
        "isTrusted": true
      },
      "detail": "html",
      "insertText": "html",
      "kind": 8
    },
    {
      "label": "archive/zip",
      "documentation": {
        "value": "Package zip provides support for reading and writing ZIP archives.\n\nSee the [ZIP specification] for details.\n\nThis package does not support disk spanning.\n\nA note about ZIP64:\n\nTo be backwards compatible the FileHeader has both 32 and 64 bit Size\nfields. The 64 bit fields will always contain the correct value and\nfor normal archives both fields will be the same. For files requiring\nthe ZIP64 format the 32 bit fields will be 0xffffffff and the 64 bit\nfields must be used instead.\n\n[ZIP specification]: https://support.pkware.com/pkzip/appnote\n\n[zip on pkg.go.dev](https://pkg.go.dev/archive/zip)",
        "isTrusted": true
      },
      "detail": "zip",
      "insertText": "archive/zip",
      "kind": 8
    },
    {
      "label": "context",
      "documentation": {
        "value": "Package context defines the Context type, which carries deadlines,\ncancellation signals, and other request-scoped values across API boundaries\nand between processes.\n\nIncoming requests to a server should create a [Context], and outgoing\ncalls to servers should accept a Context. The chain of function\ncalls between them must propagate the Context, optionally replacing\nit with a derived Context created using [WithCancel], [WithDeadline],\n[WithTimeout], or [WithValue]. When a Context is canceled, all\nContexts derived from it are also canceled.\n\nThe [WithCancel], [WithDeadline], and [WithTimeout] functions take a\nContext (the parent) and return a derived Context (the child) and a\n[CancelFunc]. Calling the CancelFunc cancels the child and its\nchildren, removes the parent's reference to the child, and stops\nany associated timers. Failing to call the CancelFunc leaks the\nchild and its children until the parent is canceled or the timer\nfires. The go vet tool checks that CancelFuncs are used on all\ncontrol-flow paths.\n\nThe [WithCancelCause] function returns a [CancelCauseFunc], which\ntakes an error and records it as the cancellation cause. Calling\n[Cause] on the canceled context or any of its children retrieves\nthe cause. If no cause is specified, Cause(ctx) returns the same\nvalue as ctx.Err().\n\nPrograms that use Contexts should follow these rules to keep interfaces\nconsistent across packages and enable static analysis tools to check context\npropagation:\n\nDo not store Contexts inside a struct type; instead, pass a Context\nexplicitly to each function that needs it. The Context should be the first\nparameter, typically named ctx:\n\n```\n\tfunc DoSomething(ctx context.Context, arg Arg) error {\n\t\t// ... use ctx ...\n\t}\n\n```\nDo not pass a nil [Context], even if a function permits it. Pass [context.TODO]\nif you are unsure about which Context to use.\n\nUse context Values only for request-scoped data that transits processes and\nAPIs, not for passing optional parameters to functions.\n\nThe same Context may be passed to functions running in different goroutines;\nContexts are safe for simultaneous use by multiple goroutines.\n\nSee https://blog.golang.org/context for example code for a server that uses\nContexts.\n\n[context on pkg.go.dev](https://pkg.go.dev/context)",
        "isTrusted": true
      },
      "detail": "context",
      "insertText": "context",
      "kind": 8
    },
    {
      "label": "crypto",
      "documentation": {
        "value": "Package crypto collects common cryptographic constants.\n\n[crypto on pkg.go.dev](https://pkg.go.dev/crypto)",
        "isTrusted": true
      },
      "detail": "crypto",
      "insertText": "crypto",
      "kind": 8
    },
    {
      "label": "bytes",
      "documentation": {
        "value": "Package bytes implements functions for the manipulation of byte slices.\nIt is analogous to the facilities of the [strings] package.\n\n[bytes on pkg.go.dev](https://pkg.go.dev/bytes)",
        "isTrusted": true
      },
      "detail": "bytes",
      "insertText": "bytes",
      "kind": 8
    },
    {
      "label": "archive/tar",
      "documentation": {
        "value": "Package tar implements access to tar archives.\n\nTape archives (tar) are a file format for storing a sequence of files that\ncan be read and written in a streaming manner.\nThis package aims to cover most variations of the format,\nincluding those produced by GNU and BSD tar tools.\n\n[tar on pkg.go.dev](https://pkg.go.dev/archive/tar)",
        "isTrusted": true
      },
      "detail": "tar",
      "insertText": "archive/tar",
      "kind": 8
    },
    {
      "label": "io",
      "documentation": {
        "value": "Package io provides basic interfaces to I/O primitives.\nIts primary job is to wrap existing implementations of such primitives,\nsuch as those in package os, into shared public interfaces that\nabstract the functionality, plus some other related primitives.\n\nBecause these interfaces and primitives wrap lower-level operations with\nvarious implementations, unless otherwise informed clients should not\nassume they are safe for parallel execution.\n\n[io on pkg.go.dev](https://pkg.go.dev/io)",
        "isTrusted": true
      },
      "detail": "io",
      "insertText": "io",
      "kind": 8
    },
    {
      "label": "iter",
      "documentation": {
        "value": "Package iter provides basic definitions and operations\nrelated to iteration in Go.\n\nThis package is experimental and can only be imported\nwhen building with GOEXPERIMENT=rangefunc.\n\n[iter on pkg.go.dev](https://pkg.go.dev/iter)",
        "isTrusted": true
      },
      "detail": "iter",
      "insertText": "iter",
      "kind": 8
    },
    {
      "label": "maps",
      "documentation": {
        "value": "Package maps defines various functions useful with maps of any type.\n\n[maps on pkg.go.dev](https://pkg.go.dev/maps)",
        "isTrusted": true
      },
      "detail": "maps",
      "insertText": "maps",
      "kind": 8
    },
    {
      "label": "log",
      "documentation": {
        "value": "Package log implements a simple logging package. It defines a type, [Logger],\nwith methods for formatting output. It also has a predefined 'standard'\nLogger accessible through helper functions Print[f|ln], Fatal[f|ln], and\nPanic[f|ln], which are easier to use than creating a Logger manually.\nThat logger writes to standard error and prints the date and time\nof each logged message.\nEvery log message is output on a separate line: if the message being\nprinted does not end in a newline, the logger will add one.\nThe Fatal functions call [os.Exit](1) after writing the log message.\nThe Panic functions call panic after writing the log message.\n\n[log on pkg.go.dev](https://pkg.go.dev/log)",
        "isTrusted": true
      },
      "detail": "log",
      "insertText": "log",
      "kind": 8
    },
    {
      "label": "image",
      "documentation": {
        "value": "Package image implements a basic 2-D image library.\n\nThe fundamental interface is called [Image]. An [Image] contains colors, which\nare described in the image/color package.\n\nValues of the [Image] interface are created either by calling functions such\nas [NewRGBA] and [NewPaletted], or by calling [Decode] on an [io.Reader] containing\nimage data in a format such as GIF, JPEG or PNG. Decoding any particular\nimage format requires the prior registration of a decoder function.\nRegistration is typically automatic as a side effect of initializing that\nformat's package so that, to decode a PNG image, it suffices to have\n\n```\n\timport _ \"image/png\"\n\n```\nin a program's main package. The _ means to import a package purely for its\ninitialization side effects.\n\nSee \"The Go image package\" for more details:\nhttps://golang.org/doc/articles/image_package.html\n\n# Security Considerations\n\nThe image package can be used to parse arbitrarily large images, which can\ncause resource exhaustion on machines which do not have enough memory to\nstore them. When operating on arbitrary images, [DecodeConfig] should be called\nbefore [Decode], so that the program can decide whether the image, as defined\nin the returned header, can be safely decoded with the available resources. A\ncall to [Decode] which produces an extremely large image, as defined in the\nheader returned by [DecodeConfig], is not considered a security issue,\nregardless of whether the image is itself malformed or not. A call to\n[DecodeConfig] which returns a header which does not match the image returned\nby [Decode] may be considered a security issue, and should be reported per the\n[Go Security Policy](https://go.dev/security/policy).\n\n[image on pkg.go.dev](https://pkg.go.dev/image)",
        "isTrusted": true
      },
      "detail": "image",
      "insertText": "image",
      "kind": 8
    },
    {
      "label": "math",
      "documentation": {
        "value": "Package math provides basic constants and mathematical functions.\n\nThis package does not guarantee bit-identical results across architectures.\n\n[math on pkg.go.dev](https://pkg.go.dev/math)",
        "isTrusted": true
      },
      "detail": "math",
      "insertText": "math",
      "kind": 8
    },
    {
      "label": "mime",
      "documentation": {
        "value": "Package mime implements parts of the MIME spec.\n\n[mime on pkg.go.dev](https://pkg.go.dev/mime)",
        "isTrusted": true
      },
      "detail": "mime",
      "insertText": "mime",
      "kind": 8
    },
    {
      "label": "regexp",
      "documentation": {
        "value": "Package regexp implements regular expression search.\n\nThe syntax of the regular expressions accepted is the same\ngeneral syntax used by Perl, Python, and other languages.\nMore precisely, it is the syntax accepted by RE2 and described at\nhttps://golang.org/s/re2syntax, except for \\C.\nFor an overview of the syntax, see the [regexp/syntax] package.\n\nThe regexp implementation provided by this package is\nguaranteed to run in time linear in the size of the input.\n(This is a property not guaranteed by most open source\nimplementations of regular expressions.) For more information\nabout this property, see\n\n```\n\thttps://swtch.com/~rsc/regexp/regexp1.html\n\n```\nor any book about automata theory.\n\nAll characters are UTF-8-encoded code points.\nFollowing [utf8.DecodeRune], each byte of an invalid UTF-8 sequence\nis treated as if it encoded utf8.RuneError (U+FFFD).\n\nThere are 16 methods of [Regexp] that match a regular expression and identify\nthe matched text. Their names are matched by this regular expression:\n\n```\n\tFind(All)?(String)?(Submatch)?(Index)?\n\n```\nIf 'All' is present, the routine matches successive non-overlapping\nmatches of the entire expression. Empty matches abutting a preceding\nmatch are ignored. The return value is a slice containing the successive\nreturn values of the corresponding non-'All' routine. These routines take\nan extra integer argument, n. If n \u003e= 0, the function returns at most n\nmatches/submatches; otherwise, it returns all of them.\n\nIf 'String' is present, the argument is a string; otherwise it is a slice\nof bytes; return values are adjusted as appropriate.\n\nIf 'Submatch' is present, the return value is a slice identifying the\nsuccessive submatches of the expression. Submatches are matches of\nparenthesized subexpressions (also known as capturing groups) within the\nregular expression, numbered from left to right in order of opening\nparenthesis. Submatch 0 is the match of the entire expression, submatch 1 is\nthe match of the first parenthesized subexpression, and so on.\n\nIf 'Index' is present, matches and submatches are identified by byte index\npairs within the input string: result[2*n:2*n+2] identifies the indexes of\nthe nth submatch. The pair for n==0 identifies the match of the entire\nexpression. If 'Index' is not present, the match is identified by the text\nof the match/submatch. If an index is negative or text is nil, it means that\nsubexpression did not match any string in the input. For 'String' versions\nan empty string means either no match or an empty match.\n\nThere is also a subset of the methods that can be applied to text read\nfrom a RuneReader:\n\n```\n\tMatchReader, FindReaderIndex, FindReaderSubmatchIndex\n\n```\nThis set may grow. Note that regular expression matches may need to\nexamine text beyond the text returned by a match, so the methods that\nmatch text from a RuneReader may read arbitrarily far into the input\nbefore returning.\n\n(There are a few other methods that do not match this pattern.)\n\n[regexp on pkg.go.dev](https://pkg.go.dev/regexp)",
        "isTrusted": true
      },
      "detail": "regexp",
      "insertText": "regexp",
      "kind": 8
    },
    {
      "label": "plugin",
      "documentation": {
        "value": "Package plugin implements loading and symbol resolution of Go plugins.\n\nA plugin is a Go main package with exported functions and variables that\nhas been built with:\n\n```\n\tgo build -buildmode=plugin\n\n```\nWhen a plugin is first opened, the init functions of all packages not\nalready part of the program are called. The main function is not run.\nA plugin is only initialized once, and cannot be closed.\n\n# Warnings\n\nThe ability to dynamically load parts of an application during\nexecution, perhaps based on user-defined configuration, may be a\nuseful building block in some designs. In particular, because\napplications and dynamically loaded functions can share data\nstructures directly, plugins may enable very high-performance\nintegration of separate parts.\n\nHowever, the plugin mechanism has many significant drawbacks that\nshould be considered carefully during the design. For example:\n\n```\n  - Plugins are currently supported only on Linux, FreeBSD, and\n    macOS, making them unsuitable for applications intended to be\n    portable.\n\n  - Applications that use plugins may require careful configuration\n    to ensure that the various parts of the program be made available\n    in the correct location in the file system (or container image).\n    By contrast, deploying an application consisting of a single static\n    executable is straightforward.\n\n  - Reasoning about program initialization is more difficult when\n    some packages may not be initialized until long after the\n    application has started running.\n\n  - Bugs in applications that load plugins could be exploited by\n    an attacker to load dangerous or untrusted libraries.\n\n  - Runtime crashes are likely to occur unless all parts of the\n    program (the application and all its plugins) are compiled\n    using exactly the same version of the toolchain, the same build\n    tags, and the same values of certain flags and environment\n    variables.\n\n  - Similar crashing problems are likely to arise unless all common\n    dependencies of the application and its plugins are built from\n    exactly the same source code.\n\n  - Together, these restrictions mean that, in practice, the\n    application and its plugins must all be built together by a\n    single person or component of a system. In that case, it may\n    be simpler for that person or component to generate Go source\n    files that blank-import the desired set of plugins and then\n    compile a static executable in the usual way.\n\n```\nFor these reasons, many users decide that traditional interprocess\ncommunication (IPC) mechanisms such as sockets, pipes, remote\nprocedure call (RPC), shared memory mappings, or file system\noperations may be more suitable despite the performance overheads.\n\n[plugin on pkg.go.dev](https://pkg.go.dev/plugin)",
        "isTrusted": true
      },
      "detail": "plugin",
      "insertText": "plugin",
      "kind": 8
    },
    {
      "label": "path",
      "documentation": {
        "value": "Package path implements utility routines for manipulating slash-separated\npaths.\n\nThe path package should only be used for paths separated by forward\nslashes, such as the paths in URLs. This package does not deal with\nWindows paths with drive letters or backslashes; to manipulate\noperating system paths, use the [path/filepath] package.\n\n[path on pkg.go.dev](https://pkg.go.dev/path)",
        "isTrusted": true
      },
      "detail": "path",
      "insertText": "path",
      "kind": 8
    },
    {
      "label": "fmt",
      "documentation": {
        "value": "Package fmt implements formatted I/O with functions analogous\nto C's printf and scanf.  The format 'verbs' are derived from C's but\nare simpler.\n\n# Printing\n\nThe verbs:\n\nGeneral:\n\n```\n\t%v\tthe value in a default format\n\t\twhen printing structs, the plus flag (%+v) adds field names\n\t%#v\ta Go-syntax representation of the value\n\t%T\ta Go-syntax representation of the type of the value\n\t%%\ta literal percent sign; consumes no value\n\n```\nBoolean:\n\n```\n\t%t\tthe word true or false\n\n```\nInteger:\n\n```\n\t%b\tbase 2\n\t%c\tthe character represented by the corresponding Unicode code point\n\t%d\tbase 10\n\t%o\tbase 8\n\t%O\tbase 8 with 0o prefix\n\t%q\ta single-quoted character literal safely escaped with Go syntax.\n\t%x\tbase 16, with lower-case letters for a-f\n\t%X\tbase 16, with upper-case letters for A-F\n\t%U\tUnicode format: U+1234; same as \"U+%04X\"\n\n```\nFloating-point and complex constituents:\n\n```\n\t%b\tdecimalless scientific notation with exponent a power of two,\n\t\tin the manner of strconv.FormatFloat with the 'b' format,\n\t\te.g. -123456p-78\n\t%e\tscientific notation, e.g. -1.234456e+78\n\t%E\tscientific notation, e.g. -1.234456E+78\n\t%f\tdecimal point but no exponent, e.g. 123.456\n\t%F\tsynonym for %f\n\t%g\t%e for large exponents, %f otherwise. Precision is discussed below.\n\t%G\t%E for large exponents, %F otherwise\n\t%x\thexadecimal notation (with decimal power of two exponent), e.g. -0x1.23abcp+20\n\t%X\tupper-case hexadecimal notation, e.g. -0X1.23ABCP+20\n\n```\nString and slice of bytes (treated equivalently with these verbs):\n\n```\n\t%s\tthe uninterpreted bytes of the string or slice\n\t%q\ta double-quoted string safely escaped with Go syntax\n\t%x\tbase 16, lower-case, two characters per byte\n\t%X\tbase 16, upper-case, two characters per byte\n\n```\nSlice:\n\n```\n\t%p\taddress of 0th element in base 16 notation, with leading 0x\n\n```\nPointer:\n\n```\n\t%p\tbase 16 notation, with leading 0x\n\tThe %b, %d, %o, %x and %X verbs also work with pointers,\n\tformatting the value exactly as if it were an integer.\n\n```\nThe default format for %v is:\n\n```\n\tbool:                    %t\n\tint, int8 etc.:          %d\n\tuint, uint8 etc.:        %d, %#x if printed with %#v\n\tfloat32, complex64, etc: %g\n\tstring:                  %s\n\tchan:                    %p\n\tpointer:                 %p\n\n```\nFor compound objects, the elements are printed using these rules, recursively,\nlaid out like this:\n\n```\n\tstruct:             {field0 field1 ...}\n\tarray, slice:       [elem0 elem1 ...]\n\tmaps:               map[key1:value1 key2:value2 ...]\n\tpointer to above:   \u0026{}, \u0026[], \u0026map[]\n\n```\nWidth is specified by an optional decimal number immediately preceding the verb.\nIf absent, the width is whatever is necessary to represent the value.\nPrecision is specified after the (optional) width by a period followed by a\ndecimal number. If no period is present, a default precision is used.\nA period with no following number specifies a precision of zero.\nExamples:\n\n```\n\t%f     default width, default precision\n\t%9f    width 9, default precision\n\t%.2f   default width, precision 2\n\t%9.2f  width 9, precision 2\n\t%9.f   width 9, precision 0\n\n```\nWidth and precision are measured in units of Unicode code points,\nthat is, runes. (This differs from C's printf where the\nunits are always measured in bytes.) Either or both of the flags\nmay be replaced with the character '*', causing their values to be\nobtained from the next operand (preceding the one to format),\nwhich must be of type int.\n\nFor most values, width is the minimum number of runes to output,\npadding the formatted form with spaces if necessary.\n\nFor strings, byte slices and byte arrays, however, precision\nlimits the length of the input to be formatted (not the size of\nthe output), truncating if necessary. Normally it is measured in\nrunes, but for these types when formatted with the %x or %X format\nit is measured in bytes.\n\nFor floating-point values, width sets the minimum width of the field and\nprecision sets the number of places after the decimal, if appropriate,\nexcept that for %g/%G precision sets the maximum number of significant\ndigits (trailing zeros are removed). For example, given 12.345 the format\n%6.3f prints 12.345 while %.3g prints 12.3. The default precision for %e, %f\nand %#g is 6; for %g it is the smallest number of digits necessary to identify\nthe value uniquely.\n\nFor complex numbers, the width and precision apply to the two\ncomponents independently and the result is parenthesized, so %f applied\nto 1.2+3.4i produces (1.200000+3.400000i).\n\nWhen formatting a single integer code point or a rune string (type []rune)\nwith %q, invalid Unicode code points are changed to the Unicode replacement\ncharacter, U+FFFD, as in strconv.QuoteRune.\n\nOther flags:\n\n```\n\t'+'\talways print a sign for numeric values;\n\t\tguarantee ASCII-only output for %q (%+q)\n\t'-'\tpad with spaces on the right rather than the left (left-justify the field)\n\t'#'\talternate format: add leading 0b for binary (%#b), 0 for octal (%#o),\n\t\t0x or 0X for hex (%#x or %#X); suppress 0x for %p (%#p);\n\t\tfor %q, print a raw (backquoted) string if strconv.CanBackquote\n\t\treturns true;\n\t\talways print a decimal point for %e, %E, %f, %F, %g and %G;\n\t\tdo not remove trailing zeros for %g and %G;\n\t\twrite e.g. U+0078 'x' if the character is printable for %U (%#U).\n\t' '\t(space) leave a space for elided sign in numbers (% d);\n\t\tput spaces between bytes printing strings or slices in hex (% x, % X)\n\t'0'\tpad with leading zeros rather than spaces;\n\t\tfor numbers, this moves the padding after the sign;\n\t\tignored for strings, byte slices and byte arrays\n\n```\nFlags are ignored by verbs that do not expect them.\nFor example there is no alternate decimal format, so %#d and %d\nbehave identically.\n\nFor each Printf-like function, there is also a Print function\nthat takes no format and is equivalent to saying %v for every\noperand.  Another variant Println inserts blanks between\noperands and appends a newline.\n\nRegardless of the verb, if an operand is an interface value,\nthe internal concrete value is used, not the interface itself.\nThus:\n\n```\n\tvar i interface{} = 23\n\tfmt.Printf(\"%v\\n\", i)\n\n```\nwill print 23.\n\nExcept when printed using the verbs %T and %p, special\nformatting considerations apply for operands that implement\ncertain interfaces. In order of application:\n\n1. If the operand is a reflect.Value, the operand is replaced by the\nconcrete value that it holds, and printing continues with the next rule.\n\n2. If an operand implements the Formatter interface, it will\nbe invoked. In this case the interpretation of verbs and flags is\ncontrolled by that implementation.\n\n3. If the %v verb is used with the # flag (%#v) and the operand\nimplements the GoStringer interface, that will be invoked.\n\nIf the format (which is implicitly %v for Println etc.) is valid\nfor a string (%s %q %x %X), or is %v but not %#v,\nthe following two rules apply:\n\n4. If an operand implements the error interface, the Error method\nwill be invoked to convert the object to a string, which will then\nbe formatted as required by the verb (if any).\n\n5. If an operand implements method String() string, that method\nwill be invoked to convert the object to a string, which will then\nbe formatted as required by the verb (if any).\n\nFor compound operands such as slices and structs, the format\napplies to the elements of each operand, recursively, not to the\noperand as a whole. Thus %q will quote each element of a slice\nof strings, and %6.2f will control formatting for each element\nof a floating-point array.\n\nHowever, when printing a byte slice with a string-like verb\n(%s %q %x %X), it is treated identically to a string, as a single item.\n\nTo avoid recursion in cases such as\n\n```\n\ttype X string\n\tfunc (x X) String() string { return Sprintf(\"\u003c%s\u003e\", x) }\n\n```\nconvert the value before recurring:\n\n```\n\tfunc (x X) String() string { return Sprintf(\"\u003c%s\u003e\", string(x)) }\n\n```\nInfinite recursion can also be triggered by self-referential data\nstructures, such as a slice that contains itself as an element, if\nthat type has a String method. Such pathologies are rare, however,\nand the package does not protect against them.\n\nWhen printing a struct, fmt cannot and therefore does not invoke\nformatting methods such as Error or String on unexported fields.\n\n# Explicit argument indexes\n\nIn Printf, Sprintf, and Fprintf, the default behavior is for each\nformatting verb to format successive arguments passed in the call.\nHowever, the notation [n] immediately before the verb indicates that the\nnth one-indexed argument is to be formatted instead. The same notation\nbefore a '*' for a width or precision selects the argument index holding\nthe value. After processing a bracketed expression [n], subsequent verbs\nwill use arguments n+1, n+2, etc. unless otherwise directed.\n\nFor example,\n\n```\n\tfmt.Sprintf(\"%[2]d %[1]d\\n\", 11, 22)\n\n```\nwill yield \"22 11\", while\n\n```\n\tfmt.Sprintf(\"%[3]*.[2]*[1]f\", 12.0, 2, 6)\n\n```\nequivalent to\n\n```\n\tfmt.Sprintf(\"%6.2f\", 12.0)\n\n```\nwill yield \" 12.00\". Because an explicit index affects subsequent verbs,\nthis notation can be used to print the same values multiple times\nby resetting the index for the first argument to be repeated:\n\n```\n\tfmt.Sprintf(\"%d %d %#[1]x %#x\", 16, 17)\n\n```\nwill yield \"16 17 0x10 0x11\".\n\n# Format errors\n\nIf an invalid argument is given for a verb, such as providing\na string to %d, the generated string will contain a\ndescription of the problem, as in these examples:\n\n```\n\tWrong type or unknown verb: %!verb(type=value)\n\t\tPrintf(\"%d\", \"hi\"):        %!d(string=hi)\n\tToo many arguments: %!(EXTRA type=value)\n\t\tPrintf(\"hi\", \"guys\"):      hi%!(EXTRA string=guys)\n\tToo few arguments: %!verb(MISSING)\n\t\tPrintf(\"hi%d\"):            hi%!d(MISSING)\n\tNon-int for width or precision: %!(BADWIDTH) or %!(BADPREC)\n\t\tPrintf(\"%*s\", 4.5, \"hi\"):  %!(BADWIDTH)hi\n\t\tPrintf(\"%.*s\", 4.5, \"hi\"): %!(BADPREC)hi\n\tInvalid or invalid use of argument index: %!(BADINDEX)\n\t\tPrintf(\"%*[2]d\", 7):       %!d(BADINDEX)\n\t\tPrintf(\"%.[2]d\", 7):       %!d(BADINDEX)\n\n```\nAll errors begin with the string \"%!\" followed sometimes\nby a single character (the verb) and end with a parenthesized\ndescription.\n\nIf an Error or String method triggers a panic when called by a\nprint routine, the fmt package reformats the error message\nfrom the panic, decorating it with an indication that it came\nthrough the fmt package.  For example, if a String method\ncalls panic(\"bad\"), the resulting formatted message will look\nlike\n\n```\n\t%!s(PANIC=bad)\n\n```\nThe %!s just shows the print verb in use when the failure\noccurred. If the panic is caused by a nil receiver to an Error\nor String method, however, the output is the undecorated\nstring, \"\u003cnil\u003e\".\n\n# Scanning\n\nAn analogous set of functions scans formatted text to yield\nvalues.  Scan, Scanf and Scanln read from os.Stdin; Fscan,\nFscanf and Fscanln read from a specified io.Reader; Sscan,\nSscanf and Sscanln read from an argument string.\n\nScan, Fscan, Sscan treat newlines in the input as spaces.\n\nScanln, Fscanln and Sscanln stop scanning at a newline and\nrequire that the items be followed by a newline or EOF.\n\nScanf, Fscanf, and Sscanf parse the arguments according to a\nformat string, analogous to that of Printf. In the text that\nfollows, 'space' means any Unicode whitespace character\nexcept newline.\n\nIn the format string, a verb introduced by the % character\nconsumes and parses input; these verbs are described in more\ndetail below. A character other than %, space, or newline in\nthe format consumes exactly that input character, which must\nbe present. A newline with zero or more spaces before it in\nthe format string consumes zero or more spaces in the input\nfollowed by a single newline or the end of the input. A space\nfollowing a newline in the format string consumes zero or more\nspaces in the input. Otherwise, any run of one or more spaces\nin the format string consumes as many spaces as possible in\nthe input. Unless the run of spaces in the format string\nappears adjacent to a newline, the run must consume at least\none space from the input or find the end of the input.\n\nThe handling of spaces and newlines differs from that of C's\nscanf family: in C, newlines are treated as any other space,\nand it is never an error when a run of spaces in the format\nstring finds no spaces to consume in the input.\n\nThe verbs behave analogously to those of Printf.\nFor example, %x will scan an integer as a hexadecimal number,\nand %v will scan the default representation format for the value.\nThe Printf verbs %p and %T and the flags # and + are not implemented.\nFor floating-point and complex values, all valid formatting verbs\n(%b %e %E %f %F %g %G %x %X and %v) are equivalent and accept\nboth decimal and hexadecimal notation (for example: \"2.3e+7\", \"0x4.5p-8\")\nand digit-separating underscores (for example: \"3.14159_26535_89793\").\n\nInput processed by verbs is implicitly space-delimited: the\nimplementation of every verb except %c starts by discarding\nleading spaces from the remaining input, and the %s verb\n(and %v reading into a string) stops consuming input at the first\nspace or newline character.\n\nThe familiar base-setting prefixes 0b (binary), 0o and 0 (octal),\nand 0x (hexadecimal) are accepted when scanning integers\nwithout a format or with the %v verb, as are digit-separating\nunderscores.\n\nWidth is interpreted in the input text but there is no\nsyntax for scanning with a precision (no %5.2f, just %5f).\nIf width is provided, it applies after leading spaces are\ntrimmed and specifies the maximum number of runes to read\nto satisfy the verb. For example,\n\n```\n\tSscanf(\" 1234567 \", \"%5s%d\", \u0026s, \u0026i)\n\n```\nwill set s to \"12345\" and i to 67 while\n\n```\n\tSscanf(\" 12 34 567 \", \"%5s%d\", \u0026s, \u0026i)\n\n```\nwill set s to \"12\" and i to 34.\n\nIn all the scanning functions, a carriage return followed\nimmediately by a newline is treated as a plain newline\n(\\r\\n means the same as \\n).\n\nIn all the scanning functions, if an operand implements method\nScan (that is, it implements the Scanner interface) that\nmethod will be used to scan the text for that operand.  Also,\nif the number of arguments scanned is less than the number of\narguments provided, an error is returned.\n\nAll arguments to be scanned must be either pointers to basic\ntypes or implementations of the Scanner interface.\n\nLike Scanf and Fscanf, Sscanf need not consume its entire input.\nThere is no way to recover how much of the input string Sscanf used.\n\nNote: Fscan etc. can read one character (rune) past the input\nthey return, which means that a loop calling a scan routine\nmay skip some of the input.  This is usually a problem only\nwhen there is no space between input values.  If the reader\nprovided to Fscan implements ReadRune, that method will be used\nto read characters.  If the reader also implements UnreadRune,\nthat method will be used to save the character and successive\ncalls will not lose data.  To attach ReadRune and UnreadRune\nmethods to a reader without that capability, use\nbufio.NewReader.\n\n[fmt on pkg.go.dev](https://pkg.go.dev/fmt)",
        "isTrusted": true
      },
      "detail": "fmt",
      "insertText": "fmt",
      "kind": 8
    },
    {
      "label": "embed",
      "documentation": {
        "value": "Package embed provides access to files embedded in the running Go program.\n\nGo source files that import \"embed\" can use the //go:embed directive\nto initialize a variable of type string, []byte, or [FS] with the contents of\nfiles read from the package directory or subdirectories at compile time.\n\nFor example, here are three ways to embed a file named hello.txt\nand then print its contents at run time.\n\nEmbedding one file into a string:\n\n```\n\timport _ \"embed\"\n\n\t//go:embed hello.txt\n\tvar s string\n\tprint(s)\n\n```\nEmbedding one file into a slice of bytes:\n\n```\n\timport _ \"embed\"\n\n\t//go:embed hello.txt\n\tvar b []byte\n\tprint(string(b))\n\n```\nEmbedded one or more files into a file system:\n\n```\n\timport \"embed\"\n\n\t//go:embed hello.txt\n\tvar f embed.FS\n\tdata, _ := f.ReadFile(\"hello.txt\")\n\tprint(string(data))\n\n```\n# Directives\n\nA //go:embed directive above a variable declaration specifies which files to embed,\nusing one or more path.Match patterns.\n\nThe directive must immediately precede a line containing the declaration of a single variable.\nOnly blank lines and ‘//’ line comments are permitted between the directive and the declaration.\n\nThe type of the variable must be a string type, or a slice of a byte type,\nor [FS] (or an alias of [FS]).\n\nFor example:\n\n```\n\tpackage server\n\n\timport \"embed\"\n\n\t// content holds our static web server content.\n\t//go:embed image/* template/*\n\t//go:embed html/index.html\n\tvar content embed.FS\n\n```\nThe Go build system will recognize the directives and arrange for the declared variable\n(in the example above, content) to be populated with the matching files from the file system.\n\nThe //go:embed directive accepts multiple space-separated patterns for\nbrevity, but it can also be repeated, to avoid very long lines when there are\nmany patterns. The patterns are interpreted relative to the package directory\ncontaining the source file. The path separator is a forward slash, even on\nWindows systems. Patterns may not contain ‘.’ or ‘..’ or empty path elements,\nnor may they begin or end with a slash. To match everything in the current\ndirectory, use ‘*’ instead of ‘.’. To allow for naming files with spaces in\ntheir names, patterns can be written as Go double-quoted or back-quoted\nstring literals.\n\nIf a pattern names a directory, all files in the subtree rooted at that directory are\nembedded (recursively), except that files with names beginning with ‘.’ or ‘_’\nare excluded. So the variable in the above example is almost equivalent to:\n\n```\n\t// content is our static web server content.\n\t//go:embed image template html/index.html\n\tvar content embed.FS\n\n```\nThe difference is that ‘image/*’ embeds ‘image/.tempfile’ while ‘image’ does not.\nNeither embeds ‘image/dir/.tempfile’.\n\nIf a pattern begins with the prefix ‘all:’, then the rule for walking directories is changed\nto include those files beginning with ‘.’ or ‘_’. For example, ‘all:image’ embeds\nboth ‘image/.tempfile’ and ‘image/dir/.tempfile’.\n\nThe //go:embed directive can be used with both exported and unexported variables,\ndepending on whether the package wants to make the data available to other packages.\nIt can only be used with variables at package scope, not with local variables.\n\nPatterns must not match files outside the package's module, such as ‘.git/*’ or symbolic links.\nPatterns must not match files whose names include the special punctuation characters  \" * \u003c \u003e ? ` ' | / \\ and :.\nMatches for empty directories are ignored. After that, each pattern in a //go:embed line\nmust match at least one file or non-empty directory.\n\nIf any patterns are invalid or have invalid matches, the build will fail.\n\n# Strings and Bytes\n\nThe //go:embed line for a variable of type string or []byte can have only a single pattern,\nand that pattern can match only a single file. The string or []byte is initialized with\nthe contents of that file.\n\nThe //go:embed directive requires importing \"embed\", even when using a string or []byte.\nIn source files that don't refer to [embed.FS], use a blank import (import _ \"embed\").\n\n# File Systems\n\nFor embedding a single file, a variable of type string or []byte is often best.\nThe [FS] type enables embedding a tree of files, such as a directory of static\nweb server content, as in the example above.\n\nFS implements the [io/fs] package's [FS] interface, so it can be used with any package that\nunderstands file systems, including [net/http], [text/template], and [html/template].\n\nFor example, given the content variable in the example above, we can write:\n\n```\n\thttp.Handle(\"/static/\", http.StripPrefix(\"/static/\", http.FileServer(http.FS(content))))\n\n\ttemplate.ParseFS(content, \"*.tmpl\")\n\n```\n# Tools\n\nTo support tools that analyze Go packages, the patterns found in //go:embed lines\nare available in “go list” output. See the EmbedPatterns, TestEmbedPatterns,\nand XTestEmbedPatterns fields in the “go help list” output.\n\n[embed on pkg.go.dev](https://pkg.go.dev/embed)",
        "isTrusted": true
      },
      "detail": "embed",
      "insertText": "embed",
      "kind": 8
    },
    {
      "label": "encoding",
      "documentation": {
        "value": "Package encoding defines interfaces shared by other packages that\nconvert data to and from byte-level and textual representations.\nPackages that check for these interfaces include encoding/gob,\nencoding/json, and encoding/xml. As a result, implementing an\ninterface once can make a type useful in multiple encodings.\nStandard types that implement these interfaces include time.Time and net.IP.\nThe interfaces come in pairs that produce and consume encoded data.\n\nAdding encoding/decoding methods to existing types may constitute a breaking change,\nas they can be used for serialization in communicating with programs\nwritten with different library versions.\nThe policy for packages maintained by the Go project is to only allow\nthe addition of marshaling functions if no existing, reasonable marshaling exists.\n\n[encoding on pkg.go.dev](https://pkg.go.dev/encoding)",
        "isTrusted": true
      },
      "detail": "encoding",
      "insertText": "encoding",
      "kind": 8
    },
    {
      "label": "errors",
      "documentation": {
        "value": "Package errors implements functions to manipulate errors.\n\nThe [New] function creates errors whose only content is a text message.\n\nAn error e wraps another error if e's type has one of the methods\n\n```\n\tUnwrap() error\n\tUnwrap() []error\n\n```\nIf e.Unwrap() returns a non-nil error w or a slice containing w,\nthen we say that e wraps w. A nil error returned from e.Unwrap()\nindicates that e does not wrap any error. It is invalid for an\nUnwrap method to return an []error containing a nil error value.\n\nAn easy way to create wrapped errors is to call [fmt.Errorf] and apply\nthe %w verb to the error argument:\n\n```\n\twrapsErr := fmt.Errorf(\"... %w ...\", ..., err, ...)\n\n```\nSuccessive unwrapping of an error creates a tree. The [Is] and [As]\nfunctions inspect an error's tree by examining first the error\nitself followed by the tree of each of its children in turn\n(pre-order, depth-first traversal).\n\n[Is] examines the tree of its first argument looking for an error that\nmatches the second. It reports whether it finds a match. It should be\nused in preference to simple equality checks:\n\n```\n\tif errors.Is(err, fs.ErrExist)\n\n```\nis preferable to\n\n```\n\tif err == fs.ErrExist\n\n```\nbecause the former will succeed if err wraps [io/fs.ErrExist].\n\n[As] examines the tree of its first argument looking for an error that can be\nassigned to its second argument, which must be a pointer. If it succeeds, it\nperforms the assignment and returns true. Otherwise, it returns false. The form\n\n```\n\tvar perr *fs.PathError\n\tif errors.As(err, \u0026perr) {\n\t\tfmt.Println(perr.Path)\n\t}\n\n```\nis preferable to\n\n```\n\tif perr, ok := err.(*fs.PathError); ok {\n\t\tfmt.Println(perr.Path)\n\t}\n\n```\nbecause the former will succeed if err wraps an [*io/fs.PathError].\n\n[errors on pkg.go.dev](https://pkg.go.dev/errors)",
        "isTrusted": true
      },
      "detail": "errors",
      "insertText": "errors",
      "kind": 8
    },
    {
      "label": "expvar",
      "documentation": {
        "value": "Package expvar provides a standardized interface to public variables, such\nas operation counters in servers. It exposes these variables via HTTP at\n/debug/vars in JSON format.\n\nOperations to set or modify these public variables are atomic.\n\nIn addition to adding the HTTP handler, this package registers the\nfollowing variables:\n\n```\n\tcmdline   os.Args\n\tmemstats  runtime.Memstats\n\n```\nThe package is sometimes only imported for the side effect of\nregistering its HTTP handler and the above variables. To use it\nthis way, link this package into your program:\n\n```\n\timport _ \"expvar\"\n\n```\n\n[expvar on pkg.go.dev](https://pkg.go.dev/expvar)",
        "isTrusted": true
      },
      "detail": "expvar",
      "insertText": "expvar",
      "kind": 8
    },
    {
      "label": "flag",
      "documentation": {
        "value": "Package flag implements command-line flag parsing.\n\n# Usage\n\nDefine flags using [flag.String], [Bool], [Int], etc.\n\nThis declares an integer flag, -n, stored in the pointer nFlag, with type *int:\n\n```\n\timport \"flag\"\n\tvar nFlag = flag.Int(\"n\", 1234, \"help message for flag n\")\n\n```\nIf you like, you can bind the flag to a variable using the Var() functions.\n\n```\n\tvar flagvar int\n\tfunc init() {\n\t\tflag.IntVar(\u0026flagvar, \"flagname\", 1234, \"help message for flagname\")\n\t}\n\n```\nOr you can create custom flags that satisfy the Value interface (with\npointer receivers) and couple them to flag parsing by\n\n```\n\tflag.Var(\u0026flagVal, \"name\", \"help message for flagname\")\n\n```\nFor such flags, the default value is just the initial value of the variable.\n\nAfter all flags are defined, call\n\n```\n\tflag.Parse()\n\n```\nto parse the command line into the defined flags.\n\nFlags may then be used directly. If you're using the flags themselves,\nthey are all pointers; if you bind to variables, they're values.\n\n```\n\tfmt.Println(\"ip has value \", *ip)\n\tfmt.Println(\"flagvar has value \", flagvar)\n\n```\nAfter parsing, the arguments following the flags are available as the\nslice [flag.Args] or individually as [flag.Arg](i).\nThe arguments are indexed from 0 through [flag.NArg]-1.\n\n# Command line flag syntax\n\nThe following forms are permitted:\n\n```\n\t-flag\n\t--flag   // double dashes are also permitted\n\t-flag=x\n\t-flag x  // non-boolean flags only\n\n```\nOne or two dashes may be used; they are equivalent.\nThe last form is not permitted for boolean flags because the\nmeaning of the command\n\n```\n\tcmd -x *\n\n```\nwhere * is a Unix shell wildcard, will change if there is a file\ncalled 0, false, etc. You must use the -flag=false form to turn\noff a boolean flag.\n\nFlag parsing stops just before the first non-flag argument\n(\"-\" is a non-flag argument) or after the terminator \"--\".\n\nInteger flags accept 1234, 0664, 0x1234 and may be negative.\nBoolean flags may be:\n\n```\n\t1, 0, t, f, T, F, true, false, TRUE, FALSE, True, False\n\n```\nDuration flags accept any input valid for time.ParseDuration.\n\nThe default set of command-line flags is controlled by\ntop-level functions.  The [FlagSet] type allows one to define\nindependent sets of flags, such as to implement subcommands\nin a command-line interface. The methods of [FlagSet] are\nanalogous to the top-level functions for the command-line\nflag set.\n\n[flag on pkg.go.dev](https://pkg.go.dev/flag)",
        "isTrusted": true
      },
      "detail": "flag",
      "insertText": "flag",
      "kind": 8
    },
    {
      "label": "hash/crc32",
      "documentation": {
        "value": "Package crc32 implements the 32-bit cyclic redundancy check, or CRC-32,\nchecksum. See https://en.wikipedia.org/wiki/Cyclic_redundancy_check for\ninformation.\n\nPolynomials are represented in LSB-first form also known as reversed representation.\n\nSee https://en.wikipedia.org/wiki/Mathematics_of_cyclic_redundancy_checks#Reversed_representations_and_reciprocal_polynomials\nfor information.\n\n[crc32 on pkg.go.dev](https://pkg.go.dev/hash/crc32)",
        "isTrusted": true
      },
      "detail": "crc32",
      "insertText": "hash/crc32",
      "kind": 8
    },
    {
      "label": "os",
      "documentation": {
        "value": "Package os provides a platform-independent interface to operating system\nfunctionality. The design is Unix-like, although the error handling is\nGo-like; failing calls return values of type error rather than error numbers.\nOften, more information is available within the error. For example,\nif a call that takes a file name fails, such as Open or Stat, the error\nwill include the failing file name when printed and will be of type\n*PathError, which may be unpacked for more information.\n\nThe os interface is intended to be uniform across all operating systems.\nFeatures not generally available appear in the system-specific package syscall.\n\nHere is a simple example, opening a file and reading some of it.\n\n```\n\tfile, err := os.Open(\"file.go\") // For read access.\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n```\nIf the open fails, the error string will be self-explanatory, like\n\n```\n\topen file.go: no such file or directory\n\n```\nThe file's data can then be read into a slice of bytes. Read and\nWrite take their byte counts from the length of the argument slice.\n\n```\n\tdata := make([]byte, 100)\n\tcount, err := file.Read(data)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfmt.Printf(\"read %d bytes: %q\\n\", count, data[:count])\n\n```\nNote: The maximum number of concurrent operations on a File may be limited by\nthe OS or the system. The number should be high, but exceeding it may degrade\nperformance or cause other issues.\n\n[os on pkg.go.dev](https://pkg.go.dev/os)",
        "isTrusted": true
      },
      "detail": "os",
      "insertText": "os",
      "kind": 8
    },
    {
      "label": "hash/adler32",
      "documentation": {
        "value": "Package adler32 implements the Adler-32 checksum.\n\nIt is defined in RFC 1950:\n\n```\n\tAdler-32 is composed of two sums accumulated per byte: s1 is\n\tthe sum of all bytes, s2 is the sum of all s1 values. Both sums\n\tare done modulo 65521. s1 is initialized to 1, s2 to zero.  The\n\tAdler-32 checksum is stored as s2*65536 + s1 in most-\n\tsignificant-byte first (network) order.\n\n```\n\n[adler32 on pkg.go.dev](https://pkg.go.dev/hash/adler32)",
        "isTrusted": true
      },
      "detail": "adler32",
      "insertText": "hash/adler32",
      "kind": 8
    },
    {
      "label": "reflect",
      "documentation": {
        "value": "Package reflect implements run-time reflection, allowing a program to\nmanipulate objects with arbitrary types. The typical use is to take a value\nwith static type interface{} and extract its dynamic type information by\ncalling TypeOf, which returns a Type.\n\nA call to ValueOf returns a Value representing the run-time data.\nZero takes a Type and returns a Value representing a zero value\nfor that type.\n\nSee \"The Laws of Reflection\" for an introduction to reflection in Go:\nhttps://golang.org/doc/articles/laws_of_reflection.html\n\n[reflect on pkg.go.dev](https://pkg.go.dev/reflect)",
        "isTrusted": true
      },
      "detail": "reflect",
      "insertText": "reflect",
      "kind": 8
    },
    {
      "label": "slices",
      "documentation": {
        "value": "Package slices defines various functions useful with slices of any type.\n\n[slices on pkg.go.dev](https://pkg.go.dev/slices)",
        "isTrusted": true
      },
      "detail": "slices",
      "insertText": "slices",
      "kind": 8
    },
    {
      "label": "sort",
      "documentation": {
        "value": "Package sort provides primitives for sorting slices and user-defined collections.\n\n[sort on pkg.go.dev](https://pkg.go.dev/sort)",
        "isTrusted": true
      },
      "detail": "sort",
      "insertText": "sort",
      "kind": 8
    },
    {
      "label": "strconv",
      "documentation": {
        "value": "Package strconv implements conversions to and from string representations\nof basic data types.\n\n# Numeric Conversions\n\nThe most common numeric conversions are Atoi (string to int) and Itoa (int to string).\n\n```\n\ti, err := strconv.Atoi(\"-42\")\n\ts := strconv.Itoa(-42)\n\n```\nThese assume decimal and the Go int type.\n\n[ParseBool], [ParseFloat], [ParseInt], and [ParseUint] convert strings to values:\n\n```\n\tb, err := strconv.ParseBool(\"true\")\n\tf, err := strconv.ParseFloat(\"3.1415\", 64)\n\ti, err := strconv.ParseInt(\"-42\", 10, 64)\n\tu, err := strconv.ParseUint(\"42\", 10, 64)\n\n```\nThe parse functions return the widest type (float64, int64, and uint64),\nbut if the size argument specifies a narrower width the result can be\nconverted to that narrower type without data loss:\n\n```\n\ts := \"2147483647\" // biggest int32\n\ti64, err := strconv.ParseInt(s, 10, 32)\n\t...\n\ti := int32(i64)\n\n```\n[FormatBool], [FormatFloat], [FormatInt], and [FormatUint] convert values to strings:\n\n```\n\ts := strconv.FormatBool(true)\n\ts := strconv.FormatFloat(3.1415, 'E', -1, 64)\n\ts := strconv.FormatInt(-42, 16)\n\ts := strconv.FormatUint(42, 16)\n\n```\n[AppendBool], [AppendFloat], [AppendInt], and [AppendUint] are similar but\nappend the formatted value to a destination slice.\n\n# String Conversions\n\n[Quote] and [QuoteToASCII] convert strings to quoted Go string literals.\nThe latter guarantees that the result is an ASCII string, by escaping\nany non-ASCII Unicode with \\u:\n\n```\n\tq := strconv.Quote(\"Hello, 世界\")\n\tq := strconv.QuoteToASCII(\"Hello, 世界\")\n\n```\n[QuoteRune] and [QuoteRuneToASCII] are similar but accept runes and\nreturn quoted Go rune literals.\n\n[Unquote] and [UnquoteChar] unquote Go string and rune literals.\n\n[strconv on pkg.go.dev](https://pkg.go.dev/strconv)",
        "isTrusted": true
      },
      "detail": "strconv",
      "insertText": "strconv",
      "kind": 8
    },
    {
      "label": "strings",
      "documentation": {
        "value": "Package strings implements simple functions to manipulate UTF-8 encoded strings.\n\nFor information about UTF-8 strings in Go, see https://blog.golang.org/strings.\n\n[strings on pkg.go.dev](https://pkg.go.dev/strings)",
        "isTrusted": true
      },
      "detail": "strings",
      "insertText": "strings",
      "kind": 8
    },
    {
      "label": "syscall",
      "documentation": {
        "value": "mkasm.go generates assembly trampolines to call library routines from Go.\nThis program must be run after mksyscall.pl.\n\n[main on pkg.go.dev](https://pkg.go.dev/syscall)",
        "isTrusted": true
      },
      "detail": "main",
      "insertText": "syscall",
      "kind": 8
    },
    {
      "label": "sync",
      "documentation": {
        "value": "Package sync provides basic synchronization primitives such as mutual\nexclusion locks. Other than the Once and WaitGroup types, most are intended\nfor use by low-level library routines. Higher-level synchronization is\nbetter done via channels and communication.\n\nValues containing the types defined in this package should not be copied.\n\n[sync on pkg.go.dev](https://pkg.go.dev/sync)",
        "isTrusted": true
      },
      "detail": "sync",
      "insertText": "sync",
      "kind": 8
    },
    {
      "label": "unicode",
      "documentation": {
        "value": "Package unicode provides data and functions to test some properties of\nUnicode code points.\n\n[unicode on pkg.go.dev](https://pkg.go.dev/unicode)",
        "isTrusted": true
      },
      "detail": "unicode",
      "insertText": "unicode",
      "kind": 8
    },
    {
      "label": "net",
      "documentation": {
        "value": "Package net provides a portable interface for network I/O, including\nTCP/IP, UDP, domain name resolution, and Unix domain sockets.\n\nAlthough the package provides access to low-level networking\nprimitives, most clients will need only the basic interface provided\nby the [Dial], [Listen], and Accept functions and the associated\n[Conn] and [Listener] interfaces. The crypto/tls package uses\nthe same interfaces and similar Dial and Listen functions.\n\nThe Dial function connects to a server:\n\n```\n\tconn, err := net.Dial(\"tcp\", \"golang.org:80\")\n\tif err != nil {\n\t\t// handle error\n\t}\n\tfmt.Fprintf(conn, \"GET / HTTP/1.0\\r\\n\\r\\n\")\n\tstatus, err := bufio.NewReader(conn).ReadString('\\n')\n\t// ...\n\n```\nThe Listen function creates servers:\n\n```\n\tln, err := net.Listen(\"tcp\", \":8080\")\n\tif err != nil {\n\t\t// handle error\n\t}\n\tfor {\n\t\tconn, err := ln.Accept()\n\t\tif err != nil {\n\t\t\t// handle error\n\t\t}\n\t\tgo handleConnection(conn)\n\t}\n\n```\n# Name Resolution\n\nThe method for resolving domain names, whether indirectly with functions like Dial\nor directly with functions like [LookupHost] and [LookupAddr], varies by operating system.\n\nOn Unix systems, the resolver has two options for resolving names.\nIt can use a pure Go resolver that sends DNS requests directly to the servers\nlisted in /etc/resolv.conf, or it can use a cgo-based resolver that calls C\nlibrary routines such as getaddrinfo and getnameinfo.\n\nBy default the pure Go resolver is used, because a blocked DNS request consumes\nonly a goroutine, while a blocked C call consumes an operating system thread.\nWhen cgo is available, the cgo-based resolver is used instead under a variety of\nconditions: on systems that do not let programs make direct DNS requests (OS X),\nwhen the LOCALDOMAIN environment variable is present (even if empty),\nwhen the RES_OPTIONS or HOSTALIASES environment variable is non-empty,\nwhen the ASR_CONFIG environment variable is non-empty (OpenBSD only),\nwhen /etc/resolv.conf or /etc/nsswitch.conf specify the use of features that the\nGo resolver does not implement, and when the name being looked up ends in .local\nor is an mDNS name.\n\nThe resolver decision can be overridden by setting the netdns value of the\nGODEBUG environment variable (see package runtime) to go or cgo, as in:\n\n```\n\texport GODEBUG=netdns=go    # force pure Go resolver\n\texport GODEBUG=netdns=cgo   # force native resolver (cgo, win32)\n\n```\nThe decision can also be forced while building the Go source tree\nby setting the netgo or netcgo build tag.\n\nA numeric netdns setting, as in GODEBUG=netdns=1, causes the resolver\nto print debugging information about its decisions.\nTo force a particular resolver while also printing debugging information,\njoin the two settings by a plus sign, as in GODEBUG=netdns=go+1.\n\nOn macOS, if Go code that uses the net package is built with\n-buildmode=c-archive, linking the resulting archive into a C program\nrequires passing -lresolv when linking the C code.\n\nOn Plan 9, the resolver always accesses /net/cs and /net/dns.\n\nOn Windows, in Go 1.18.x and earlier, the resolver always used C\nlibrary functions, such as GetAddrInfo and DnsQuery.\n\n[net on pkg.go.dev](https://pkg.go.dev/net)",
        "isTrusted": true
      },
      "detail": "net",
      "insertText": "net",
      "kind": 8
    },
    {
      "label": "hash/crc64",
      "documentation": {
        "value": "Package crc64 implements the 64-bit cyclic redundancy check, or CRC-64,\nchecksum. See https://en.wikipedia.org/wiki/Cyclic_redundancy_check for\ninformation.\n\n[crc64 on pkg.go.dev](https://pkg.go.dev/hash/crc64)",
        "isTrusted": true
      },
      "detail": "crc64",
      "insertText": "hash/crc64",
      "kind": 8
    },
    {
      "label": "testing",
      "documentation": {
        "value": "Package testing provides support for automated testing of Go packages.\nIt is intended to be used in concert with the \"go test\" command, which automates\nexecution of any function of the form\n\n```\n\tfunc TestXxx(*testing.T)\n\n```\nwhere Xxx does not start with a lowercase letter. The function name\nserves to identify the test routine.\n\nWithin these functions, use the Error, Fail or related methods to signal failure.\n\nTo write a new test suite, create a file that\ncontains the TestXxx functions as described here,\nand give that file a name ending in \"_test.go\".\nThe file will be excluded from regular\npackage builds but will be included when the \"go test\" command is run.\n\nThe test file can be in the same package as the one being tested,\nor in a corresponding package with the suffix \"_test\".\n\nIf the test file is in the same package, it may refer to unexported\nidentifiers within the package, as in this example:\n\n```\n\tpackage abs\n\n\timport \"testing\"\n\n\tfunc TestAbs(t *testing.T) {\n\t    got := Abs(-1)\n\t    if got != 1 {\n\t        t.Errorf(\"Abs(-1) = %d; want 1\", got)\n\t    }\n\t}\n\n```\nIf the file is in a separate \"_test\" package, the package being tested\nmust be imported explicitly and only its exported identifiers may be used.\nThis is known as \"black box\" testing.\n\n```\n\tpackage abs_test\n\n\timport (\n\t\t\"testing\"\n\n\t\t\"path_to_pkg/abs\"\n\t)\n\n\tfunc TestAbs(t *testing.T) {\n\t    got := abs.Abs(-1)\n\t    if got != 1 {\n\t        t.Errorf(\"Abs(-1) = %d; want 1\", got)\n\t    }\n\t}\n\n```\nFor more detail, run \"go help test\" and \"go help testflag\".\n\n# Benchmarks\n\nFunctions of the form\n\n```\n\tfunc BenchmarkXxx(*testing.B)\n\n```\nare considered benchmarks, and are executed by the \"go test\" command when\nits -bench flag is provided. Benchmarks are run sequentially.\n\nFor a description of the testing flags, see\nhttps://golang.org/cmd/go/#hdr-Testing_flags.\n\nA sample benchmark function looks like this:\n\n```\n\tfunc BenchmarkRandInt(b *testing.B) {\n\t    for i := 0; i \u003c b.N; i++ {\n\t        rand.Int()\n\t    }\n\t}\n\n```\nThe benchmark function must run the target code b.N times.\nDuring benchmark execution, b.N is adjusted until the benchmark function lasts\nlong enough to be timed reliably. The output\n\n```\n\tBenchmarkRandInt-8   \t68453040\t        17.8 ns/op\n\n```\nmeans that the loop ran 68453040 times at a speed of 17.8 ns per loop.\n\nIf a benchmark needs some expensive setup before running, the timer\nmay be reset:\n\n```\n\tfunc BenchmarkBigLen(b *testing.B) {\n\t    big := NewBig()\n\t    b.ResetTimer()\n\t    for i := 0; i \u003c b.N; i++ {\n\t        big.Len()\n\t    }\n\t}\n\n```\nIf a benchmark needs to test performance in a parallel setting, it may use\nthe RunParallel helper function; such benchmarks are intended to be used with\nthe go test -cpu flag:\n\n```\n\tfunc BenchmarkTemplateParallel(b *testing.B) {\n\t    templ := template.Must(template.New(\"test\").Parse(\"Hello, {{.}}!\"))\n\t    b.RunParallel(func(pb *testing.PB) {\n\t        var buf bytes.Buffer\n\t        for pb.Next() {\n\t            buf.Reset()\n\t            templ.Execute(\u0026buf, \"World\")\n\t        }\n\t    })\n\t}\n\n```\nA detailed specification of the benchmark results format is given\nin https://golang.org/design/14313-benchmark-format.\n\nThere are standard tools for working with benchmark results at\nhttps://golang.org/x/perf/cmd.\nIn particular, https://golang.org/x/perf/cmd/benchstat performs\nstatistically robust A/B comparisons.\n\n# Examples\n\nThe package also runs and verifies example code. Example functions may\ninclude a concluding line comment that begins with \"Output:\" and is compared with\nthe standard output of the function when the tests are run. (The comparison\nignores leading and trailing space.) These are examples of an example:\n\n```\n\tfunc ExampleHello() {\n\t    fmt.Println(\"hello\")\n\t    // Output: hello\n\t}\n\n\tfunc ExampleSalutations() {\n\t    fmt.Println(\"hello, and\")\n\t    fmt.Println(\"goodbye\")\n\t    // Output:\n\t    // hello, and\n\t    // goodbye\n\t}\n\n```\nThe comment prefix \"Unordered output:\" is like \"Output:\", but matches any\nline order:\n\n```\n\tfunc ExamplePerm() {\n\t    for _, value := range Perm(5) {\n\t        fmt.Println(value)\n\t    }\n\t    // Unordered output: 4\n\t    // 2\n\t    // 1\n\t    // 3\n\t    // 0\n\t}\n\n```\nExample functions without output comments are compiled but not executed.\n\nThe naming convention to declare examples for the package, a function F, a type T and\nmethod M on type T are:\n\n```\n\tfunc Example() { ... }\n\tfunc ExampleF() { ... }\n\tfunc ExampleT() { ... }\n\tfunc ExampleT_M() { ... }\n\n```\nMultiple example functions for a package/type/function/method may be provided by\nappending a distinct suffix to the name. The suffix must start with a\nlower-case letter.\n\n```\n\tfunc Example_suffix() { ... }\n\tfunc ExampleF_suffix() { ... }\n\tfunc ExampleT_suffix() { ... }\n\tfunc ExampleT_M_suffix() { ... }\n\n```\nThe entire test file is presented as the example when it contains a single\nexample function, at least one other function, type, variable, or constant\ndeclaration, and no test or benchmark functions.\n\n# Fuzzing\n\n'go test' and the testing package support fuzzing, a testing technique where\na function is called with randomly generated inputs to find bugs not\nanticipated by unit tests.\n\nFunctions of the form\n\n```\n\tfunc FuzzXxx(*testing.F)\n\n```\nare considered fuzz tests.\n\nFor example:\n\n```\n\tfunc FuzzHex(f *testing.F) {\n\t  for _, seed := range [][]byte{{}, {0}, {9}, {0xa}, {0xf}, {1, 2, 3, 4}} {\n\t    f.Add(seed)\n\t  }\n\t  f.Fuzz(func(t *testing.T, in []byte) {\n\t    enc := hex.EncodeToString(in)\n\t    out, err := hex.DecodeString(enc)\n\t    if err != nil {\n\t      t.Fatalf(\"%v: decode: %v\", in, err)\n\t    }\n\t    if !bytes.Equal(in, out) {\n\t      t.Fatalf(\"%v: not equal after round trip: %v\", in, out)\n\t    }\n\t  })\n\t}\n\n```\nA fuzz test maintains a seed corpus, or a set of inputs which are run by\ndefault, and can seed input generation. Seed inputs may be registered by\ncalling (*F).Add or by storing files in the directory testdata/fuzz/\u003cName\u003e\n(where \u003cName\u003e is the name of the fuzz test) within the package containing\nthe fuzz test. Seed inputs are optional, but the fuzzing engine may find\nbugs more efficiently when provided with a set of small seed inputs with good\ncode coverage. These seed inputs can also serve as regression tests for bugs\nidentified through fuzzing.\n\nThe function passed to (*F).Fuzz within the fuzz test is considered the fuzz\ntarget. A fuzz target must accept a *T parameter, followed by one or more\nparameters for random inputs. The types of arguments passed to (*F).Add must\nbe identical to the types of these parameters. The fuzz target may signal\nthat it's found a problem the same way tests do: by calling T.Fail (or any\nmethod that calls it like T.Error or T.Fatal) or by panicking.\n\nWhen fuzzing is enabled (by setting the -fuzz flag to a regular expression\nthat matches a specific fuzz test), the fuzz target is called with arguments\ngenerated by repeatedly making random changes to the seed inputs. On\nsupported platforms, 'go test' compiles the test executable with fuzzing\ncoverage instrumentation. The fuzzing engine uses that instrumentation to\nfind and cache inputs that expand coverage, increasing the likelihood of\nfinding bugs. If the fuzz target fails for a given input, the fuzzing engine\nwrites the inputs that caused the failure to a file in the directory\ntestdata/fuzz/\u003cName\u003e within the package directory. This file later serves as\na seed input. If the file can't be written at that location (for example,\nbecause the directory is read-only), the fuzzing engine writes the file to\nthe fuzz cache directory within the build cache instead.\n\nWhen fuzzing is disabled, the fuzz target is called with the seed inputs\nregistered with F.Add and seed inputs from testdata/fuzz/\u003cName\u003e. In this\nmode, the fuzz test acts much like a regular test, with subtests started\nwith F.Fuzz instead of T.Run.\n\nSee https://go.dev/doc/fuzz for documentation about fuzzing.\n\n# Skipping\n\nTests or benchmarks may be skipped at run time with a call to\nthe Skip method of *T or *B:\n\n```\n\tfunc TestTimeConsuming(t *testing.T) {\n\t    if testing.Short() {\n\t        t.Skip(\"skipping test in short mode.\")\n\t    }\n\t    ...\n\t}\n\n```\nThe Skip method of *T can be used in a fuzz target if the input is invalid,\nbut should not be considered a failing input. For example:\n\n```\n\tfunc FuzzJSONMarshaling(f *testing.F) {\n\t    f.Fuzz(func(t *testing.T, b []byte) {\n\t        var v interface{}\n\t        if err := json.Unmarshal(b, \u0026v); err != nil {\n\t            t.Skip()\n\t        }\n\t        if _, err := json.Marshal(v); err != nil {\n\t            t.Errorf(\"Marshal: %v\", err)\n\t        }\n\t    })\n\t}\n\n```\n# Subtests and Sub-benchmarks\n\nThe Run methods of T and B allow defining subtests and sub-benchmarks,\nwithout having to define separate functions for each. This enables uses\nlike table-driven benchmarks and creating hierarchical tests.\nIt also provides a way to share common setup and tear-down code:\n\n```\n\tfunc TestFoo(t *testing.T) {\n\t    // \u003csetup code\u003e\n\t    t.Run(\"A=1\", func(t *testing.T) { ... })\n\t    t.Run(\"A=2\", func(t *testing.T) { ... })\n\t    t.Run(\"B=1\", func(t *testing.T) { ... })\n\t    // \u003ctear-down code\u003e\n\t}\n\n```\nEach subtest and sub-benchmark has a unique name: the combination of the name\nof the top-level test and the sequence of names passed to Run, separated by\nslashes, with an optional trailing sequence number for disambiguation.\n\nThe argument to the -run, -bench, and -fuzz command-line flags is an unanchored regular\nexpression that matches the test's name. For tests with multiple slash-separated\nelements, such as subtests, the argument is itself slash-separated, with\nexpressions matching each name element in turn. Because it is unanchored, an\nempty expression matches any string.\nFor example, using \"matching\" to mean \"whose name contains\":\n\n```\n\tgo test -run ''        # Run all tests.\n\tgo test -run Foo       # Run top-level tests matching \"Foo\", such as \"TestFooBar\".\n\tgo test -run Foo/A=    # For top-level tests matching \"Foo\", run subtests matching \"A=\".\n\tgo test -run /A=1      # For all top-level tests, run subtests matching \"A=1\".\n\tgo test -fuzz FuzzFoo  # Fuzz the target matching \"FuzzFoo\"\n\n```\nThe -run argument can also be used to run a specific value in the seed\ncorpus, for debugging. For example:\n\n```\n\tgo test -run=FuzzFoo/9ddb952d9814\n\n```\nThe -fuzz and -run flags can both be set, in order to fuzz a target but\nskip the execution of all other tests.\n\nSubtests can also be used to control parallelism. A parent test will only\ncomplete once all of its subtests complete. In this example, all tests are\nrun in parallel with each other, and only with each other, regardless of\nother top-level tests that may be defined:\n\n```\n\tfunc TestGroupedParallel(t *testing.T) {\n\t    for _, tc := range tests {\n\t        tc := tc // capture range variable\n\t        t.Run(tc.Name, func(t *testing.T) {\n\t            t.Parallel()\n\t            ...\n\t        })\n\t    }\n\t}\n\n```\nRun does not return until parallel subtests have completed, providing a way\nto clean up after a group of parallel tests:\n\n```\n\tfunc TestTeardownParallel(t *testing.T) {\n\t    // This Run will not return until the parallel tests finish.\n\t    t.Run(\"group\", func(t *testing.T) {\n\t        t.Run(\"Test1\", parallelTest1)\n\t        t.Run(\"Test2\", parallelTest2)\n\t        t.Run(\"Test3\", parallelTest3)\n\t    })\n\t    // \u003ctear-down code\u003e\n\t}\n\n```\n# Main\n\nIt is sometimes necessary for a test or benchmark program to do extra setup or teardown\nbefore or after it executes. It is also sometimes necessary to control\nwhich code runs on the main thread. To support these and other cases,\nif a test file contains a function:\n\n```\n\tfunc TestMain(m *testing.M)\n\n```\nthen the generated test will call TestMain(m) instead of running the tests or benchmarks\ndirectly. TestMain runs in the main goroutine and can do whatever setup\nand teardown is necessary around a call to m.Run. m.Run will return an exit\ncode that may be passed to os.Exit. If TestMain returns, the test wrapper\nwill pass the result of m.Run to os.Exit itself.\n\nWhen TestMain is called, flag.Parse has not been run. If TestMain depends on\ncommand-line flags, including those of the testing package, it should call\nflag.Parse explicitly. Command line flags are always parsed by the time test\nor benchmark functions run.\n\nA simple implementation of TestMain is:\n\n```\n\tfunc TestMain(m *testing.M) {\n\t\t// call flag.Parse() here if TestMain uses flags\n\t\tos.Exit(m.Run())\n\t}\n\n```\nTestMain is a low-level primitive and should not be necessary for casual\ntesting needs, where ordinary test functions suffice.\n\n[testing on pkg.go.dev](https://pkg.go.dev/testing)",
        "isTrusted": true
      },
      "detail": "testing",
      "insertText": "testing",
      "kind": 8
    },
    {
      "label": "hash/fnv",
      "documentation": {
        "value": "Package fnv implements FNV-1 and FNV-1a, non-cryptographic hash functions\ncreated by Glenn Fowler, Landon Curt Noll, and Phong Vo.\nSee\nhttps://en.wikipedia.org/wiki/Fowler-Noll-Vo_hash_function.\n\nAll the hash.Hash implementations returned by this package also\nimplement encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to\nmarshal and unmarshal the internal state of the hash.\n\n[fnv on pkg.go.dev](https://pkg.go.dev/hash/fnv)",
        "isTrusted": true
      },
      "detail": "fnv",
      "insertText": "hash/fnv",
      "kind": 8
    },
    {
      "label": "unsafe",
      "documentation": {
        "value": "Package unsafe contains operations that step around the type safety of Go programs.\n\nPackages that import unsafe may be non-portable and are not protected by the\nGo 1 compatibility guidelines.\n\n[unsafe on pkg.go.dev](https://pkg.go.dev/unsafe)",
        "isTrusted": true
      },
      "detail": "unsafe",
      "insertText": "unsafe",
      "kind": 8
    },
    {
      "label": "hash/maphash",
      "documentation": {
        "value": "Package maphash provides hash functions on byte sequences.\nThese hash functions are intended to be used to implement hash tables or\nother data structures that need to map arbitrary strings or byte\nsequences to a uniform distribution on unsigned 64-bit integers.\nEach different instance of a hash table or data structure should use its own [Seed].\n\nThe hash functions are not cryptographically secure.\n(See crypto/sha256 and crypto/sha512 for cryptographic use.)\n\n[maphash on pkg.go.dev](https://pkg.go.dev/hash/maphash)",
        "isTrusted": true
      },
      "detail": "maphash",
      "insertText": "hash/maphash",
      "kind": 8
    },
    {
      "label": "arena",
      "documentation": {
        "value": "The arena package provides the ability to allocate memory for a collection\nof Go values and free that space manually all at once, safely. The purpose\nof this functionality is to improve efficiency: manually freeing memory\nbefore a garbage collection delays that cycle. Less frequent cycles means\nthe CPU cost of the garbage collector is incurred less frequently.\n\nThis functionality in this package is mostly captured in the Arena type.\nArenas allocate large chunks of memory for Go values, so they're likely to\nbe inefficient for allocating only small amounts of small Go values. They're\nbest used in bulk, on the order of MiB of memory allocated on each use.\n\nNote that by allowing for this limited form of manual memory allocation\nthat use-after-free bugs are possible with regular Go values. This package\nlimits the impact of these use-after-free bugs by preventing reuse of freed\nmemory regions until the garbage collector is able to determine that it is\nsafe. Typically, a use-after-free bug will result in a fault and a helpful\nerror message, but this package reserves the right to not force a fault on\nfreed memory. That means a valid implementation of this package is to just\nallocate all memory the way the runtime normally would, and in fact, it\nreserves the right to occasionally do so for some Go values.\n\n[arena on pkg.go.dev](https://pkg.go.dev/arena)",
        "isTrusted": true
      },
      "detail": "arena",
      "insertText": "arena",
      "kind": 8
    },
    {
      "label": "time",
      "documentation": {
        "value": "Package time provides functionality for measuring and displaying time.\n\nThe calendrical calculations always assume a Gregorian calendar, with\nno leap seconds.\n\n# Monotonic Clocks\n\nOperating systems provide both a “wall clock,” which is subject to\nchanges for clock synchronization, and a “monotonic clock,” which is\nnot. The general rule is that the wall clock is for telling time and\nthe monotonic clock is for measuring time. Rather than split the API,\nin this package the Time returned by time.Now contains both a wall\nclock reading and a monotonic clock reading; later time-telling\noperations use the wall clock reading, but later time-measuring\noperations, specifically comparisons and subtractions, use the\nmonotonic clock reading.\n\nFor example, this code always computes a positive elapsed time of\napproximately 20 milliseconds, even if the wall clock is changed during\nthe operation being timed:\n\n```\n\tstart := time.Now()\n\t... operation that takes 20 milliseconds ...\n\tt := time.Now()\n\telapsed := t.Sub(start)\n\n```\nOther idioms, such as time.Since(start), time.Until(deadline), and\ntime.Now().Before(deadline), are similarly robust against wall clock\nresets.\n\nThe rest of this section gives the precise details of how operations\nuse monotonic clocks, but understanding those details is not required\nto use this package.\n\nThe Time returned by time.Now contains a monotonic clock reading.\nIf Time t has a monotonic clock reading, t.Add adds the same duration to\nboth the wall clock and monotonic clock readings to compute the result.\nBecause t.AddDate(y, m, d), t.Round(d), and t.Truncate(d) are wall time\ncomputations, they always strip any monotonic clock reading from their results.\nBecause t.In, t.Local, and t.UTC are used for their effect on the interpretation\nof the wall time, they also strip any monotonic clock reading from their results.\nThe canonical way to strip a monotonic clock reading is to use t = t.Round(0).\n\nIf Times t and u both contain monotonic clock readings, the operations\nt.After(u), t.Before(u), t.Equal(u), t.Compare(u), and t.Sub(u) are carried out\nusing the monotonic clock readings alone, ignoring the wall clock\nreadings. If either t or u contains no monotonic clock reading, these\noperations fall back to using the wall clock readings.\n\nOn some systems the monotonic clock will stop if the computer goes to sleep.\nOn such a system, t.Sub(u) may not accurately reflect the actual\ntime that passed between t and u.\n\nBecause the monotonic clock reading has no meaning outside\nthe current process, the serialized forms generated by t.GobEncode,\nt.MarshalBinary, t.MarshalJSON, and t.MarshalText omit the monotonic\nclock reading, and t.Format provides no format for it. Similarly, the\nconstructors time.Date, time.Parse, time.ParseInLocation, and time.Unix,\nas well as the unmarshalers t.GobDecode, t.UnmarshalBinary.\nt.UnmarshalJSON, and t.UnmarshalText always create times with\nno monotonic clock reading.\n\nThe monotonic clock reading exists only in Time values. It is not\na part of Duration values or the Unix times returned by t.Unix and\nfriends.\n\nNote that the Go == operator compares not just the time instant but\nalso the Location and the monotonic clock reading. See the\ndocumentation for the Time type for a discussion of equality\ntesting for Time values.\n\nFor debugging, the result of t.String does include the monotonic\nclock reading if present. If t != u because of different monotonic clock readings,\nthat difference will be visible when printing t.String() and u.String().\n\n# Timer Resolution\n\nTimer resolution varies depending on the Go runtime, the operating system\nand the underlying hardware.\nOn Unix, the resolution is approximately 1ms.\nOn Windows, the default resolution is approximately 16ms, but\na higher resolution may be requested using [golang.org/x/sys/windows.TimeBeginPeriod].\n\n[time on pkg.go.dev](https://pkg.go.dev/time)",
        "isTrusted": true
      },
      "detail": "time",
      "insertText": "time",
      "kind": 8
    },
    {
      "label": "html/template",
      "documentation": {
        "value": "Package template (html/template) implements data-driven templates for\ngenerating HTML output safe against code injection. It provides the\nsame interface as [text/template] and should be used instead of\n[text/template] whenever the output is HTML.\n\nThe documentation here focuses on the security features of the package.\nFor information about how to program the templates themselves, see the\ndocumentation for [text/template].\n\n# Introduction\n\nThis package wraps [text/template] so you can share its template API\nto parse and execute HTML templates safely.\n\n```\n\ttmpl, err := template.New(\"name\").Parse(...)\n\t// Error checking elided\n\terr = tmpl.Execute(out, data)\n\n```\nIf successful, tmpl will now be injection-safe. Otherwise, err is an error\ndefined in the docs for ErrorCode.\n\nHTML templates treat data values as plain text which should be encoded so they\ncan be safely embedded in an HTML document. The escaping is contextual, so\nactions can appear within JavaScript, CSS, and URI contexts.\n\nThe security model used by this package assumes that template authors are\ntrusted, while Execute's data parameter is not. More details are\nprovided below.\n\nExample\n\n```\n\timport \"text/template\"\n\t...\n\tt, err := template.New(\"foo\").Parse(`{{define \"T\"}}Hello, {{.}}!{{end}}`)\n\terr = t.ExecuteTemplate(out, \"T\", \"\u003cscript\u003ealert('you have been pwned')\u003c/script\u003e\")\n\n```\nproduces\n\n```\n\tHello, \u003cscript\u003ealert('you have been pwned')\u003c/script\u003e!\n\n```\nbut the contextual autoescaping in html/template\n\n```\n\timport \"html/template\"\n\t...\n\tt, err := template.New(\"foo\").Parse(`{{define \"T\"}}Hello, {{.}}!{{end}}`)\n\terr = t.ExecuteTemplate(out, \"T\", \"\u003cscript\u003ealert('you have been pwned')\u003c/script\u003e\")\n\n```\nproduces safe, escaped HTML output\n\n```\n\tHello, \u0026lt;script\u0026gt;alert(\u0026#39;you have been pwned\u0026#39;)\u0026lt;/script\u0026gt;!\n\n```\n# Contexts\n\nThis package understands HTML, CSS, JavaScript, and URIs. It adds sanitizing\nfunctions to each simple action pipeline, so given the excerpt\n\n```\n\t\u003ca href=\"/search?q={{.}}\"\u003e{{.}}\u003c/a\u003e\n\n```\nAt parse time each {{.}} is overwritten to add escaping functions as necessary.\nIn this case it becomes\n\n```\n\t\u003ca href=\"/search?q={{. | urlescaper | attrescaper}}\"\u003e{{. | htmlescaper}}\u003c/a\u003e\n\n```\nwhere urlescaper, attrescaper, and htmlescaper are aliases for internal escaping\nfunctions.\n\nFor these internal escaping functions, if an action pipeline evaluates to\na nil interface value, it is treated as though it were an empty string.\n\n# Namespaced and data- attributes\n\nAttributes with a namespace are treated as if they had no namespace.\nGiven the excerpt\n\n```\n\t\u003ca my:href=\"{{.}}\"\u003e\u003c/a\u003e\n\n```\nAt parse time the attribute will be treated as if it were just \"href\".\nSo at parse time the template becomes:\n\n```\n\t\u003ca my:href=\"{{. | urlescaper | attrescaper}}\"\u003e\u003c/a\u003e\n\n```\nSimilarly to attributes with namespaces, attributes with a \"data-\" prefix are\ntreated as if they had no \"data-\" prefix. So given\n\n```\n\t\u003ca data-href=\"{{.}}\"\u003e\u003c/a\u003e\n\n```\nAt parse time this becomes\n\n```\n\t\u003ca data-href=\"{{. | urlescaper | attrescaper}}\"\u003e\u003c/a\u003e\n\n```\nIf an attribute has both a namespace and a \"data-\" prefix, only the namespace\nwill be removed when determining the context. For example\n\n```\n\t\u003ca my:data-href=\"{{.}}\"\u003e\u003c/a\u003e\n\n```\nThis is handled as if \"my:data-href\" was just \"data-href\" and not \"href\" as\nit would be if the \"data-\" prefix were to be ignored too. Thus at parse\ntime this becomes just\n\n```\n\t\u003ca my:data-href=\"{{. | attrescaper}}\"\u003e\u003c/a\u003e\n\n```\nAs a special case, attributes with the namespace \"xmlns\" are always treated\nas containing URLs. Given the excerpts\n\n```\n\t\u003ca xmlns:title=\"{{.}}\"\u003e\u003c/a\u003e\n\t\u003ca xmlns:href=\"{{.}}\"\u003e\u003c/a\u003e\n\t\u003ca xmlns:onclick=\"{{.}}\"\u003e\u003c/a\u003e\n\n```\nAt parse time they become:\n\n```\n\t\u003ca xmlns:title=\"{{. | urlescaper | attrescaper}}\"\u003e\u003c/a\u003e\n\t\u003ca xmlns:href=\"{{. | urlescaper | attrescaper}}\"\u003e\u003c/a\u003e\n\t\u003ca xmlns:onclick=\"{{. | urlescaper | attrescaper}}\"\u003e\u003c/a\u003e\n\n```\n# Errors\n\nSee the documentation of ErrorCode for details.\n\n# A fuller picture\n\nThe rest of this package comment may be skipped on first reading; it includes\ndetails necessary to understand escaping contexts and error messages. Most users\nwill not need to understand these details.\n\n# Contexts\n\nAssuming {{.}} is `O'Reilly: How are \u003ci\u003eyou\u003c/i\u003e?`, the table below shows\nhow {{.}} appears when used in the context to the left.\n\n```\n\tContext                          {{.}} After\n\t{{.}}                            O'Reilly: How are \u0026lt;i\u0026gt;you\u0026lt;/i\u0026gt;?\n\t\u003ca title='{{.}}'\u003e                O\u0026#39;Reilly: How are you?\n\t\u003ca href=\"/{{.}}\"\u003e                O\u0026#39;Reilly: How are %3ci%3eyou%3c/i%3e?\n\t\u003ca href=\"?q={{.}}\"\u003e              O\u0026#39;Reilly%3a%20How%20are%3ci%3e...%3f\n\t\u003ca onx='f(\"{{.}}\")'\u003e             O\\x27Reilly: How are \\x3ci\\x3eyou...?\n\t\u003ca onx='f({{.}})'\u003e               \"O\\x27Reilly: How are \\x3ci\\x3eyou...?\"\n\t\u003ca onx='pattern = /{{.}}/;'\u003e     O\\x27Reilly: How are \\x3ci\\x3eyou...\\x3f\n\n```\nIf used in an unsafe context, then the value might be filtered out:\n\n```\n\tContext                          {{.}} After\n\t\u003ca href=\"{{.}}\"\u003e                 #ZgotmplZ\n\n```\nsince \"O'Reilly:\" is not an allowed protocol like \"http:\".\n\nIf {{.}} is the innocuous word, `left`, then it can appear more widely,\n\n```\n\tContext                              {{.}} After\n\t{{.}}                                left\n\t\u003ca title='{{.}}'\u003e                    left\n\t\u003ca href='{{.}}'\u003e                     left\n\t\u003ca href='/{{.}}'\u003e                    left\n\t\u003ca href='?dir={{.}}'\u003e                left\n\t\u003ca style=\"border-{{.}}: 4px\"\u003e        left\n\t\u003ca style=\"align: {{.}}\"\u003e             left\n\t\u003ca style=\"background: '{{.}}'\u003e       left\n\t\u003ca style=\"background: url('{{.}}')\u003e  left\n\t\u003cstyle\u003ep.{{.}} {color:red}\u003c/style\u003e   left\n\n```\nNon-string values can be used in JavaScript contexts.\nIf {{.}} is\n\n```\n\tstruct{A,B string}{ \"foo\", \"bar\" }\n\n```\nin the escaped template\n\n```\n\t\u003cscript\u003evar pair = {{.}};\u003c/script\u003e\n\n```\nthen the template output is\n\n```\n\t\u003cscript\u003evar pair = {\"A\": \"foo\", \"B\": \"bar\"};\u003c/script\u003e\n\n```\nSee package json to understand how non-string content is marshaled for\nembedding in JavaScript contexts.\n\n# Typed Strings\n\nBy default, this package assumes that all pipelines produce a plain text string.\nIt adds escaping pipeline stages necessary to correctly and safely embed that\nplain text string in the appropriate context.\n\nWhen a data value is not plain text, you can make sure it is not over-escaped\nby marking it with its type.\n\nTypes HTML, JS, URL, and others from content.go can carry safe content that is\nexempted from escaping.\n\nThe template\n\n```\n\tHello, {{.}}!\n\n```\ncan be invoked with\n\n```\n\ttmpl.Execute(out, template.HTML(`\u003cb\u003eWorld\u003c/b\u003e`))\n\n```\nto produce\n\n```\n\tHello, \u003cb\u003eWorld\u003c/b\u003e!\n\n```\ninstead of the\n\n```\n\tHello, \u0026lt;b\u0026gt;World\u0026lt;b\u0026gt;!\n\n```\nthat would have been produced if {{.}} was a regular string.\n\n# Security Model\n\nhttps://rawgit.com/mikesamuel/sanitized-jquery-templates/trunk/safetemplate.html#problem_definition defines \"safe\" as used by this package.\n\nThis package assumes that template authors are trusted, that Execute's data\nparameter is not, and seeks to preserve the properties below in the face\nof untrusted data:\n\nStructure Preservation Property:\n\"... when a template author writes an HTML tag in a safe templating language,\nthe browser will interpret the corresponding portion of the output as a tag\nregardless of the values of untrusted data, and similarly for other structures\nsuch as attribute boundaries and JS and CSS string boundaries.\"\n\nCode Effect Property:\n\"... only code specified by the template author should run as a result of\ninjecting the template output into a page and all code specified by the\ntemplate author should run as a result of the same.\"\n\nLeast Surprise Property:\n\"A developer (or code reviewer) familiar with HTML, CSS, and JavaScript, who\nknows that contextual autoescaping happens should be able to look at a {{.}}\nand correctly infer what sanitization happens.\"\n\nAs a consequence of the Least Surprise Property, template actions within an\nECMAScript 6 template literal are disabled by default.\nHandling string interpolation within these literals is rather complex resulting\nin no clear safe way to support it.\nTo re-enable template actions within ECMAScript 6 template literals, use the\nGODEBUG=jstmpllitinterp=1 environment variable.\n\n[template on pkg.go.dev](https://pkg.go.dev/html/template)",
        "isTrusted": true
      },
      "detail": "template",
      "insertText": "html/template",
      "kind": 8
    },
    {
      "label": "debug/buildinfo",
      "documentation": {
        "value": "Package buildinfo provides access to information embedded in a Go binary\nabout how it was built. This includes the Go toolchain version, and the\nset of modules used (for binaries built in module mode).\n\nBuild information is available for the currently running binary in\nruntime/debug.ReadBuildInfo.\n\n[buildinfo on pkg.go.dev](https://pkg.go.dev/debug/buildinfo)",
        "isTrusted": true
      },
      "detail": "buildinfo",
      "insertText": "debug/buildinfo",
      "kind": 8
    },
    {
      "label": "debug/macho",
      "documentation": {
        "value": "Package macho implements access to Mach-O object files.\n\n# Security\n\nThis package is not designed to be hardened against adversarial inputs, and is\noutside the scope of https://go.dev/security/policy. In particular, only basic\nvalidation is done when parsing object files. As such, care should be taken when\nparsing untrusted inputs, as parsing malformed files may consume significant\nresources, or cause panics.\n\n[macho on pkg.go.dev](https://pkg.go.dev/debug/macho)",
        "isTrusted": true
      },
      "detail": "macho",
      "insertText": "debug/macho",
      "kind": 8
    },
    {
      "label": "runtime",
      "documentation": {
        "value": "Package runtime contains operations that interact with Go's runtime system,\nsuch as functions to control goroutines. It also includes the low-level type information\nused by the reflect package; see [reflect]'s documentation for the programmable\ninterface to the run-time type system.\n\n# Environment Variables\n\nThe following environment variables ($name or %name%, depending on the host\noperating system) control the run-time behavior of Go programs. The meanings\nand use may change from release to release.\n\nThe GOGC variable sets the initial garbage collection target percentage.\nA collection is triggered when the ratio of freshly allocated data to live data\nremaining after the previous collection reaches this percentage. The default\nis GOGC=100. Setting GOGC=off disables the garbage collector entirely.\n[runtime/debug.SetGCPercent] allows changing this percentage at run time.\n\nThe GOMEMLIMIT variable sets a soft memory limit for the runtime. This memory limit\nincludes the Go heap and all other memory managed by the runtime, and excludes\nexternal memory sources such as mappings of the binary itself, memory managed in\nother languages, and memory held by the operating system on behalf of the Go\nprogram. GOMEMLIMIT is a numeric value in bytes with an optional unit suffix.\nThe supported suffixes include B, KiB, MiB, GiB, and TiB. These suffixes\nrepresent quantities of bytes as defined by the IEC 80000-13 standard. That is,\nthey are based on powers of two: KiB means 2^10 bytes, MiB means 2^20 bytes,\nand so on. The default setting is [math.MaxInt64], which effectively disables the\nmemory limit. [runtime/debug.SetMemoryLimit] allows changing this limit at run\ntime.\n\nThe GODEBUG variable controls debugging variables within the runtime.\nIt is a comma-separated list of name=val pairs setting these named variables:\n\n```\n\tallocfreetrace: setting allocfreetrace=1 causes every allocation to be\n\tprofiled and a stack trace printed on each object's allocation and free.\n\n\tclobberfree: setting clobberfree=1 causes the garbage collector to\n\tclobber the memory content of an object with bad content when it frees\n\tthe object.\n\n\tcpu.*: cpu.all=off disables the use of all optional instruction set extensions.\n\tcpu.extension=off disables use of instructions from the specified instruction set extension.\n\textension is the lower case name for the instruction set extension such as sse41 or avx\n\tas listed in internal/cpu package. As an example cpu.avx=off disables runtime detection\n\tand thereby use of AVX instructions.\n\n\tcgocheck: setting cgocheck=0 disables all checks for packages\n\tusing cgo to incorrectly pass Go pointers to non-Go code.\n\tSetting cgocheck=1 (the default) enables relatively cheap\n\tchecks that may miss some errors. A more complete, but slow,\n\tcgocheck mode can be enabled using GOEXPERIMENT (which\n\trequires a rebuild), see https://pkg.go.dev/internal/goexperiment for details.\n\n\tdisablethp: setting disablethp=1 on Linux disables transparent huge pages for the heap.\n\tIt has no effect on other platforms. disablethp is meant for compatibility with versions\n\tof Go before 1.21, which stopped working around a Linux kernel default that can result\n\tin significant memory overuse. See https://go.dev/issue/64332. This setting will be\n\tremoved in a future release, so operators should tweak their Linux configuration to suit\n\ttheir needs before then. See https://go.dev/doc/gc-guide#Linux_transparent_huge_pages.\n\n\tdontfreezetheworld: by default, the start of a fatal panic or throw\n\t\"freezes the world\", preempting all threads to stop all running\n\tgoroutines, which makes it possible to traceback all goroutines, and\n\tkeeps their state close to the point of panic. Setting\n\tdontfreezetheworld=1 disables this preemption, allowing goroutines to\n\tcontinue executing during panic processing. Note that goroutines that\n\tnaturally enter the scheduler will still stop. This can be useful when\n\tdebugging the runtime scheduler, as freezetheworld perturbs scheduler\n\tstate and thus may hide problems.\n\n\tefence: setting efence=1 causes the allocator to run in a mode\n\twhere each object is allocated on a unique page and addresses are\n\tnever recycled.\n\n\tgccheckmark: setting gccheckmark=1 enables verification of the\n\tgarbage collector's concurrent mark phase by performing a\n\tsecond mark pass while the world is stopped.  If the second\n\tpass finds a reachable object that was not found by concurrent\n\tmark, the garbage collector will panic.\n\n\tgcpacertrace: setting gcpacertrace=1 causes the garbage collector to\n\tprint information about the internal state of the concurrent pacer.\n\n\tgcshrinkstackoff: setting gcshrinkstackoff=1 disables moving goroutines\n\tonto smaller stacks. In this mode, a goroutine's stack can only grow.\n\n\tgcstoptheworld: setting gcstoptheworld=1 disables concurrent garbage collection,\n\tmaking every garbage collection a stop-the-world event. Setting gcstoptheworld=2\n\talso disables concurrent sweeping after the garbage collection finishes.\n\n\tgctrace: setting gctrace=1 causes the garbage collector to emit a single line to standard\n\terror at each collection, summarizing the amount of memory collected and the\n\tlength of the pause. The format of this line is subject to change. Included in\n\tthe explanation below is also the relevant runtime/metrics metric for each field.\n\tCurrently, it is:\n\t\tgc # @#s #%: #+#+# ms clock, #+#/#/#+# ms cpu, #-\u003e#-\u003e# MB, # MB goal, # MB stacks, #MB globals, # P\n\twhere the fields are as follows:\n\t\tgc #         the GC number, incremented at each GC\n\t\t@#s          time in seconds since program start\n\t\t#%           percentage of time spent in GC since program start\n\t\t#+...+#      wall-clock/CPU times for the phases of the GC\n\t\t#-\u003e#-\u003e# MB   heap size at GC start, at GC end, and live heap, or /gc/scan/heap:bytes\n\t\t# MB goal    goal heap size, or /gc/heap/goal:bytes\n\t\t# MB stacks  estimated scannable stack size, or /gc/scan/stack:bytes\n\t\t# MB globals scannable global size, or /gc/scan/globals:bytes\n\t\t# P          number of processors used, or /sched/gomaxprocs:threads\n\tThe phases are stop-the-world (STW) sweep termination, concurrent\n\tmark and scan, and STW mark termination. The CPU times\n\tfor mark/scan are broken down in to assist time (GC performed in\n\tline with allocation), background GC time, and idle GC time.\n\tIf the line ends with \"(forced)\", this GC was forced by a\n\truntime.GC() call.\n\n\tharddecommit: setting harddecommit=1 causes memory that is returned to the OS to\n\talso have protections removed on it. This is the only mode of operation on Windows,\n\tbut is helpful in debugging scavenger-related issues on other platforms. Currently,\n\tonly supported on Linux.\n\n\tinittrace: setting inittrace=1 causes the runtime to emit a single line to standard\n\terror for each package with init work, summarizing the execution time and memory\n\tallocation. No information is printed for inits executed as part of plugin loading\n\tand for packages without both user defined and compiler generated init work.\n\tThe format of this line is subject to change. Currently, it is:\n\t\tinit # @#ms, # ms clock, # bytes, # allocs\n\twhere the fields are as follows:\n\t\tinit #      the package name\n\t\t@# ms       time in milliseconds when the init started since program start\n\t\t# clock     wall-clock time for package initialization work\n\t\t# bytes     memory allocated on the heap\n\t\t# allocs    number of heap allocations\n\n\tmadvdontneed: setting madvdontneed=0 will use MADV_FREE\n\tinstead of MADV_DONTNEED on Linux when returning memory to the\n\tkernel. This is more efficient, but means RSS numbers will\n\tdrop only when the OS is under memory pressure. On the BSDs and\n\tIllumos/Solaris, setting madvdontneed=1 will use MADV_DONTNEED instead\n\tof MADV_FREE. This is less efficient, but causes RSS numbers to drop\n\tmore quickly.\n\n\tmemprofilerate: setting memprofilerate=X will update the value of runtime.MemProfileRate.\n\tWhen set to 0 memory profiling is disabled.  Refer to the description of\n\tMemProfileRate for the default value.\n\n\tpagetrace: setting pagetrace=/path/to/file will write out a trace of page events\n\tthat can be viewed, analyzed, and visualized using the x/debug/cmd/pagetrace tool.\n\tBuild your program with GOEXPERIMENT=pagetrace to enable this functionality. Do not\n\tenable this functionality if your program is a setuid binary as it introduces a security\n\trisk in that scenario. Currently not supported on Windows, plan9 or js/wasm. Setting this\n\toption for some applications can produce large traces, so use with care.\n\n\tpanicnil: setting panicnil=1 disables the runtime error when calling panic with nil\n\tinterface value or an untyped nil.\n\n\truntimecontentionstacks: setting runtimecontentionstacks=1 enables inclusion of call stacks\n\trelated to contention on runtime-internal locks in the \"mutex\" profile, subject to the\n\tMutexProfileFraction setting. When runtimecontentionstacks=0, contention on\n\truntime-internal locks will report as \"runtime._LostContendedRuntimeLock\". When\n\truntimecontentionstacks=1, the call stacks will correspond to the unlock call that released\n\tthe lock. But instead of the value corresponding to the amount of contention that call\n\tstack caused, it corresponds to the amount of time the caller of unlock had to wait in its\n\toriginal call to lock. A future release is expected to align those and remove this setting.\n\n\tinvalidptr: invalidptr=1 (the default) causes the garbage collector and stack\n\tcopier to crash the program if an invalid pointer value (for example, 1)\n\tis found in a pointer-typed location. Setting invalidptr=0 disables this check.\n\tThis should only be used as a temporary workaround to diagnose buggy code.\n\tThe real fix is to not store integers in pointer-typed locations.\n\n\tsbrk: setting sbrk=1 replaces the memory allocator and garbage collector\n\twith a trivial allocator that obtains memory from the operating system and\n\tnever reclaims any memory.\n\n\tscavtrace: setting scavtrace=1 causes the runtime to emit a single line to standard\n\terror, roughly once per GC cycle, summarizing the amount of work done by the\n\tscavenger as well as the total amount of memory returned to the operating system\n\tand an estimate of physical memory utilization. The format of this line is subject\n\tto change, but currently it is:\n\t\tscav # KiB work (bg), # KiB work (eager), # KiB total, #% util\n\twhere the fields are as follows:\n\t\t# KiB work (bg)    the amount of memory returned to the OS in the background since\n\t\t                   the last line\n\t\t# KiB work (eager) the amount of memory returned to the OS eagerly since the last line\n\t\t# KiB now          the amount of address space currently returned to the OS\n\t\t#% util            the fraction of all unscavenged heap memory which is in-use\n\tIf the line ends with \"(forced)\", then scavenging was forced by a\n\tdebug.FreeOSMemory() call.\n\n\tscheddetail: setting schedtrace=X and scheddetail=1 causes the scheduler to emit\n\tdetailed multiline info every X milliseconds, describing state of the scheduler,\n\tprocessors, threads and goroutines.\n\n\tschedtrace: setting schedtrace=X causes the scheduler to emit a single line to standard\n\terror every X milliseconds, summarizing the scheduler state.\n\n\ttracebackancestors: setting tracebackancestors=N extends tracebacks with the stacks at\n\twhich goroutines were created, where N limits the number of ancestor goroutines to\n\treport. This also extends the information returned by runtime.Stack. Ancestor's goroutine\n\tIDs will refer to the ID of the goroutine at the time of creation; it's possible for this\n\tID to be reused for another goroutine. Setting N to 0 will report no ancestry information.\n\n\ttracefpunwindoff: setting tracefpunwindoff=1 forces the execution tracer to\n\tuse the runtime's default stack unwinder instead of frame pointer unwinding.\n\tThis increases tracer overhead, but could be helpful as a workaround or for\n\tdebugging unexpected regressions caused by frame pointer unwinding.\n\n\ttraceadvanceperiod: the approximate period in nanoseconds between trace generations. Only\n\tapplies if a program is built with GOEXPERIMENT=exectracer2. Used primarily for testing\n\tand debugging the execution tracer.\n\n\tasyncpreemptoff: asyncpreemptoff=1 disables signal-based\n\tasynchronous goroutine preemption. This makes some loops\n\tnon-preemptible for long periods, which may delay GC and\n\tgoroutine scheduling. This is useful for debugging GC issues\n\tbecause it also disables the conservative stack scanning used\n\tfor asynchronously preempted goroutines.\n\n```\nThe [net] and [net/http] packages also refer to debugging variables in GODEBUG.\nSee the documentation for those packages for details.\n\nThe GOMAXPROCS variable limits the number of operating system threads that\ncan execute user-level Go code simultaneously. There is no limit to the number of threads\nthat can be blocked in system calls on behalf of Go code; those do not count against\nthe GOMAXPROCS limit. This package's [GOMAXPROCS] function queries and changes\nthe limit.\n\nThe GORACE variable configures the race detector, for programs built using -race.\nSee the [Race Detector article] for details.\n\nThe GOTRACEBACK variable controls the amount of output generated when a Go\nprogram fails due to an unrecovered panic or an unexpected runtime condition.\nBy default, a failure prints a stack trace for the current goroutine,\neliding functions internal to the run-time system, and then exits with exit code 2.\nThe failure prints stack traces for all goroutines if there is no current goroutine\nor the failure is internal to the run-time.\nGOTRACEBACK=none omits the goroutine stack traces entirely.\nGOTRACEBACK=single (the default) behaves as described above.\nGOTRACEBACK=all adds stack traces for all user-created goroutines.\nGOTRACEBACK=system is like “all” but adds stack frames for run-time functions\nand shows goroutines created internally by the run-time.\nGOTRACEBACK=crash is like “system” but crashes in an operating system-specific\nmanner instead of exiting. For example, on Unix systems, the crash raises\nSIGABRT to trigger a core dump.\nGOTRACEBACK=wer is like “crash” but doesn't disable Windows Error Reporting (WER).\nFor historical reasons, the GOTRACEBACK settings 0, 1, and 2 are synonyms for\nnone, all, and system, respectively.\nThe [runtime/debug.SetTraceback] function allows increasing the\namount of output at run time, but it cannot reduce the amount below that\nspecified by the environment variable.\n\nThe GOARCH, GOOS, GOPATH, and GOROOT environment variables complete\nthe set of Go environment variables. They influence the building of Go programs\n(see [cmd/go] and [go/build]).\nGOARCH, GOOS, and GOROOT are recorded at compile time and made available by\nconstants or functions in this package, but they do not influence the execution\nof the run-time system.\n\n# Security\n\nOn Unix platforms, Go's runtime system behaves slightly differently when a\nbinary is setuid/setgid or executed with setuid/setgid-like properties, in order\nto prevent dangerous behaviors. On Linux this is determined by checking for the\nAT_SECURE flag in the auxiliary vector, on the BSDs and Solaris/Illumos it is\ndetermined by checking the issetugid syscall, and on AIX it is determined by\nchecking if the uid/gid match the effective uid/gid.\n\nWhen the runtime determines the binary is setuid/setgid-like, it does three main\nthings:\n```\n  - The standard input/output file descriptors (0, 1, 2) are checked to be open.\n    If any of them are closed, they are opened pointing at /dev/null.\n  - The value of the GOTRACEBACK environment variable is set to 'none'.\n  - When a signal is received that terminates the program, or the program\n    encounters an unrecoverable panic that would otherwise override the value\n    of GOTRACEBACK, the goroutine stack, registers, and other memory related\n    information are omitted.\n\n```\n[Race Detector article]: https://go.dev/doc/articles/race_detector\n\n[runtime on pkg.go.dev](https://pkg.go.dev/runtime)",
        "isTrusted": true
      },
      "detail": "runtime",
      "insertText": "runtime",
      "kind": 8
    },
    {
      "label": "debug/dwarf",
      "documentation": {
        "value": "Package dwarf provides access to DWARF debugging information loaded from\nexecutable files, as defined in the DWARF 2.0 Standard at\nhttp://dwarfstd.org/doc/dwarf-2.0.0.pdf.\n\n# Security\n\nThis package is not designed to be hardened against adversarial inputs, and is\noutside the scope of https://go.dev/security/policy. In particular, only basic\nvalidation is done when parsing object files. As such, care should be taken when\nparsing untrusted inputs, as parsing malformed files may consume significant\nresources, or cause panics.\n\n[dwarf on pkg.go.dev](https://pkg.go.dev/debug/dwarf)",
        "isTrusted": true
      },
      "detail": "dwarf",
      "insertText": "debug/dwarf",
      "kind": 8
    },
    {
      "label": "debug/pe",
      "documentation": {
        "value": "Package pe implements access to PE (Microsoft Windows Portable Executable) files.\n\n# Security\n\nThis package is not designed to be hardened against adversarial inputs, and is\noutside the scope of https://go.dev/security/policy. In particular, only basic\nvalidation is done when parsing object files. As such, care should be taken when\nparsing untrusted inputs, as parsing malformed files may consume significant\nresources, or cause panics.\n\n[pe on pkg.go.dev](https://pkg.go.dev/debug/pe)",
        "isTrusted": true
      },
      "detail": "pe",
      "insertText": "debug/pe",
      "kind": 8
    },
    {
      "label": "debug/gosym",
      "documentation": {
        "value": "Package gosym implements access to the Go symbol\nand line number tables embedded in Go binaries generated\nby the gc compilers.\n\n[gosym on pkg.go.dev](https://pkg.go.dev/debug/gosym)",
        "isTrusted": true
      },
      "detail": "gosym",
      "insertText": "debug/gosym",
      "kind": 8
    },
    {
      "label": "debug/plan9obj",
      "documentation": {
        "value": "Package plan9obj implements access to Plan 9 a.out object files.\n\n# Security\n\nThis package is not designed to be hardened against adversarial inputs, and is\noutside the scope of https://go.dev/security/policy. In particular, only basic\nvalidation is done when parsing object files. As such, care should be taken when\nparsing untrusted inputs, as parsing malformed files may consume significant\nresources, or cause panics.\n\n[plan9obj on pkg.go.dev](https://pkg.go.dev/debug/plan9obj)",
        "isTrusted": true
      },
      "detail": "plan9obj",
      "insertText": "debug/plan9obj",
      "kind": 8
    },
    {
      "label": "compress/gzip",
      "documentation": {
        "value": "Package gzip implements reading and writing of gzip format compressed files,\nas specified in RFC 1952.\n\n[gzip on pkg.go.dev](https://pkg.go.dev/compress/gzip)",
        "isTrusted": true
      },
      "detail": "gzip",
      "insertText": "compress/gzip",
      "kind": 8
    },
    {
      "label": "compress/lzw",
      "documentation": {
        "value": "Package lzw implements the Lempel-Ziv-Welch compressed data format,\ndescribed in T. A. Welch, “A Technique for High-Performance Data\nCompression”, Computer, 17(6) (June 1984), pp 8-19.\n\nIn particular, it implements LZW as used by the GIF and PDF file\nformats, which means variable-width codes up to 12 bits and the first\ntwo non-literal codes are a clear code and an EOF code.\n\nThe TIFF file format uses a similar but incompatible version of the LZW\nalgorithm. See the golang.org/x/image/tiff/lzw package for an\nimplementation.\n\n[lzw on pkg.go.dev](https://pkg.go.dev/compress/lzw)",
        "isTrusted": true
      },
      "detail": "lzw",
      "insertText": "compress/lzw",
      "kind": 8
    },
    {
      "label": "compress/bzip2",
      "documentation": {
        "value": "Package bzip2 implements bzip2 decompression.\n\n[bzip2 on pkg.go.dev](https://pkg.go.dev/compress/bzip2)",
        "isTrusted": true
      },
      "detail": "bzip2",
      "insertText": "compress/bzip2",
      "kind": 8
    },
    {
      "label": "compress/zlib",
      "documentation": {
        "value": "Package zlib implements reading and writing of zlib format compressed data,\nas specified in RFC 1950.\n\nThe implementation provides filters that uncompress during reading\nand compress during writing.  For example, to write compressed data\nto a buffer:\n\n```\n\tvar b bytes.Buffer\n\tw := zlib.NewWriter(\u0026b)\n\tw.Write([]byte(\"hello, world\\n\"))\n\tw.Close()\n\n```\nand to read that data back:\n\n```\n\tr, err := zlib.NewReader(\u0026b)\n\tio.Copy(os.Stdout, r)\n\tr.Close()\n\n```\n\n[zlib on pkg.go.dev](https://pkg.go.dev/compress/zlib)",
        "isTrusted": true
      },
      "detail": "zlib",
      "insertText": "compress/zlib",
      "kind": 8
    },
    {
      "label": "container/list",
      "documentation": {
        "value": "Package list implements a doubly linked list.\n\nTo iterate over a list (where l is a *List):\n\n```\n\tfor e := l.Front(); e != nil; e = e.Next() {\n\t\t// do something with e.Value\n\t}\n\n```\n\n[list on pkg.go.dev](https://pkg.go.dev/container/list)",
        "isTrusted": true
      },
      "detail": "list",
      "insertText": "container/list",
      "kind": 8
    },
    {
      "label": "container/heap",
      "documentation": {
        "value": "Package heap provides heap operations for any type that implements\nheap.Interface. A heap is a tree with the property that each node is the\nminimum-valued node in its subtree.\n\nThe minimum element in the tree is the root, at index 0.\n\nA heap is a common way to implement a priority queue. To build a priority\nqueue, implement the Heap interface with the (negative) priority as the\nordering for the Less method, so Push adds items while Pop removes the\nhighest-priority item from the queue. The Examples include such an\nimplementation; the file example_pq_test.go has the complete source.\n\n[heap on pkg.go.dev](https://pkg.go.dev/container/heap)",
        "isTrusted": true
      },
      "detail": "heap",
      "insertText": "container/heap",
      "kind": 8
    },
    {
      "label": "container/ring",
      "documentation": {
        "value": "Package ring implements operations on circular lists.\n\n[ring on pkg.go.dev](https://pkg.go.dev/container/ring)",
        "isTrusted": true
      },
      "detail": "ring",
      "insertText": "container/ring",
      "kind": 8
    },
    {
      "label": "debug/elf",
      "documentation": {
        "value": "Package elf implements access to ELF object files.\n\n# Security\n\nThis package is not designed to be hardened against adversarial inputs, and is\noutside the scope of https://go.dev/security/policy. In particular, only basic\nvalidation is done when parsing object files. As such, care should be taken when\nparsing untrusted inputs, as parsing malformed files may consume significant\nresources, or cause panics.\n\n[elf on pkg.go.dev](https://pkg.go.dev/debug/elf)",
        "isTrusted": true
      },
      "detail": "elf",
      "insertText": "debug/elf",
      "kind": 8
    },
    {
      "label": "crypto/elliptic",
      "documentation": {
        "value": "Package elliptic implements the standard NIST P-224, P-256, P-384, and P-521\nelliptic curves over prime fields.\n\nDirect use of this package is deprecated, beyond the [P224], [P256], [P384],\nand [P521] values necessary to use [crypto/ecdsa]. Most other uses\nshould migrate to the more efficient and safer [crypto/ecdh], or to\nthird-party modules for lower-level functionality.\n\n[elliptic on pkg.go.dev](https://pkg.go.dev/crypto/elliptic)",
        "isTrusted": true
      },
      "detail": "elliptic",
      "insertText": "crypto/elliptic",
      "kind": 8
    },
    {
      "label": "crypto/boring",
      "documentation": {
        "value": "Package boring exposes functions that are only available when building with\nGo+BoringCrypto. This package is available on all targets as long as the\nGo+BoringCrypto toolchain is used. Use the Enabled function to determine\nwhether the BoringCrypto core is actually in use.\n\nAny time the Go+BoringCrypto toolchain is used, the \"boringcrypto\" build tag\nis satisfied, so that applications can tag files that use this package.\n\n[boring on pkg.go.dev](https://pkg.go.dev/crypto/boring)",
        "isTrusted": true
      },
      "detail": "boring",
      "insertText": "crypto/boring",
      "kind": 8
    },
    {
      "label": "crypto/cipher",
      "documentation": {
        "value": "Package cipher implements standard block cipher modes that can be wrapped\naround low-level block cipher implementations.\nSee https://csrc.nist.gov/groups/ST/toolkit/BCM/current_modes.html\nand NIST Special Publication 800-38A.\n\n[cipher on pkg.go.dev](https://pkg.go.dev/crypto/cipher)",
        "isTrusted": true
      },
      "detail": "cipher",
      "insertText": "crypto/cipher",
      "kind": 8
    },
    {
      "label": "crypto/des",
      "documentation": {
        "value": "Package des implements the Data Encryption Standard (DES) and the\nTriple Data Encryption Algorithm (TDEA) as defined\nin U.S. Federal Information Processing Standards Publication 46-3.\n\nDES is cryptographically broken and should not be used for secure\napplications.\n\n[des on pkg.go.dev](https://pkg.go.dev/crypto/des)",
        "isTrusted": true
      },
      "detail": "des",
      "insertText": "crypto/des",
      "kind": 8
    },
    {
      "label": "crypto/dsa",
      "documentation": {
        "value": "Package dsa implements the Digital Signature Algorithm, as defined in FIPS 186-3.\n\nThe DSA operations in this package are not implemented using constant-time algorithms.\n\nDeprecated: DSA is a legacy algorithm, and modern alternatives such as\nEd25519 (implemented by package crypto/ed25519) should be used instead. Keys\nwith 1024-bit moduli (L1024N160 parameters) are cryptographically weak, while\nbigger keys are not widely supported. Note that FIPS 186-5 no longer approves\nDSA for signature generation.\n\n[dsa on pkg.go.dev](https://pkg.go.dev/crypto/dsa)",
        "isTrusted": true
      },
      "detail": "dsa",
      "insertText": "crypto/dsa",
      "kind": 8
    },
    {
      "label": "crypto/ecdh",
      "documentation": {
        "value": "Package ecdh implements Elliptic Curve Diffie-Hellman over\nNIST curves and Curve25519.\n\n[ecdh on pkg.go.dev](https://pkg.go.dev/crypto/ecdh)",
        "isTrusted": true
      },
      "detail": "ecdh",
      "insertText": "crypto/ecdh",
      "kind": 8
    },
    {
      "label": "crypto/ed25519",
      "documentation": {
        "value": "Package ed25519 implements the Ed25519 signature algorithm. See\nhttps://ed25519.cr.yp.to/.\n\nThese functions are also compatible with the “Ed25519” function defined in\nRFC 8032. However, unlike RFC 8032's formulation, this package's private key\nrepresentation includes a public key suffix to make multiple signing\noperations with the same key more efficient. This package refers to the RFC\n8032 private key as the “seed”.\n\n[ed25519 on pkg.go.dev](https://pkg.go.dev/crypto/ed25519)",
        "isTrusted": true
      },
      "detail": "ed25519",
      "insertText": "crypto/ed25519",
      "kind": 8
    },
    {
      "label": "crypto/aes",
      "documentation": {
        "value": "Package aes implements AES encryption (formerly Rijndael), as defined in\nU.S. Federal Information Processing Standards Publication 197.\n\nThe AES operations in this package are not implemented using constant-time algorithms.\nAn exception is when running on systems with enabled hardware support for AES\nthat makes these operations constant-time. Examples include amd64 systems using AES-NI\nextensions and s390x systems using Message-Security-Assist extensions.\nOn such systems, when the result of NewCipher is passed to cipher.NewGCM,\nthe GHASH operation used by GCM is also constant-time.\n\n[aes on pkg.go.dev](https://pkg.go.dev/crypto/aes)",
        "isTrusted": true
      },
      "detail": "aes",
      "insertText": "crypto/aes",
      "kind": 8
    },
    {
      "label": "compress/flate",
      "documentation": {
        "value": "Package flate implements the DEFLATE compressed data format, described in\nRFC 1951.  The gzip and zlib packages implement access to DEFLATE-based file\nformats.\n\n[flate on pkg.go.dev](https://pkg.go.dev/compress/flate)",
        "isTrusted": true
      },
      "detail": "flate",
      "insertText": "compress/flate",
      "kind": 8
    },
    {
      "label": "crypto/hmac",
      "documentation": {
        "value": "Package hmac implements the Keyed-Hash Message Authentication Code (HMAC) as\ndefined in U.S. Federal Information Processing Standards Publication 198.\nAn HMAC is a cryptographic hash that uses a key to sign a message.\nThe receiver verifies the hash by recomputing it using the same key.\n\nReceivers should be careful to use Equal to compare MACs in order to avoid\ntiming side-channels:\n\n```\n\t// ValidMAC reports whether messageMAC is a valid HMAC tag for message.\n\tfunc ValidMAC(message, messageMAC, key []byte) bool {\n\t\tmac := hmac.New(sha256.New, key)\n\t\tmac.Write(message)\n\t\texpectedMAC := mac.Sum(nil)\n\t\treturn hmac.Equal(messageMAC, expectedMAC)\n\t}\n\n```\n\n[hmac on pkg.go.dev](https://pkg.go.dev/crypto/hmac)",
        "isTrusted": true
      },
      "detail": "hmac",
      "insertText": "crypto/hmac",
      "kind": 8
    },
    {
      "label": "crypto/ecdsa",
      "documentation": {
        "value": "Package ecdsa implements the Elliptic Curve Digital Signature Algorithm, as\ndefined in FIPS 186-4 and SEC 1, Version 2.0.\n\nSignatures generated by this package are not deterministic, but entropy is\nmixed with the private key and the message, achieving the same level of\nsecurity in case of randomness source failure.\n\n[ecdsa on pkg.go.dev](https://pkg.go.dev/crypto/ecdsa)",
        "isTrusted": true
      },
      "detail": "ecdsa",
      "insertText": "crypto/ecdsa",
      "kind": 8
    },
    {
      "label": "crypto/rand",
      "documentation": {
        "value": "Package rand implements a cryptographically secure\nrandom number generator.\n\n[rand on pkg.go.dev](https://pkg.go.dev/crypto/rand)",
        "isTrusted": true
      },
      "detail": "rand",
      "insertText": "crypto/rand",
      "kind": 8
    },
    {
      "label": "crypto/rc4",
      "documentation": {
        "value": "Package rc4 implements RC4 encryption, as defined in Bruce Schneier's\nApplied Cryptography.\n\nRC4 is cryptographically broken and should not be used for secure\napplications.\n\n[rc4 on pkg.go.dev](https://pkg.go.dev/crypto/rc4)",
        "isTrusted": true
      },
      "detail": "rc4",
      "insertText": "crypto/rc4",
      "kind": 8
    },
    {
      "label": "crypto/md5",
      "documentation": {
        "value": "Package md5 implements the MD5 hash algorithm as defined in RFC 1321.\n\nMD5 is cryptographically broken and should not be used for secure\napplications.\n\n[md5 on pkg.go.dev](https://pkg.go.dev/crypto/md5)",
        "isTrusted": true
      },
      "detail": "md5",
      "insertText": "crypto/md5",
      "kind": 8
    },
    {
      "label": "crypto/sha1",
      "documentation": {
        "value": "Package sha1 implements the SHA-1 hash algorithm as defined in RFC 3174.\n\nSHA-1 is cryptographically broken and should not be used for secure\napplications.\n\n[sha1 on pkg.go.dev](https://pkg.go.dev/crypto/sha1)",
        "isTrusted": true
      },
      "detail": "sha1",
      "insertText": "crypto/sha1",
      "kind": 8
    },
    {
      "label": "crypto/sha512",
      "documentation": {
        "value": "Package sha512 implements the SHA-384, SHA-512, SHA-512/224, and SHA-512/256\nhash algorithms as defined in FIPS 180-4.\n\nAll the hash.Hash implementations returned by this package also\nimplement encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to\nmarshal and unmarshal the internal state of the hash.\n\n[sha512 on pkg.go.dev](https://pkg.go.dev/crypto/sha512)",
        "isTrusted": true
      },
      "detail": "sha512",
      "insertText": "crypto/sha512",
      "kind": 8
    },
    {
      "label": "crypto/subtle",
      "documentation": {
        "value": "Package subtle implements functions that are often useful in cryptographic\ncode but require careful thought to use correctly.\n\n[subtle on pkg.go.dev](https://pkg.go.dev/crypto/subtle)",
        "isTrusted": true
      },
      "detail": "subtle",
      "insertText": "crypto/subtle",
      "kind": 8
    },
    {
      "label": "crypto/sha256",
      "documentation": {
        "value": "Package sha256 implements the SHA224 and SHA256 hash algorithms as defined\nin FIPS 180-4.\n\n[sha256 on pkg.go.dev](https://pkg.go.dev/crypto/sha256)",
        "isTrusted": true
      },
      "detail": "sha256",
      "insertText": "crypto/sha256",
      "kind": 8
    },
    {
      "label": "crypto/rsa",
      "documentation": {
        "value": "Package rsa implements RSA encryption as specified in PKCS #1 and RFC 8017.\n\nRSA is a single, fundamental operation that is used in this package to\nimplement either public-key encryption or public-key signatures.\n\nThe original specification for encryption and signatures with RSA is PKCS #1\nand the terms \"RSA encryption\" and \"RSA signatures\" by default refer to\nPKCS #1 version 1.5. However, that specification has flaws and new designs\nshould use version 2, usually called by just OAEP and PSS, where\npossible.\n\nTwo sets of interfaces are included in this package. When a more abstract\ninterface isn't necessary, there are functions for encrypting/decrypting\nwith v1.5/OAEP and signing/verifying with v1.5/PSS. If one needs to abstract\nover the public key primitive, the PrivateKey type implements the\nDecrypter and Signer interfaces from the crypto package.\n\nOperations in this package are implemented using constant-time algorithms,\nexcept for [GenerateKey], [PrivateKey.Precompute], and [PrivateKey.Validate].\nEvery other operation only leaks the bit size of the involved values, which\nall depend on the selected key size.\n\n[rsa on pkg.go.dev](https://pkg.go.dev/crypto/rsa)",
        "isTrusted": true
      },
      "detail": "rsa",
      "insertText": "crypto/rsa",
      "kind": 8
    },
    {
      "label": "regexp/syntax",
      "documentation": {
        "value": "Package syntax parses regular expressions into parse trees and compiles\nparse trees into programs. Most clients of regular expressions will use the\nfacilities of package regexp (such as Compile and Match) instead of this package.\n\n# Syntax\n\nThe regular expression syntax understood by this package when parsing with the Perl flag is as follows.\nParts of the syntax can be disabled by passing alternate flags to Parse.\n\nSingle characters:\n\n```\n\t.              any character, possibly including newline (flag s=true)\n\t[xyz]          character class\n\t[^xyz]         negated character class\n\t\\d             Perl character class\n\t\\D             negated Perl character class\n\t[[:alpha:]]    ASCII character class\n\t[[:^alpha:]]   negated ASCII character class\n\t\\pN            Unicode character class (one-letter name)\n\t\\p{Greek}      Unicode character class\n\t\\PN            negated Unicode character class (one-letter name)\n\t\\P{Greek}      negated Unicode character class\n\n```\nComposites:\n\n```\n\txy             x followed by y\n\tx|y            x or y (prefer x)\n\n```\nRepetitions:\n\n```\n\tx*             zero or more x, prefer more\n\tx+             one or more x, prefer more\n\tx?             zero or one x, prefer one\n\tx{n,m}         n or n+1 or ... or m x, prefer more\n\tx{n,}          n or more x, prefer more\n\tx{n}           exactly n x\n\tx*?            zero or more x, prefer fewer\n\tx+?            one or more x, prefer fewer\n\tx??            zero or one x, prefer zero\n\tx{n,m}?        n or n+1 or ... or m x, prefer fewer\n\tx{n,}?         n or more x, prefer fewer\n\tx{n}?          exactly n x\n\n```\nImplementation restriction: The counting forms x{n,m}, x{n,}, and x{n}\nreject forms that create a minimum or maximum repetition count above 1000.\nUnlimited repetitions are not subject to this restriction.\n\nGrouping:\n\n```\n\t(re)           numbered capturing group (submatch)\n\t(?P\u003cname\u003ere)   named \u0026 numbered capturing group (submatch)\n\t(?\u003cname\u003ere)    named \u0026 numbered capturing group (submatch)\n\t(?:re)         non-capturing group\n\t(?flags)       set flags within current group; non-capturing\n\t(?flags:re)    set flags during re; non-capturing\n\n\tFlag syntax is xyz (set) or -xyz (clear) or xy-z (set xy, clear z). The flags are:\n\n\ti              case-insensitive (default false)\n\tm              multi-line mode: ^ and $ match begin/end line in addition to begin/end text (default false)\n\ts              let . match \\n (default false)\n\tU              ungreedy: swap meaning of x* and x*?, x+ and x+?, etc (default false)\n\n```\nEmpty strings:\n\n```\n\t^              at beginning of text or line (flag m=true)\n\t$              at end of text (like \\z not \\Z) or line (flag m=true)\n\t\\A             at beginning of text\n\t\\b             at ASCII word boundary (\\w on one side and \\W, \\A, or \\z on the other)\n\t\\B             not at ASCII word boundary\n\t\\z             at end of text\n\n```\nEscape sequences:\n\n```\n\t\\a             bell (== \\007)\n\t\\f             form feed (== \\014)\n\t\\t             horizontal tab (== \\011)\n\t\\n             newline (== \\012)\n\t\\r             carriage return (== \\015)\n\t\\v             vertical tab character (== \\013)\n\t\\*             literal *, for any punctuation character *\n\t\\123           octal character code (up to three digits)\n\t\\x7F           hex character code (exactly two digits)\n\t\\x{10FFFF}     hex character code\n\t\\Q...\\E        literal text ... even if ... has punctuation\n\n```\nCharacter class elements:\n\n```\n\tx              single character\n\tA-Z            character range (inclusive)\n\t\\d             Perl character class\n\t[:foo:]        ASCII character class foo\n\t\\p{Foo}        Unicode character class Foo\n\t\\pF            Unicode character class F (one-letter name)\n\n```\nNamed character classes as character class elements:\n\n```\n\t[\\d]           digits (== \\d)\n\t[^\\d]          not digits (== \\D)\n\t[\\D]           not digits (== \\D)\n\t[^\\D]          not not digits (== \\d)\n\t[[:name:]]     named ASCII class inside character class (== [:name:])\n\t[^[:name:]]    named ASCII class inside negated character class (== [:^name:])\n\t[\\p{Name}]     named Unicode property inside character class (== \\p{Name})\n\t[^\\p{Name}]    named Unicode property inside negated character class (== \\P{Name})\n\n```\nPerl character classes (all ASCII-only):\n\n```\n\t\\d             digits (== [0-9])\n\t\\D             not digits (== [^0-9])\n\t\\s             whitespace (== [\\t\\n\\f\\r ])\n\t\\S             not whitespace (== [^\\t\\n\\f\\r ])\n\t\\w             word characters (== [0-9A-Za-z_])\n\t\\W             not word characters (== [^0-9A-Za-z_])\n\n```\nASCII character classes:\n\n```\n\t[[:alnum:]]    alphanumeric (== [0-9A-Za-z])\n\t[[:alpha:]]    alphabetic (== [A-Za-z])\n\t[[:ascii:]]    ASCII (== [\\x00-\\x7F])\n\t[[:blank:]]    blank (== [\\t ])\n\t[[:cntrl:]]    control (== [\\x00-\\x1F\\x7F])\n\t[[:digit:]]    digits (== [0-9])\n\t[[:graph:]]    graphical (== [!-~] == [A-Za-z0-9!\"#$%\u0026'()*+,\\-./:;\u003c=\u003e?@[\\\\\\]^_`{|}~])\n\t[[:lower:]]    lower case (== [a-z])\n\t[[:print:]]    printable (== [ -~] == [ [:graph:]])\n\t[[:punct:]]    punctuation (== [!-/:-@[-`{-~])\n\t[[:space:]]    whitespace (== [\\t\\n\\v\\f\\r ])\n\t[[:upper:]]    upper case (== [A-Z])\n\t[[:word:]]     word characters (== [0-9A-Za-z_])\n\t[[:xdigit:]]   hex digit (== [0-9A-Fa-f])\n\n```\nUnicode character classes are those in unicode.Categories and unicode.Scripts.\n\n[syntax on pkg.go.dev](https://pkg.go.dev/regexp/syntax)",
        "isTrusted": true
      },
      "detail": "syntax",
      "insertText": "regexp/syntax",
      "kind": 8
    },
    {
      "label": "image/draw",
      "documentation": {
        "value": "Package draw provides image composition functions.\n\nSee \"The Go image/draw package\" for an introduction to this package:\nhttps://golang.org/doc/articles/image_draw.html\n\n[draw on pkg.go.dev](https://pkg.go.dev/image/draw)",
        "isTrusted": true
      },
      "detail": "draw",
      "insertText": "image/draw",
      "kind": 8
    },
    {
      "label": "image/color",
      "documentation": {
        "value": "Package color implements a basic color library.\n\n[color on pkg.go.dev](https://pkg.go.dev/image/color)",
        "isTrusted": true
      },
      "detail": "color",
      "insertText": "image/color",
      "kind": 8
    },
    {
      "label": "database/sql",
      "documentation": {
        "value": "Package sql provides a generic interface around SQL (or SQL-like)\ndatabases.\n\nThe sql package must be used in conjunction with a database driver.\nSee https://golang.org/s/sqldrivers for a list of drivers.\n\nDrivers that do not support context cancellation will not return until\nafter the query is completed.\n\nFor usage examples, see the wiki page at\nhttps://golang.org/s/sqlwiki.\n\n[sql on pkg.go.dev](https://pkg.go.dev/database/sql)",
        "isTrusted": true
      },
      "detail": "sql",
      "insertText": "database/sql",
      "kind": 8
    },
    {
      "label": "image/gif",
      "documentation": {
        "value": "Package gif implements a GIF image decoder and encoder.\n\nThe GIF specification is at https://www.w3.org/Graphics/GIF/spec-gif89a.txt.\n\n[gif on pkg.go.dev](https://pkg.go.dev/image/gif)",
        "isTrusted": true
      },
      "detail": "gif",
      "insertText": "image/gif",
      "kind": 8
    },
    {
      "label": "image/png",
      "documentation": {
        "value": "Package png implements a PNG image decoder and encoder.\n\nThe PNG specification is at https://www.w3.org/TR/PNG/.\n\n[png on pkg.go.dev](https://pkg.go.dev/image/png)",
        "isTrusted": true
      },
      "detail": "png",
      "insertText": "image/png",
      "kind": 8
    },
    {
      "label": "image/jpeg",
      "documentation": {
        "value": "Package jpeg implements a JPEG image decoder and encoder.\n\nJPEG is defined in ITU-T T.81: https://www.w3.org/Graphics/JPEG/itu-t81.pdf.\n\n[jpeg on pkg.go.dev](https://pkg.go.dev/image/jpeg)",
        "isTrusted": true
      },
      "detail": "jpeg",
      "insertText": "image/jpeg",
      "kind": 8
    },
    {
      "label": "index/suffixarray",
      "documentation": {
        "value": "Gen generates sais2.go by duplicating functions in sais.go\nusing different input types.\nSee the comment at the top of sais.go for details.\n\n[main on pkg.go.dev](https://pkg.go.dev/index/suffixarray)",
        "isTrusted": true
      },
      "detail": "main",
      "insertText": "index/suffixarray",
      "kind": 8
    },
    {
      "label": "io/ioutil",
      "documentation": {
        "value": "Package ioutil implements some I/O utility functions.\n\nDeprecated: As of Go 1.16, the same functionality is now provided\nby package [io] or package [os], and those implementations\nshould be preferred in new code.\nSee the specific function documentation for details.\n\n[ioutil on pkg.go.dev](https://pkg.go.dev/io/ioutil)",
        "isTrusted": true
      },
      "detail": "ioutil",
      "insertText": "io/ioutil",
      "kind": 8
    },
    {
      "label": "io/fs",
      "documentation": {
        "value": "Package fs defines basic interfaces to a file system.\nA file system can be provided by the host operating system\nbut also by other packages.\n\nSee the [testing/fstest] package for support with testing\nimplementations of file systems.\n\n[fs on pkg.go.dev](https://pkg.go.dev/io/fs)",
        "isTrusted": true
      },
      "detail": "fs",
      "insertText": "io/fs",
      "kind": 8
    },
    {
      "label": "log/syslog",
      "documentation": {
        "value": "Package syslog provides a simple interface to the system log\nservice. It can send messages to the syslog daemon using UNIX\ndomain sockets, UDP or TCP.\n\nOnly one call to Dial is necessary. On write failures,\nthe syslog client will attempt to reconnect to the server\nand write again.\n\nThe syslog package is frozen and is not accepting new features.\nSome external packages provide more functionality. See:\n\n```\n\thttps://godoc.org/?q=syslog\n\n```\n\n[syslog on pkg.go.dev](https://pkg.go.dev/log/syslog)",
        "isTrusted": true
      },
      "detail": "syslog",
      "insertText": "log/syslog",
      "kind": 8
    },
    {
      "label": "log/slog",
      "documentation": {
        "value": "Package slog provides structured logging,\nin which log records include a message,\na severity level, and various other attributes\nexpressed as key-value pairs.\n\nIt defines a type, [Logger],\nwhich provides several methods (such as [Logger.Info] and [Logger.Error])\nfor reporting events of interest.\n\nEach Logger is associated with a [Handler].\nA Logger output method creates a [Record] from the method arguments\nand passes it to the Handler, which decides how to handle it.\nThere is a default Logger accessible through top-level functions\n(such as [Info] and [Error]) that call the corresponding Logger methods.\n\nA log record consists of a time, a level, a message, and a set of key-value\npairs, where the keys are strings and the values may be of any type.\nAs an example,\n\n```\n\tslog.Info(\"hello\", \"count\", 3)\n\n```\ncreates a record containing the time of the call,\na level of Info, the message \"hello\", and a single\npair with key \"count\" and value 3.\n\nThe [Info] top-level function calls the [Logger.Info] method on the default Logger.\nIn addition to [Logger.Info], there are methods for Debug, Warn and Error levels.\nBesides these convenience methods for common levels,\nthere is also a [Logger.Log] method which takes the level as an argument.\nEach of these methods has a corresponding top-level function that uses the\ndefault logger.\n\nThe default handler formats the log record's message, time, level, and attributes\nas a string and passes it to the [log] package.\n\n```\n\t2022/11/08 15:28:26 INFO hello count=3\n\n```\nFor more control over the output format, create a logger with a different handler.\nThis statement uses [New] to create a new logger with a [TextHandler]\nthat writes structured records in text form to standard error:\n\n```\n\tlogger := slog.New(slog.NewTextHandler(os.Stderr, nil))\n\n```\n[TextHandler] output is a sequence of key=value pairs, easily and unambiguously\nparsed by machine. This statement:\n\n```\n\tlogger.Info(\"hello\", \"count\", 3)\n\n```\nproduces this output:\n\n```\n\ttime=2022-11-08T15:28:26.000-05:00 level=INFO msg=hello count=3\n\n```\nThe package also provides [JSONHandler], whose output is line-delimited JSON:\n\n```\n\tlogger := slog.New(slog.NewJSONHandler(os.Stdout, nil))\n\tlogger.Info(\"hello\", \"count\", 3)\n\n```\nproduces this output:\n\n```\n\t{\"time\":\"2022-11-08T15:28:26.000000000-05:00\",\"level\":\"INFO\",\"msg\":\"hello\",\"count\":3}\n\n```\nBoth [TextHandler] and [JSONHandler] can be configured with [HandlerOptions].\nThere are options for setting the minimum level (see Levels, below),\ndisplaying the source file and line of the log call, and\nmodifying attributes before they are logged.\n\nSetting a logger as the default with\n\n```\n\tslog.SetDefault(logger)\n\n```\nwill cause the top-level functions like [Info] to use it.\n[SetDefault] also updates the default logger used by the [log] package,\nso that existing applications that use [log.Printf] and related functions\nwill send log records to the logger's handler without needing to be rewritten.\n\nSome attributes are common to many log calls.\nFor example, you may wish to include the URL or trace identifier of a server request\nwith all log events arising from the request.\nRather than repeat the attribute with every log call, you can use [Logger.With]\nto construct a new Logger containing the attributes:\n\n```\n\tlogger2 := logger.With(\"url\", r.URL)\n\n```\nThe arguments to With are the same key-value pairs used in [Logger.Info].\nThe result is a new Logger with the same handler as the original, but additional\nattributes that will appear in the output of every call.\n\n# Levels\n\nA [Level] is an integer representing the importance or severity of a log event.\nThe higher the level, the more severe the event.\nThis package defines constants for the most common levels,\nbut any int can be used as a level.\n\nIn an application, you may wish to log messages only at a certain level or greater.\nOne common configuration is to log messages at Info or higher levels,\nsuppressing debug logging until it is needed.\nThe built-in handlers can be configured with the minimum level to output by\nsetting [HandlerOptions.Level].\nThe program's `main` function typically does this.\nThe default value is LevelInfo.\n\nSetting the [HandlerOptions.Level] field to a [Level] value\nfixes the handler's minimum level throughout its lifetime.\nSetting it to a [LevelVar] allows the level to be varied dynamically.\nA LevelVar holds a Level and is safe to read or write from multiple\ngoroutines.\nTo vary the level dynamically for an entire program, first initialize\na global LevelVar:\n\n```\n\tvar programLevel = new(slog.LevelVar) // Info by default\n\n```\nThen use the LevelVar to construct a handler, and make it the default:\n\n```\n\th := slog.NewJSONHandler(os.Stderr, \u0026slog.HandlerOptions{Level: programLevel})\n\tslog.SetDefault(slog.New(h))\n\n```\nNow the program can change its logging level with a single statement:\n\n```\n\tprogramLevel.Set(slog.LevelDebug)\n\n```\n# Groups\n\nAttributes can be collected into groups.\nA group has a name that is used to qualify the names of its attributes.\nHow this qualification is displayed depends on the handler.\n[TextHandler] separates the group and attribute names with a dot.\n[JSONHandler] treats each group as a separate JSON object, with the group name as the key.\n\nUse [Group] to create a Group attribute from a name and a list of key-value pairs:\n\n```\n\tslog.Group(\"request\",\n\t    \"method\", r.Method,\n\t    \"url\", r.URL)\n\n```\nTextHandler would display this group as\n\n```\n\trequest.method=GET request.url=http://example.com\n\n```\nJSONHandler would display it as\n\n```\n\t\"request\":{\"method\":\"GET\",\"url\":\"http://example.com\"}\n\n```\nUse [Logger.WithGroup] to qualify all of a Logger's output\nwith a group name. Calling WithGroup on a Logger results in a\nnew Logger with the same Handler as the original, but with all\nits attributes qualified by the group name.\n\nThis can help prevent duplicate attribute keys in large systems,\nwhere subsystems might use the same keys.\nPass each subsystem a different Logger with its own group name so that\npotential duplicates are qualified:\n\n```\n\tlogger := slog.Default().With(\"id\", systemID)\n\tparserLogger := logger.WithGroup(\"parser\")\n\tparseInput(input, parserLogger)\n\n```\nWhen parseInput logs with parserLogger, its keys will be qualified with \"parser\",\nso even if it uses the common key \"id\", the log line will have distinct keys.\n\n# Contexts\n\nSome handlers may wish to include information from the [context.Context] that is\navailable at the call site. One example of such information\nis the identifier for the current span when tracing is enabled.\n\nThe [Logger.Log] and [Logger.LogAttrs] methods take a context as a first\nargument, as do their corresponding top-level functions.\n\nAlthough the convenience methods on Logger (Info and so on) and the\ncorresponding top-level functions do not take a context, the alternatives ending\nin \"Context\" do. For example,\n\n```\n\tslog.InfoContext(ctx, \"message\")\n\n```\nIt is recommended to pass a context to an output method if one is available.\n\n# Attrs and Values\n\nAn [Attr] is a key-value pair. The Logger output methods accept Attrs as well as\nalternating keys and values. The statement\n\n```\n\tslog.Info(\"hello\", slog.Int(\"count\", 3))\n\n```\nbehaves the same as\n\n```\n\tslog.Info(\"hello\", \"count\", 3)\n\n```\nThere are convenience constructors for [Attr] such as [Int], [String], and [Bool]\nfor common types, as well as the function [Any] for constructing Attrs of any\ntype.\n\nThe value part of an Attr is a type called [Value].\nLike an [any], a Value can hold any Go value,\nbut it can represent typical values, including all numbers and strings,\nwithout an allocation.\n\nFor the most efficient log output, use [Logger.LogAttrs].\nIt is similar to [Logger.Log] but accepts only Attrs, not alternating\nkeys and values; this allows it, too, to avoid allocation.\n\nThe call\n\n```\n\tlogger.LogAttrs(ctx, slog.LevelInfo, \"hello\", slog.Int(\"count\", 3))\n\n```\nis the most efficient way to achieve the same output as\n\n```\n\tslog.InfoContext(ctx, \"hello\", \"count\", 3)\n\n```\n# Customizing a type's logging behavior\n\nIf a type implements the [LogValuer] interface, the [Value] returned from its LogValue\nmethod is used for logging. You can use this to control how values of the type\nappear in logs. For example, you can redact secret information like passwords,\nor gather a struct's fields in a Group. See the examples under [LogValuer] for\ndetails.\n\nA LogValue method may return a Value that itself implements [LogValuer]. The [Value.Resolve]\nmethod handles these cases carefully, avoiding infinite loops and unbounded recursion.\nHandler authors and others may wish to use [Value.Resolve] instead of calling LogValue directly.\n\n# Wrapping output methods\n\nThe logger functions use reflection over the call stack to find the file name\nand line number of the logging call within the application. This can produce\nincorrect source information for functions that wrap slog. For instance, if you\ndefine this function in file mylog.go:\n\n```\n\tfunc Infof(logger *slog.Logger, format string, args ...any) {\n\t    logger.Info(fmt.Sprintf(format, args...))\n\t}\n\n```\nand you call it like this in main.go:\n\n```\n\tInfof(slog.Default(), \"hello, %s\", \"world\")\n\n```\nthen slog will report the source file as mylog.go, not main.go.\n\nA correct implementation of Infof will obtain the source location\n(pc) and pass it to NewRecord.\nThe Infof function in the package-level example called \"wrapping\"\ndemonstrates how to do this.\n\n# Working with Records\n\nSometimes a Handler will need to modify a Record\nbefore passing it on to another Handler or backend.\nA Record contains a mixture of simple public fields (e.g. Time, Level, Message)\nand hidden fields that refer to state (such as attributes) indirectly. This\nmeans that modifying a simple copy of a Record (e.g. by calling\n[Record.Add] or [Record.AddAttrs] to add attributes)\nmay have unexpected effects on the original.\nBefore modifying a Record, use [Record.Clone] to\ncreate a copy that shares no state with the original,\nor create a new Record with [NewRecord]\nand build up its Attrs by traversing the old ones with [Record.Attrs].\n\n# Performance considerations\n\nIf profiling your application demonstrates that logging is taking significant time,\nthe following suggestions may help.\n\nIf many log lines have a common attribute, use [Logger.With] to create a Logger with\nthat attribute. The built-in handlers will format that attribute only once, at the\ncall to [Logger.With]. The [Handler] interface is designed to allow that optimization,\nand a well-written Handler should take advantage of it.\n\nThe arguments to a log call are always evaluated, even if the log event is discarded.\nIf possible, defer computation so that it happens only if the value is actually logged.\nFor example, consider the call\n\n```\n\tslog.Info(\"starting request\", \"url\", r.URL.String())  // may compute String unnecessarily\n\n```\nThe URL.String method will be called even if the logger discards Info-level events.\nInstead, pass the URL directly:\n\n```\n\tslog.Info(\"starting request\", \"url\", \u0026r.URL) // calls URL.String only if needed\n\n```\nThe built-in [TextHandler] will call its String method, but only\nif the log event is enabled.\nAvoiding the call to String also preserves the structure of the underlying value.\nFor example [JSONHandler] emits the components of the parsed URL as a JSON object.\nIf you want to avoid eagerly paying the cost of the String call\nwithout causing the handler to potentially inspect the structure of the value,\nwrap the value in a fmt.Stringer implementation that hides its Marshal methods.\n\nYou can also use the [LogValuer] interface to avoid unnecessary work in disabled log\ncalls. Say you need to log some expensive value:\n\n```\n\tslog.Debug(\"frobbing\", \"value\", computeExpensiveValue(arg))\n\n```\nEven if this line is disabled, computeExpensiveValue will be called.\nTo avoid that, define a type implementing LogValuer:\n\n```\n\ttype expensive struct { arg int }\n\n\tfunc (e expensive) LogValue() slog.Value {\n\t    return slog.AnyValue(computeExpensiveValue(e.arg))\n\t}\n\n```\nThen use a value of that type in log calls:\n\n```\n\tslog.Debug(\"frobbing\", \"value\", expensive{arg})\n\n```\nNow computeExpensiveValue will only be called when the line is enabled.\n\nThe built-in handlers acquire a lock before calling [io.Writer.Write]\nto ensure that each record is written in one piece. User-defined\nhandlers are responsible for their own locking.\n\n# Writing a handler\n\nFor a guide to writing a custom handler, see https://golang.org/s/slog-handler-guide.\n\n[slog on pkg.go.dev](https://pkg.go.dev/log/slog)",
        "isTrusted": true
      },
      "detail": "slog",
      "insertText": "log/slog",
      "kind": 8
    },
    {
      "label": "math/bits",
      "documentation": {
        "value": "Package bits implements bit counting and manipulation\nfunctions for the predeclared unsigned integer types.\n\nFunctions in this package may be implemented directly by\nthe compiler, for better performance. For those functions\nthe code in this package will not be used. Which\nfunctions are implemented by the compiler depends on the\narchitecture and the Go release.\n\n[bits on pkg.go.dev](https://pkg.go.dev/math/bits)",
        "isTrusted": true
      },
      "detail": "bits",
      "insertText": "math/bits",
      "kind": 8
    },
    {
      "label": "math/cmplx",
      "documentation": {
        "value": "Package cmplx provides basic constants and mathematical functions for\ncomplex numbers. Special case handling conforms to the C99 standard\nAnnex G IEC 60559-compatible complex arithmetic.\n\n[cmplx on pkg.go.dev](https://pkg.go.dev/math/cmplx)",
        "isTrusted": true
      },
      "detail": "cmplx",
      "insertText": "math/cmplx",
      "kind": 8
    },
    {
      "label": "crypto/x509",
      "documentation": {
        "value": "Package x509 implements a subset of the X.509 standard.\n\nIt allows parsing and generating certificates, certificate signing\nrequests, certificate revocation lists, and encoded public and private keys.\nIt provides a certificate verifier, complete with a chain builder.\n\nThe package targets the X.509 technical profile defined by the IETF (RFC\n2459/3280/5280), and as further restricted by the CA/Browser Forum Baseline\nRequirements. There is minimal support for features outside of these\nprofiles, as the primary goal of the package is to provide compatibility\nwith the publicly trusted TLS certificate ecosystem and its policies and\nconstraints.\n\nOn macOS and Windows, certificate verification is handled by system APIs, but\nthe package aims to apply consistent validation rules across operating\nsystems.\n\n[x509 on pkg.go.dev](https://pkg.go.dev/crypto/x509)",
        "isTrusted": true
      },
      "detail": "x509",
      "insertText": "crypto/x509",
      "kind": 8
    },
    {
      "label": "math/big",
      "documentation": {
        "value": "Package big implements arbitrary-precision arithmetic (big numbers).\nThe following numeric types are supported:\n\n```\n\tInt    signed integers\n\tRat    rational numbers\n\tFloat  floating-point numbers\n\n```\nThe zero value for an [Int], [Rat], or [Float] correspond to 0. Thus, new\nvalues can be declared in the usual ways and denote 0 without further\ninitialization:\n\n```\n\tvar x Int        // \u0026x is an *Int of value 0\n\tvar r = \u0026Rat{}   // r is a *Rat of value 0\n\ty := new(Float)  // y is a *Float of value 0\n\n```\nAlternatively, new values can be allocated and initialized with factory\nfunctions of the form:\n\n```\n\tfunc NewT(v V) *T\n\n```\nFor instance, [NewInt](x) returns an *[Int] set to the value of the int64\nargument x, [NewRat](a, b) returns a *[Rat] set to the fraction a/b where\na and b are int64 values, and [NewFloat](f) returns a *[Float] initialized\nto the float64 argument f. More flexibility is provided with explicit\nsetters, for instance:\n\n```\n\tvar z1 Int\n\tz1.SetUint64(123)                 // z1 := 123\n\tz2 := new(Rat).SetFloat64(1.25)   // z2 := 5/4\n\tz3 := new(Float).SetInt(z1)       // z3 := 123.0\n\n```\nSetters, numeric operations and predicates are represented as methods of\nthe form:\n\n```\n\tfunc (z *T) SetV(v V) *T          // z = v\n\tfunc (z *T) Unary(x *T) *T        // z = unary x\n\tfunc (z *T) Binary(x, y *T) *T    // z = x binary y\n\tfunc (x *T) Pred() P              // p = pred(x)\n\n```\nwith T one of [Int], [Rat], or [Float]. For unary and binary operations, the\nresult is the receiver (usually named z in that case; see below); if it\nis one of the operands x or y it may be safely overwritten (and its memory\nreused).\n\nArithmetic expressions are typically written as a sequence of individual\nmethod calls, with each call corresponding to an operation. The receiver\ndenotes the result and the method arguments are the operation's operands.\nFor instance, given three *Int values a, b and c, the invocation\n\n```\n\tc.Add(a, b)\n\n```\ncomputes the sum a + b and stores the result in c, overwriting whatever\nvalue was held in c before. Unless specified otherwise, operations permit\naliasing of parameters, so it is perfectly ok to write\n\n```\n\tsum.Add(sum, x)\n\n```\nto accumulate values x in a sum.\n\n(By always passing in a result value via the receiver, memory use can be\nmuch better controlled. Instead of having to allocate new memory for each\nresult, an operation can reuse the space allocated for the result value,\nand overwrite that value with the new result in the process.)\n\nNotational convention: Incoming method parameters (including the receiver)\nare named consistently in the API to clarify their use. Incoming operands\nare usually named x, y, a, b, and so on, but never z. A parameter specifying\nthe result is named z (typically the receiver).\n\nFor instance, the arguments for (*Int).Add are named x and y, and because\nthe receiver specifies the result destination, it is called z:\n\n```\n\tfunc (z *Int) Add(x, y *Int) *Int\n\n```\nMethods of this form typically return the incoming receiver as well, to\nenable simple call chaining.\n\nMethods which don't require a result value to be passed in (for instance,\n[Int.Sign]), simply return the result. In this case, the receiver is typically\nthe first operand, named x:\n\n```\n\tfunc (x *Int) Sign() int\n\n```\nVarious methods support conversions between strings and corresponding\nnumeric values, and vice versa: *[Int], *[Rat], and *[Float] values implement\nthe Stringer interface for a (default) string representation of the value,\nbut also provide SetString methods to initialize a value from a string in\na variety of supported formats (see the respective SetString documentation).\n\nFinally, *[Int], *[Rat], and *[Float] satisfy [fmt.Scanner] for scanning\nand (except for *[Rat]) the Formatter interface for formatted printing.\n\n[big on pkg.go.dev](https://pkg.go.dev/math/big)",
        "isTrusted": true
      },
      "detail": "big",
      "insertText": "math/big",
      "kind": 8
    },
    {
      "label": "mime/quotedprintable",
      "documentation": {
        "value": "Package quotedprintable implements quoted-printable encoding as specified by\nRFC 2045.\n\n[quotedprintable on pkg.go.dev](https://pkg.go.dev/mime/quotedprintable)",
        "isTrusted": true
      },
      "detail": "quotedprintable",
      "insertText": "mime/quotedprintable",
      "kind": 8
    },
    {
      "label": "math/rand",
      "documentation": {
        "value": "Package rand implements pseudo-random number generators suitable for tasks\nsuch as simulation, but it should not be used for security-sensitive work.\n\nRandom numbers are generated by a [Source], usually wrapped in a [Rand].\nBoth types should be used by a single goroutine at a time: sharing among\nmultiple goroutines requires some kind of synchronization.\n\nTop-level functions, such as [Float64] and [Int],\nare safe for concurrent use by multiple goroutines.\n\nThis package's outputs might be easily predictable regardless of how it's\nseeded. For random numbers suitable for security-sensitive work, see the\ncrypto/rand package.\n\n[rand on pkg.go.dev](https://pkg.go.dev/math/rand)",
        "isTrusted": true
      },
      "detail": "rand",
      "insertText": "math/rand",
      "kind": 8
    },
    {
      "label": "mime/multipart",
      "documentation": {
        "value": "Package multipart implements MIME multipart parsing, as defined in RFC\n2046.\n\nThe implementation is sufficient for HTTP (RFC 2388) and the multipart\nbodies generated by popular browsers.\n\n# Limits\n\nTo protect against malicious inputs, this package sets limits on the size\nof the MIME data it processes.\n\nReader.NextPart and Reader.NextRawPart limit the number of headers in a\npart to 10000 and Reader.ReadForm limits the total number of headers in all\nFileHeaders to 10000.\nThese limits may be adjusted with the GODEBUG=multipartmaxheaders=\u003cvalues\u003e\nsetting.\n\nReader.ReadForm further limits the number of parts in a form to 1000.\nThis limit may be adjusted with the GODEBUG=multipartmaxparts=\u003cvalue\u003e\nsetting.\n\n[multipart on pkg.go.dev](https://pkg.go.dev/mime/multipart)",
        "isTrusted": true
      },
      "detail": "multipart",
      "insertText": "mime/multipart",
      "kind": 8
    },
    {
      "label": "net/mail",
      "documentation": {
        "value": "Package mail implements parsing of mail messages.\n\nFor the most part, this package follows the syntax as specified by RFC 5322 and\nextended by RFC 6532.\nNotable divergences:\n```\n  - Obsolete address formats are not parsed, including addresses with\n    embedded route information.\n  - The full range of spacing (the CFWS syntax element) is not supported,\n    such as breaking addresses across lines.\n  - No unicode normalization is performed.\n  - The special characters ()[]:;@\\, are allowed to appear unquoted in names.\n  - A leading From line is permitted, as in mbox format (RFC 4155).\n\n```\n\n[mail on pkg.go.dev](https://pkg.go.dev/net/mail)",
        "isTrusted": true
      },
      "detail": "mail",
      "insertText": "net/mail",
      "kind": 8
    },
    {
      "label": "net/netip",
      "documentation": {
        "value": "Package netip defines an IP address type that's a small value type.\nBuilding on that [Addr] type, the package also defines [AddrPort] (an\nIP address and a port) and [Prefix] (an IP address and a bit length\nprefix).\n\nCompared to the [net.IP] type, [Addr] type takes less memory, is immutable,\nand is comparable (supports == and being a map key).\n\n[netip on pkg.go.dev](https://pkg.go.dev/net/netip)",
        "isTrusted": true
      },
      "detail": "netip",
      "insertText": "net/netip",
      "kind": 8
    },
    {
      "label": "net/http",
      "documentation": {
        "value": "Package http provides HTTP client and server implementations.\n\n[Get], [Head], [Post], and [PostForm] make HTTP (or HTTPS) requests:\n\n```\n\tresp, err := http.Get(\"http://example.com/\")\n\t...\n\tresp, err := http.Post(\"http://example.com/upload\", \"image/jpeg\", \u0026buf)\n\t...\n\tresp, err := http.PostForm(\"http://example.com/form\",\n\t\turl.Values{\"key\": {\"Value\"}, \"id\": {\"123\"}})\n\n```\nThe caller must close the response body when finished with it:\n\n```\n\tresp, err := http.Get(\"http://example.com/\")\n\tif err != nil {\n\t\t// handle error\n\t}\n\tdefer resp.Body.Close()\n\tbody, err := io.ReadAll(resp.Body)\n\t// ...\n\n```\n# Clients and Transports\n\nFor control over HTTP client headers, redirect policy, and other\nsettings, create a [Client]:\n\n```\n\tclient := \u0026http.Client{\n\t\tCheckRedirect: redirectPolicyFunc,\n\t}\n\n\tresp, err := client.Get(\"http://example.com\")\n\t// ...\n\n\treq, err := http.NewRequest(\"GET\", \"http://example.com\", nil)\n\t// ...\n\treq.Header.Add(\"If-None-Match\", `W/\"wyzzy\"`)\n\tresp, err := client.Do(req)\n\t// ...\n\n```\nFor control over proxies, TLS configuration, keep-alives,\ncompression, and other settings, create a [Transport]:\n\n```\n\ttr := \u0026http.Transport{\n\t\tMaxIdleConns:       10,\n\t\tIdleConnTimeout:    30 * time.Second,\n\t\tDisableCompression: true,\n\t}\n\tclient := \u0026http.Client{Transport: tr}\n\tresp, err := client.Get(\"https://example.com\")\n\n```\nClients and Transports are safe for concurrent use by multiple\ngoroutines and for efficiency should only be created once and re-used.\n\n# Servers\n\nListenAndServe starts an HTTP server with a given address and handler.\nThe handler is usually nil, which means to use [DefaultServeMux].\n[Handle] and [HandleFunc] add handlers to [DefaultServeMux]:\n\n```\n\thttp.Handle(\"/foo\", fooHandler)\n\n\thttp.HandleFunc(\"/bar\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintf(w, \"Hello, %q\", html.EscapeString(r.URL.Path))\n\t})\n\n\tlog.Fatal(http.ListenAndServe(\":8080\", nil))\n\n```\nMore control over the server's behavior is available by creating a\ncustom Server:\n\n```\n\ts := \u0026http.Server{\n\t\tAddr:           \":8080\",\n\t\tHandler:        myHandler,\n\t\tReadTimeout:    10 * time.Second,\n\t\tWriteTimeout:   10 * time.Second,\n\t\tMaxHeaderBytes: 1 \u003c\u003c 20,\n\t}\n\tlog.Fatal(s.ListenAndServe())\n\n```\n# HTTP/2\n\nStarting with Go 1.6, the http package has transparent support for the\nHTTP/2 protocol when using HTTPS. Programs that must disable HTTP/2\ncan do so by setting [Transport.TLSNextProto] (for clients) or\n[Server.TLSNextProto] (for servers) to a non-nil, empty\nmap. Alternatively, the following GODEBUG settings are\ncurrently supported:\n\n```\n\tGODEBUG=http2client=0  # disable HTTP/2 client support\n\tGODEBUG=http2server=0  # disable HTTP/2 server support\n\tGODEBUG=http2debug=1   # enable verbose HTTP/2 debug logs\n\tGODEBUG=http2debug=2   # ... even more verbose, with frame dumps\n\n```\nPlease report any issues before disabling HTTP/2 support: https://golang.org/s/http2bug\n\nThe http package's [Transport] and [Server] both automatically enable\nHTTP/2 support for simple configurations. To enable HTTP/2 for more\ncomplex configurations, to use lower-level HTTP/2 features, or to use\na newer version of Go's http2 package, import \"golang.org/x/net/http2\"\ndirectly and use its ConfigureTransport and/or ConfigureServer\nfunctions. Manually configuring HTTP/2 via the golang.org/x/net/http2\npackage takes precedence over the net/http package's built-in HTTP/2\nsupport.\n\n[http on pkg.go.dev](https://pkg.go.dev/net/http)",
        "isTrusted": true
      },
      "detail": "http",
      "insertText": "net/http",
      "kind": 8
    },
    {
      "label": "net/smtp",
      "documentation": {
        "value": "Package smtp implements the Simple Mail Transfer Protocol as defined in RFC 5321.\nIt also implements the following extensions:\n\n```\n\t8BITMIME  RFC 1652\n\tAUTH      RFC 2554\n\tSTARTTLS  RFC 3207\n\n```\nAdditional extensions may be handled by clients.\n\nThe smtp package is frozen and is not accepting new features.\nSome external packages provide more functionality. See:\n\n```\n\thttps://godoc.org/?q=smtp\n\n```\n\n[smtp on pkg.go.dev](https://pkg.go.dev/net/smtp)",
        "isTrusted": true
      },
      "detail": "smtp",
      "insertText": "net/smtp",
      "kind": 8
    },
    {
      "label": "net/rpc",
      "documentation": {
        "value": "Package rpc provides access to the exported methods of an object across a\nnetwork or other I/O connection.  A server registers an object, making it visible\nas a service with the name of the type of the object.  After registration, exported\nmethods of the object will be accessible remotely.  A server may register multiple\nobjects (services) of different types but it is an error to register multiple\nobjects of the same type.\n\nOnly methods that satisfy these criteria will be made available for remote access;\nother methods will be ignored:\n\n```\n  - the method's type is exported.\n  - the method is exported.\n  - the method has two arguments, both exported (or builtin) types.\n  - the method's second argument is a pointer.\n  - the method has return type error.\n\n```\nIn effect, the method must look schematically like\n\n```\n\tfunc (t *T) MethodName(argType T1, replyType *T2) error\n\n```\nwhere T1 and T2 can be marshaled by encoding/gob.\nThese requirements apply even if a different codec is used.\n(In the future, these requirements may soften for custom codecs.)\n\nThe method's first argument represents the arguments provided by the caller; the\nsecond argument represents the result parameters to be returned to the caller.\nThe method's return value, if non-nil, is passed back as a string that the client\nsees as if created by [errors.New].  If an error is returned, the reply parameter\nwill not be sent back to the client.\n\nThe server may handle requests on a single connection by calling [ServeConn].  More\ntypically it will create a network listener and call [Accept] or, for an HTTP\nlistener, [HandleHTTP] and [http.Serve].\n\nA client wishing to use the service establishes a connection and then invokes\n[NewClient] on the connection.  The convenience function [Dial] ([DialHTTP]) performs\nboth steps for a raw network connection (an HTTP connection).  The resulting\n[Client] object has two methods, [Call] and Go, that specify the service and method to\ncall, a pointer containing the arguments, and a pointer to receive the result\nparameters.\n\nThe Call method waits for the remote call to complete while the Go method\nlaunches the call asynchronously and signals completion using the Call\nstructure's Done channel.\n\nUnless an explicit codec is set up, package [encoding/gob] is used to\ntransport the data.\n\nHere is a simple example.  A server wishes to export an object of type Arith:\n\n```\n\tpackage server\n\n\timport \"errors\"\n\n\ttype Args struct {\n\t\tA, B int\n\t}\n\n\ttype Quotient struct {\n\t\tQuo, Rem int\n\t}\n\n\ttype Arith int\n\n\tfunc (t *Arith) Multiply(args *Args, reply *int) error {\n\t\t*reply = args.A * args.B\n\t\treturn nil\n\t}\n\n\tfunc (t *Arith) Divide(args *Args, quo *Quotient) error {\n\t\tif args.B == 0 {\n\t\t\treturn errors.New(\"divide by zero\")\n\t\t}\n\t\tquo.Quo = args.A / args.B\n\t\tquo.Rem = args.A % args.B\n\t\treturn nil\n\t}\n\n```\nThe server calls (for HTTP service):\n\n```\n\tarith := new(Arith)\n\trpc.Register(arith)\n\trpc.HandleHTTP()\n\tl, err := net.Listen(\"tcp\", \":1234\")\n\tif err != nil {\n\t\tlog.Fatal(\"listen error:\", err)\n\t}\n\tgo http.Serve(l, nil)\n\n```\nAt this point, clients can see a service \"Arith\" with methods \"Arith.Multiply\" and\n\"Arith.Divide\".  To invoke one, a client first dials the server:\n\n```\n\tclient, err := rpc.DialHTTP(\"tcp\", serverAddress + \":1234\")\n\tif err != nil {\n\t\tlog.Fatal(\"dialing:\", err)\n\t}\n\n```\nThen it can make a remote call:\n\n```\n\t// Synchronous call\n\targs := \u0026server.Args{7,8}\n\tvar reply int\n\terr = client.Call(\"Arith.Multiply\", args, \u0026reply)\n\tif err != nil {\n\t\tlog.Fatal(\"arith error:\", err)\n\t}\n\tfmt.Printf(\"Arith: %d*%d=%d\", args.A, args.B, reply)\n\n```\nor\n\n```\n\t// Asynchronous call\n\tquotient := new(Quotient)\n\tdivCall := client.Go(\"Arith.Divide\", args, quotient, nil)\n\treplyCall := \u003c-divCall.Done\t// will be equal to divCall\n\t// check errors, print, etc.\n\n```\nA server implementation will often provide a simple, type-safe wrapper for the\nclient.\n\nThe net/rpc package is frozen and is not accepting new features.\n\n[rpc on pkg.go.dev](https://pkg.go.dev/net/rpc)",
        "isTrusted": true
      },
      "detail": "rpc",
      "insertText": "net/rpc",
      "kind": 8
    },
    {
      "label": "net/textproto",
      "documentation": {
        "value": "Package textproto implements generic support for text-based request/response\nprotocols in the style of HTTP, NNTP, and SMTP.\n\nThe package provides:\n\n[Error], which represents a numeric error response from\na server.\n\n[Pipeline], to manage pipelined requests and responses\nin a client.\n\n[Reader], to read numeric response code lines,\nkey: value headers, lines wrapped with leading spaces\non continuation lines, and whole text blocks ending\nwith a dot on a line by itself.\n\n[Writer], to write dot-encoded text blocks.\n\n[Conn], a convenient packaging of [Reader], [Writer], and [Pipeline] for use\nwith a single network connection.\n\n[textproto on pkg.go.dev](https://pkg.go.dev/net/textproto)",
        "isTrusted": true
      },
      "detail": "textproto",
      "insertText": "net/textproto",
      "kind": 8
    },
    {
      "label": "net/url",
      "documentation": {
        "value": "Package url parses URLs and implements query escaping.\n\n[url on pkg.go.dev](https://pkg.go.dev/net/url)",
        "isTrusted": true
      },
      "detail": "url",
      "insertText": "net/url",
      "kind": 8
    },
    {
      "label": "os/signal",
      "documentation": {
        "value": "Package signal implements access to incoming signals.\n\nSignals are primarily used on Unix-like systems. For the use of this\npackage on Windows and Plan 9, see below.\n\n# Types of signals\n\nThe signals SIGKILL and SIGSTOP may not be caught by a program, and\ntherefore cannot be affected by this package.\n\nSynchronous signals are signals triggered by errors in program\nexecution: SIGBUS, SIGFPE, and SIGSEGV. These are only considered\nsynchronous when caused by program execution, not when sent using\n[os.Process.Kill] or the kill program or some similar mechanism. In\ngeneral, except as discussed below, Go programs will convert a\nsynchronous signal into a run-time panic.\n\nThe remaining signals are asynchronous signals. They are not\ntriggered by program errors, but are instead sent from the kernel or\nfrom some other program.\n\nOf the asynchronous signals, the SIGHUP signal is sent when a program\nloses its controlling terminal. The SIGINT signal is sent when the\nuser at the controlling terminal presses the interrupt character,\nwhich by default is ^C (Control-C). The SIGQUIT signal is sent when\nthe user at the controlling terminal presses the quit character, which\nby default is ^\\ (Control-Backslash). In general you can cause a\nprogram to simply exit by pressing ^C, and you can cause it to exit\nwith a stack dump by pressing ^\\.\n\n# Default behavior of signals in Go programs\n\nBy default, a synchronous signal is converted into a run-time panic. A\nSIGHUP, SIGINT, or SIGTERM signal causes the program to exit. A\nSIGQUIT, SIGILL, SIGTRAP, SIGABRT, SIGSTKFLT, SIGEMT, or SIGSYS signal\ncauses the program to exit with a stack dump. A SIGTSTP, SIGTTIN, or\nSIGTTOU signal gets the system default behavior (these signals are\nused by the shell for job control). The SIGPROF signal is handled\ndirectly by the Go runtime to implement runtime.CPUProfile. Other\nsignals will be caught but no action will be taken.\n\nIf the Go program is started with either SIGHUP or SIGINT ignored\n(signal handler set to SIG_IGN), they will remain ignored.\n\nIf the Go program is started with a non-empty signal mask, that will\ngenerally be honored. However, some signals are explicitly unblocked:\nthe synchronous signals, SIGILL, SIGTRAP, SIGSTKFLT, SIGCHLD, SIGPROF,\nand, on Linux, signals 32 (SIGCANCEL) and 33 (SIGSETXID)\n(SIGCANCEL and SIGSETXID are used internally by glibc). Subprocesses\nstarted by [os.Exec], or by [os/exec], will inherit the\nmodified signal mask.\n\n# Changing the behavior of signals in Go programs\n\nThe functions in this package allow a program to change the way Go\nprograms handle signals.\n\nNotify disables the default behavior for a given set of asynchronous\nsignals and instead delivers them over one or more registered\nchannels. Specifically, it applies to the signals SIGHUP, SIGINT,\nSIGQUIT, SIGABRT, and SIGTERM. It also applies to the job control\nsignals SIGTSTP, SIGTTIN, and SIGTTOU, in which case the system\ndefault behavior does not occur. It also applies to some signals that\notherwise cause no action: SIGUSR1, SIGUSR2, SIGPIPE, SIGALRM,\nSIGCHLD, SIGCONT, SIGURG, SIGXCPU, SIGXFSZ, SIGVTALRM, SIGWINCH,\nSIGIO, SIGPWR, SIGSYS, SIGINFO, SIGTHR, SIGWAITING, SIGLWP, SIGFREEZE,\nSIGTHAW, SIGLOST, SIGXRES, SIGJVM1, SIGJVM2, and any real time signals\nused on the system. Note that not all of these signals are available\non all systems.\n\nIf the program was started with SIGHUP or SIGINT ignored, and Notify\nis called for either signal, a signal handler will be installed for\nthat signal and it will no longer be ignored. If, later, Reset or\nIgnore is called for that signal, or Stop is called on all channels\npassed to Notify for that signal, the signal will once again be\nignored. Reset will restore the system default behavior for the\nsignal, while Ignore will cause the system to ignore the signal\nentirely.\n\nIf the program is started with a non-empty signal mask, some signals\nwill be explicitly unblocked as described above. If Notify is called\nfor a blocked signal, it will be unblocked. If, later, Reset is\ncalled for that signal, or Stop is called on all channels passed to\nNotify for that signal, the signal will once again be blocked.\n\n# SIGPIPE\n\nWhen a Go program writes to a broken pipe, the kernel will raise a\nSIGPIPE signal.\n\nIf the program has not called Notify to receive SIGPIPE signals, then\nthe behavior depends on the file descriptor number. A write to a\nbroken pipe on file descriptors 1 or 2 (standard output or standard\nerror) will cause the program to exit with a SIGPIPE signal. A write\nto a broken pipe on some other file descriptor will take no action on\nthe SIGPIPE signal, and the write will fail with an EPIPE error.\n\nIf the program has called Notify to receive SIGPIPE signals, the file\ndescriptor number does not matter. The SIGPIPE signal will be\ndelivered to the Notify channel, and the write will fail with an EPIPE\nerror.\n\nThis means that, by default, command line programs will behave like\ntypical Unix command line programs, while other programs will not\ncrash with SIGPIPE when writing to a closed network connection.\n\n# Go programs that use cgo or SWIG\n\nIn a Go program that includes non-Go code, typically C/C++ code\naccessed using cgo or SWIG, Go's startup code normally runs first. It\nconfigures the signal handlers as expected by the Go runtime, before\nthe non-Go startup code runs. If the non-Go startup code wishes to\ninstall its own signal handlers, it must take certain steps to keep Go\nworking well. This section documents those steps and the overall\neffect changes to signal handler settings by the non-Go code can have\non Go programs. In rare cases, the non-Go code may run before the Go\ncode, in which case the next section also applies.\n\nIf the non-Go code called by the Go program does not change any signal\nhandlers or masks, then the behavior is the same as for a pure Go\nprogram.\n\nIf the non-Go code installs any signal handlers, it must use the\nSA_ONSTACK flag with sigaction. Failing to do so is likely to cause\nthe program to crash if the signal is received. Go programs routinely\nrun with a limited stack, and therefore set up an alternate signal\nstack.\n\nIf the non-Go code installs a signal handler for any of the\nsynchronous signals (SIGBUS, SIGFPE, SIGSEGV), then it should record\nthe existing Go signal handler. If those signals occur while\nexecuting Go code, it should invoke the Go signal handler (whether the\nsignal occurs while executing Go code can be determined by looking at\nthe PC passed to the signal handler). Otherwise some Go run-time\npanics will not occur as expected.\n\nIf the non-Go code installs a signal handler for any of the\nasynchronous signals, it may invoke the Go signal handler or not as it\nchooses. Naturally, if it does not invoke the Go signal handler, the\nGo behavior described above will not occur. This can be an issue with\nthe SIGPROF signal in particular.\n\nThe non-Go code should not change the signal mask on any threads\ncreated by the Go runtime. If the non-Go code starts new threads of\nits own, it may set the signal mask as it pleases.\n\nIf the non-Go code starts a new thread, changes the signal mask, and\nthen invokes a Go function in that thread, the Go runtime will\nautomatically unblock certain signals: the synchronous signals,\nSIGILL, SIGTRAP, SIGSTKFLT, SIGCHLD, SIGPROF, SIGCANCEL, and\nSIGSETXID. When the Go function returns, the non-Go signal mask will\nbe restored.\n\nIf the Go signal handler is invoked on a non-Go thread not running Go\ncode, the handler generally forwards the signal to the non-Go code, as\nfollows. If the signal is SIGPROF, the Go handler does\nnothing. Otherwise, the Go handler removes itself, unblocks the\nsignal, and raises it again, to invoke any non-Go handler or default\nsystem handler. If the program does not exit, the Go handler then\nreinstalls itself and continues execution of the program.\n\nIf a SIGPIPE signal is received, the Go program will invoke the\nspecial handling described above if the SIGPIPE is received on a Go\nthread.  If the SIGPIPE is received on a non-Go thread the signal will\nbe forwarded to the non-Go handler, if any; if there is none the\ndefault system handler will cause the program to terminate.\n\n# Non-Go programs that call Go code\n\nWhen Go code is built with options like -buildmode=c-shared, it will\nbe run as part of an existing non-Go program. The non-Go code may\nhave already installed signal handlers when the Go code starts (that\nmay also happen in unusual cases when using cgo or SWIG; in that case,\nthe discussion here applies).  For -buildmode=c-archive the Go runtime\nwill initialize signals at global constructor time.  For\n-buildmode=c-shared the Go runtime will initialize signals when the\nshared library is loaded.\n\nIf the Go runtime sees an existing signal handler for the SIGCANCEL or\nSIGSETXID signals (which are used only on Linux), it will turn on\nthe SA_ONSTACK flag and otherwise keep the signal handler.\n\nFor the synchronous signals and SIGPIPE, the Go runtime will install a\nsignal handler. It will save any existing signal handler. If a\nsynchronous signal arrives while executing non-Go code, the Go runtime\nwill invoke the existing signal handler instead of the Go signal\nhandler.\n\nGo code built with -buildmode=c-archive or -buildmode=c-shared will\nnot install any other signal handlers by default. If there is an\nexisting signal handler, the Go runtime will turn on the SA_ONSTACK\nflag and otherwise keep the signal handler. If Notify is called for an\nasynchronous signal, a Go signal handler will be installed for that\nsignal. If, later, Reset is called for that signal, the original\nhandling for that signal will be reinstalled, restoring the non-Go\nsignal handler if any.\n\nGo code built without -buildmode=c-archive or -buildmode=c-shared will\ninstall a signal handler for the asynchronous signals listed above,\nand save any existing signal handler. If a signal is delivered to a\nnon-Go thread, it will act as described above, except that if there is\nan existing non-Go signal handler, that handler will be installed\nbefore raising the signal.\n\n# Windows\n\nOn Windows a ^C (Control-C) or ^BREAK (Control-Break) normally cause\nthe program to exit. If Notify is called for [os.Interrupt], ^C or ^BREAK\nwill cause [os.Interrupt] to be sent on the channel, and the program will\nnot exit. If Reset is called, or Stop is called on all channels passed\nto Notify, then the default behavior will be restored.\n\nAdditionally, if Notify is called, and Windows sends CTRL_CLOSE_EVENT,\nCTRL_LOGOFF_EVENT or CTRL_SHUTDOWN_EVENT to the process, Notify will\nreturn syscall.SIGTERM. Unlike Control-C and Control-Break, Notify does\nnot change process behavior when either CTRL_CLOSE_EVENT,\nCTRL_LOGOFF_EVENT or CTRL_SHUTDOWN_EVENT is received - the process will\nstill get terminated unless it exits. But receiving syscall.SIGTERM will\ngive the process an opportunity to clean up before termination.\n\n# Plan 9\n\nOn Plan 9, signals have type syscall.Note, which is a string. Calling\nNotify with a syscall.Note will cause that value to be sent on the\nchannel when that string is posted as a note.\n\n[signal on pkg.go.dev](https://pkg.go.dev/os/signal)",
        "isTrusted": true
      },
      "detail": "signal",
      "insertText": "os/signal",
      "kind": 8
    },
    {
      "label": "os/exec",
      "documentation": {
        "value": "Package exec runs external commands. It wraps os.StartProcess to make it\neasier to remap stdin and stdout, connect I/O with pipes, and do other\nadjustments.\n\nUnlike the \"system\" library call from C and other languages, the\nos/exec package intentionally does not invoke the system shell and\ndoes not expand any glob patterns or handle other expansions,\npipelines, or redirections typically done by shells. The package\nbehaves more like C's \"exec\" family of functions. To expand glob\npatterns, either call the shell directly, taking care to escape any\ndangerous input, or use the path/filepath package's Glob function.\nTo expand environment variables, use package os's ExpandEnv.\n\nNote that the examples in this package assume a Unix system.\nThey may not run on Windows, and they do not run in the Go Playground\nused by golang.org and godoc.org.\n\n# Executables in the current directory\n\nThe functions Command and LookPath look for a program\nin the directories listed in the current path, following the\nconventions of the host operating system.\nOperating systems have for decades included the current\ndirectory in this search, sometimes implicitly and sometimes\nconfigured explicitly that way by default.\nModern practice is that including the current directory\nis usually unexpected and often leads to security problems.\n\nTo avoid those security problems, as of Go 1.19, this package will not resolve a program\nusing an implicit or explicit path entry relative to the current directory.\nThat is, if you run exec.LookPath(\"go\"), it will not successfully return\n./go on Unix nor .\\go.exe on Windows, no matter how the path is configured.\nInstead, if the usual path algorithms would result in that answer,\nthese functions return an error err satisfying errors.Is(err, ErrDot).\n\nFor example, consider these two program snippets:\n\n```\n\tpath, err := exec.LookPath(\"prog\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tuse(path)\n\n```\nand\n\n```\n\tcmd := exec.Command(\"prog\")\n\tif err := cmd.Run(); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n```\nThese will not find and run ./prog or .\\prog.exe,\nno matter how the current path is configured.\n\nCode that always wants to run a program from the current directory\ncan be rewritten to say \"./prog\" instead of \"prog\".\n\nCode that insists on including results from relative path entries\ncan instead override the error using an errors.Is check:\n\n```\n\tpath, err := exec.LookPath(\"prog\")\n\tif errors.Is(err, exec.ErrDot) {\n\t\terr = nil\n\t}\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tuse(path)\n\n```\nand\n\n```\n\tcmd := exec.Command(\"prog\")\n\tif errors.Is(cmd.Err, exec.ErrDot) {\n\t\tcmd.Err = nil\n\t}\n\tif err := cmd.Run(); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n```\nSetting the environment variable GODEBUG=execerrdot=0\ndisables generation of ErrDot entirely, temporarily restoring the pre-Go 1.19\nbehavior for programs that are unable to apply more targeted fixes.\nA future version of Go may remove support for this variable.\n\nBefore adding such overrides, make sure you understand the\nsecurity implications of doing so.\nSee https://go.dev/blog/path-security for more information.\n\n[exec on pkg.go.dev](https://pkg.go.dev/os/exec)",
        "isTrusted": true
      },
      "detail": "exec",
      "insertText": "os/exec",
      "kind": 8
    },
    {
      "label": "path/filepath",
      "documentation": {
        "value": "Package filepath implements utility routines for manipulating filename paths\nin a way compatible with the target operating system-defined file paths.\n\nThe filepath package uses either forward slashes or backslashes,\ndepending on the operating system. To process paths such as URLs\nthat always use forward slashes regardless of the operating\nsystem, see the [path] package.\n\n[filepath on pkg.go.dev](https://pkg.go.dev/path/filepath)",
        "isTrusted": true
      },
      "detail": "filepath",
      "insertText": "path/filepath",
      "kind": 8
    },
    {
      "label": "crypto/tls",
      "documentation": {
        "value": "Package tls partially implements TLS 1.2, as specified in RFC 5246,\nand TLS 1.3, as specified in RFC 8446.\n\n[tls on pkg.go.dev](https://pkg.go.dev/crypto/tls)",
        "isTrusted": true
      },
      "detail": "tls",
      "insertText": "crypto/tls",
      "kind": 8
    },
    {
      "label": "encoding/binary",
      "documentation": {
        "value": "Package binary implements simple translation between numbers and byte\nsequences and encoding and decoding of varints.\n\nNumbers are translated by reading and writing fixed-size values.\nA fixed-size value is either a fixed-size arithmetic\ntype (bool, int8, uint8, int16, float32, complex64, ...)\nor an array or struct containing only fixed-size values.\n\nThe varint functions encode and decode single integer values using\na variable-length encoding; smaller values require fewer bytes.\nFor a specification, see\nhttps://developers.google.com/protocol-buffers/docs/encoding.\n\nThis package favors simplicity over efficiency. Clients that require\nhigh-performance serialization, especially for large data structures,\nshould look at more advanced solutions such as the [encoding/gob]\npackage or [google.golang.org/protobuf] for protocol buffers.\n\n[binary on pkg.go.dev](https://pkg.go.dev/encoding/binary)",
        "isTrusted": true
      },
      "detail": "binary",
      "insertText": "encoding/binary",
      "kind": 8
    },
    {
      "label": "encoding/ascii85",
      "documentation": {
        "value": "Package ascii85 implements the ascii85 data encoding\nas used in the btoa tool and Adobe's PostScript and PDF document formats.\n\n[ascii85 on pkg.go.dev](https://pkg.go.dev/encoding/ascii85)",
        "isTrusted": true
      },
      "detail": "ascii85",
      "insertText": "encoding/ascii85",
      "kind": 8
    },
    {
      "label": "encoding/base32",
      "documentation": {
        "value": "Package base32 implements base32 encoding as specified by RFC 4648.\n\n[base32 on pkg.go.dev](https://pkg.go.dev/encoding/base32)",
        "isTrusted": true
      },
      "detail": "base32",
      "insertText": "encoding/base32",
      "kind": 8
    },
    {
      "label": "encoding/base64",
      "documentation": {
        "value": "Package base64 implements base64 encoding as specified by RFC 4648.\n\n[base64 on pkg.go.dev](https://pkg.go.dev/encoding/base64)",
        "isTrusted": true
      },
      "detail": "base64",
      "insertText": "encoding/base64",
      "kind": 8
    },
    {
      "label": "os/user",
      "documentation": {
        "value": "Package user allows user account lookups by name or id.\n\nFor most Unix systems, this package has two internal implementations of\nresolving user and group ids to names, and listing supplementary group IDs.\nOne is written in pure Go and parses /etc/passwd and /etc/group. The other\nis cgo-based and relies on the standard C library (libc) routines such as\ngetpwuid_r, getgrnam_r, and getgrouplist.\n\nWhen cgo is available, and the required routines are implemented in libc\nfor a particular platform, cgo-based (libc-backed) code is used.\nThis can be overridden by using osusergo build tag, which enforces\nthe pure Go implementation.\n\n[user on pkg.go.dev](https://pkg.go.dev/os/user)",
        "isTrusted": true
      },
      "detail": "user",
      "insertText": "os/user",
      "kind": 8
    },
    {
      "label": "encoding/asn1",
      "documentation": {
        "value": "Package asn1 implements parsing of DER-encoded ASN.1 data structures,\nas defined in ITU-T Rec X.690.\n\nSee also “A Layman's Guide to a Subset of ASN.1, BER, and DER,”\nhttp://luca.ntop.org/Teaching/Appunti/asn1.html.\n\n[asn1 on pkg.go.dev](https://pkg.go.dev/encoding/asn1)",
        "isTrusted": true
      },
      "detail": "asn1",
      "insertText": "encoding/asn1",
      "kind": 8
    },
    {
      "label": "encoding/hex",
      "documentation": {
        "value": "Package hex implements hexadecimal encoding and decoding.\n\n[hex on pkg.go.dev](https://pkg.go.dev/encoding/hex)",
        "isTrusted": true
      },
      "detail": "hex",
      "insertText": "encoding/hex",
      "kind": 8
    },
    {
      "label": "encoding/csv",
      "documentation": {
        "value": "Package csv reads and writes comma-separated values (CSV) files.\nThere are many kinds of CSV files; this package supports the format\ndescribed in RFC 4180.\n\nA csv file contains zero or more records of one or more fields per record.\nEach record is separated by the newline character. The final record may\noptionally be followed by a newline character.\n\n```\n\tfield1,field2,field3\n\n```\nWhite space is considered part of a field.\n\nCarriage returns before newline characters are silently removed.\n\nBlank lines are ignored. A line with only whitespace characters (excluding\nthe ending newline character) is not considered a blank line.\n\nFields which start and stop with the quote character \" are called\nquoted-fields. The beginning and ending quote are not part of the\nfield.\n\nThe source:\n\n```\n\tnormal string,\"quoted-field\"\n\n```\nresults in the fields\n\n```\n\t{`normal string`, `quoted-field`}\n\n```\nWithin a quoted-field a quote character followed by a second quote\ncharacter is considered a single quote.\n\n```\n\t\"the \"\"word\"\" is true\",\"a \"\"quoted-field\"\"\"\n\n```\nresults in\n\n```\n\t{`the \"word\" is true`, `a \"quoted-field\"`}\n\n```\nNewlines and commas may be included in a quoted-field\n\n```\n\t\"Multi-line\n\tfield\",\"comma is ,\"\n\n```\nresults in\n\n```\n\t{`Multi-line\n\tfield`, `comma is ,`}\n\n```\n\n[csv on pkg.go.dev](https://pkg.go.dev/encoding/csv)",
        "isTrusted": true
      },
      "detail": "csv",
      "insertText": "encoding/csv",
      "kind": 8
    },
    {
      "label": "encoding/pem",
      "documentation": {
        "value": "Package pem implements the PEM data encoding, which originated in Privacy\nEnhanced Mail. The most common use of PEM encoding today is in TLS keys and\ncertificates. See RFC 1421.\n\n[pem on pkg.go.dev](https://pkg.go.dev/encoding/pem)",
        "isTrusted": true
      },
      "detail": "pem",
      "insertText": "encoding/pem",
      "kind": 8
    },
    {
      "label": "go/importer",
      "documentation": {
        "value": "Package importer provides access to export data importers.\n\n[importer on pkg.go.dev](https://pkg.go.dev/go/importer)",
        "isTrusted": true
      },
      "detail": "importer",
      "insertText": "go/importer",
      "kind": 8
    },
    {
      "label": "go/ast",
      "documentation": {
        "value": "Package ast declares the types used to represent syntax trees for Go\npackages.\n\n[ast on pkg.go.dev](https://pkg.go.dev/go/ast)",
        "isTrusted": true
      },
      "detail": "ast",
      "insertText": "go/ast",
      "kind": 8
    },
    {
      "label": "encoding/json",
      "documentation": {
        "value": "Package json implements encoding and decoding of JSON as defined in\nRFC 7159. The mapping between JSON and Go values is described\nin the documentation for the Marshal and Unmarshal functions.\n\nSee \"JSON and Go\" for an introduction to this package:\nhttps://golang.org/doc/articles/json_and_go.html\n\n[json on pkg.go.dev](https://pkg.go.dev/encoding/json)",
        "isTrusted": true
      },
      "detail": "json",
      "insertText": "encoding/json",
      "kind": 8
    },
    {
      "label": "encoding/gob",
      "documentation": {
        "value": "Package gob manages streams of gobs - binary values exchanged between an\n[Encoder] (transmitter) and a [Decoder] (receiver). A typical use is transporting\narguments and results of remote procedure calls (RPCs) such as those provided by\n[net/rpc].\n\nThe implementation compiles a custom codec for each data type in the stream and\nis most efficient when a single [Encoder] is used to transmit a stream of values,\namortizing the cost of compilation.\n\n# Basics\n\nA stream of gobs is self-describing. Each data item in the stream is preceded by\na specification of its type, expressed in terms of a small set of predefined\ntypes. Pointers are not transmitted, but the things they point to are\ntransmitted; that is, the values are flattened. Nil pointers are not permitted,\nas they have no value. Recursive types work fine, but\nrecursive values (data with cycles) are problematic. This may change.\n\nTo use gobs, create an [Encoder] and present it with a series of data items as\nvalues or addresses that can be dereferenced to values. The [Encoder] makes sure\nall type information is sent before it is needed. At the receive side, a\n[Decoder] retrieves values from the encoded stream and unpacks them into local\nvariables.\n\n# Types and Values\n\nThe source and destination values/types need not correspond exactly. For structs,\nfields (identified by name) that are in the source but absent from the receiving\nvariable will be ignored. Fields that are in the receiving variable but missing\nfrom the transmitted type or value will be ignored in the destination. If a field\nwith the same name is present in both, their types must be compatible. Both the\nreceiver and transmitter will do all necessary indirection and dereferencing to\nconvert between gobs and actual Go values. For instance, a gob type that is\nschematically,\n\n```\n\tstruct { A, B int }\n\n```\ncan be sent from or received into any of these Go types:\n\n```\n\tstruct { A, B int }\t// the same\n\t*struct { A, B int }\t// extra indirection of the struct\n\tstruct { *A, **B int }\t// extra indirection of the fields\n\tstruct { A, B int64 }\t// different concrete value type; see below\n\n```\nIt may also be received into any of these:\n\n```\n\tstruct { A, B int }\t// the same\n\tstruct { B, A int }\t// ordering doesn't matter; matching is by name\n\tstruct { A, B, C int }\t// extra field (C) ignored\n\tstruct { B int }\t// missing field (A) ignored; data will be dropped\n\tstruct { B, C int }\t// missing field (A) ignored; extra field (C) ignored.\n\n```\nAttempting to receive into these types will draw a decode error:\n\n```\n\tstruct { A int; B uint }\t// change of signedness for B\n\tstruct { A int; B float }\t// change of type for B\n\tstruct { }\t\t\t// no field names in common\n\tstruct { C, D int }\t\t// no field names in common\n\n```\nIntegers are transmitted two ways: arbitrary precision signed integers or\narbitrary precision unsigned integers. There is no int8, int16 etc.\ndiscrimination in the gob format; there are only signed and unsigned integers. As\ndescribed below, the transmitter sends the value in a variable-length encoding;\nthe receiver accepts the value and stores it in the destination variable.\nFloating-point numbers are always sent using IEEE-754 64-bit precision (see\nbelow).\n\nSigned integers may be received into any signed integer variable: int, int16, etc.;\nunsigned integers may be received into any unsigned integer variable; and floating\npoint values may be received into any floating point variable. However,\nthe destination variable must be able to represent the value or the decode\noperation will fail.\n\nStructs, arrays and slices are also supported. Structs encode and decode only\nexported fields. Strings and arrays of bytes are supported with a special,\nefficient representation (see below). When a slice is decoded, if the existing\nslice has capacity the slice will be extended in place; if not, a new array is\nallocated. Regardless, the length of the resulting slice reports the number of\nelements decoded.\n\nIn general, if allocation is required, the decoder will allocate memory. If not,\nit will update the destination variables with values read from the stream. It does\nnot initialize them first, so if the destination is a compound value such as a\nmap, struct, or slice, the decoded values will be merged elementwise into the\nexisting variables.\n\nFunctions and channels will not be sent in a gob. Attempting to encode such a value\nat the top level will fail. A struct field of chan or func type is treated exactly\nlike an unexported field and is ignored.\n\nGob can encode a value of any type implementing the [GobEncoder] or\n[encoding.BinaryMarshaler] interfaces by calling the corresponding method,\nin that order of preference.\n\nGob can decode a value of any type implementing the [GobDecoder] or\n[encoding.BinaryUnmarshaler] interfaces by calling the corresponding method,\nagain in that order of preference.\n\n# Encoding Details\n\nThis section documents the encoding, details that are not important for most\nusers. Details are presented bottom-up.\n\nAn unsigned integer is sent one of two ways. If it is less than 128, it is sent\nas a byte with that value. Otherwise it is sent as a minimal-length big-endian\n(high byte first) byte stream holding the value, preceded by one byte holding the\nbyte count, negated. Thus 0 is transmitted as (00), 7 is transmitted as (07) and\n256 is transmitted as (FE 01 00).\n\nA boolean is encoded within an unsigned integer: 0 for false, 1 for true.\n\nA signed integer, i, is encoded within an unsigned integer, u. Within u, bits 1\nupward contain the value; bit 0 says whether they should be complemented upon\nreceipt. The encode algorithm looks like this:\n\n```\n\tvar u uint\n\tif i \u003c 0 {\n\t\tu = (^uint(i) \u003c\u003c 1) | 1 // complement i, bit 0 is 1\n\t} else {\n\t\tu = (uint(i) \u003c\u003c 1) // do not complement i, bit 0 is 0\n\t}\n\tencodeUnsigned(u)\n\n```\nThe low bit is therefore analogous to a sign bit, but making it the complement bit\ninstead guarantees that the largest negative integer is not a special case. For\nexample, -129=^128=(^256\u003e\u003e1) encodes as (FE 01 01).\n\nFloating-point numbers are always sent as a representation of a float64 value.\nThat value is converted to a uint64 using [math.Float64bits]. The uint64 is then\nbyte-reversed and sent as a regular unsigned integer. The byte-reversal means the\nexponent and high-precision part of the mantissa go first. Since the low bits are\noften zero, this can save encoding bytes. For instance, 17.0 is encoded in only\nthree bytes (FE 31 40).\n\nStrings and slices of bytes are sent as an unsigned count followed by that many\nuninterpreted bytes of the value.\n\nAll other slices and arrays are sent as an unsigned count followed by that many\nelements using the standard gob encoding for their type, recursively.\n\nMaps are sent as an unsigned count followed by that many key, element\npairs. Empty but non-nil maps are sent, so if the receiver has not allocated\none already, one will always be allocated on receipt unless the transmitted map\nis nil and not at the top level.\n\nIn slices and arrays, as well as maps, all elements, even zero-valued elements,\nare transmitted, even if all the elements are zero.\n\nStructs are sent as a sequence of (field number, field value) pairs. The field\nvalue is sent using the standard gob encoding for its type, recursively. If a\nfield has the zero value for its type (except for arrays; see above), it is omitted\nfrom the transmission. The field number is defined by the type of the encoded\nstruct: the first field of the encoded type is field 0, the second is field 1,\netc. When encoding a value, the field numbers are delta encoded for efficiency\nand the fields are always sent in order of increasing field number; the deltas are\ntherefore unsigned. The initialization for the delta encoding sets the field\nnumber to -1, so an unsigned integer field 0 with value 7 is transmitted as unsigned\ndelta = 1, unsigned value = 7 or (01 07). Finally, after all the fields have been\nsent a terminating mark denotes the end of the struct. That mark is a delta=0\nvalue, which has representation (00).\n\nInterface types are not checked for compatibility; all interface types are\ntreated, for transmission, as members of a single \"interface\" type, analogous to\nint or []byte - in effect they're all treated as interface{}. Interface values\nare transmitted as a string identifying the concrete type being sent (a name\nthat must be pre-defined by calling [Register]), followed by a byte count of the\nlength of the following data (so the value can be skipped if it cannot be\nstored), followed by the usual encoding of concrete (dynamic) value stored in\nthe interface value. (A nil interface value is identified by the empty string\nand transmits no value.) Upon receipt, the decoder verifies that the unpacked\nconcrete item satisfies the interface of the receiving variable.\n\nIf a value is passed to [Encoder.Encode] and the type is not a struct (or pointer to struct,\netc.), for simplicity of processing it is represented as a struct of one field.\nThe only visible effect of this is to encode a zero byte after the value, just as\nafter the last field of an encoded struct, so that the decode algorithm knows when\nthe top-level value is complete.\n\nThe representation of types is described below. When a type is defined on a given\nconnection between an [Encoder] and [Decoder], it is assigned a signed integer type\nid. When [Encoder.Encode](v) is called, it makes sure there is an id assigned for\nthe type of v and all its elements and then it sends the pair (typeid, encoded-v)\nwhere typeid is the type id of the encoded type of v and encoded-v is the gob\nencoding of the value v.\n\nTo define a type, the encoder chooses an unused, positive type id and sends the\npair (-type id, encoded-type) where encoded-type is the gob encoding of a wireType\ndescription, constructed from these types:\n\n```\n\ttype wireType struct {\n\t\tArrayT           *ArrayType\n\t\tSliceT           *SliceType\n\t\tStructT          *StructType\n\t\tMapT             *MapType\n\t\tGobEncoderT      *gobEncoderType\n\t\tBinaryMarshalerT *gobEncoderType\n\t\tTextMarshalerT   *gobEncoderType\n\n\t}\n\ttype arrayType struct {\n\t\tCommonType\n\t\tElem typeId\n\t\tLen  int\n\t}\n\ttype CommonType struct {\n\t\tName string // the name of the struct type\n\t\tId  int    // the id of the type, repeated so it's inside the type\n\t}\n\ttype sliceType struct {\n\t\tCommonType\n\t\tElem typeId\n\t}\n\ttype structType struct {\n\t\tCommonType\n\t\tField []*fieldType // the fields of the struct.\n\t}\n\ttype fieldType struct {\n\t\tName string // the name of the field.\n\t\tId   int    // the type id of the field, which must be already defined\n\t}\n\ttype mapType struct {\n\t\tCommonType\n\t\tKey  typeId\n\t\tElem typeId\n\t}\n\ttype gobEncoderType struct {\n\t\tCommonType\n\t}\n\n```\nIf there are nested type ids, the types for all inner type ids must be defined\nbefore the top-level type id is used to describe an encoded-v.\n\nFor simplicity in setup, the connection is defined to understand these types a\npriori, as well as the basic gob types int, uint, etc. Their ids are:\n\n```\n\tbool        1\n\tint         2\n\tuint        3\n\tfloat       4\n\t[]byte      5\n\tstring      6\n\tcomplex     7\n\tinterface   8\n\t// gap for reserved ids.\n\tWireType    16\n\tArrayType   17\n\tCommonType  18\n\tSliceType   19\n\tStructType  20\n\tFieldType   21\n\t// 22 is slice of fieldType.\n\tMapType     23\n\n```\nFinally, each message created by a call to Encode is preceded by an encoded\nunsigned integer count of the number of bytes remaining in the message. After\nthe initial type name, interface values are wrapped the same way; in effect, the\ninterface value acts like a recursive invocation of Encode.\n\nIn summary, a gob stream looks like\n\n```\n\t(byteCount (-type id, encoding of a wireType)* (type id, encoding of a value))*\n\n```\nwhere * signifies zero or more repetitions and the type id of a value must\nbe predefined or be defined before the value in the stream.\n\nCompatibility: Any future changes to the package will endeavor to maintain\ncompatibility with streams encoded using previous versions. That is, any released\nversion of this package should be able to decode data written with any previously\nreleased version, subject to issues such as security fixes. See the Go compatibility\ndocument for background: https://golang.org/doc/go1compat\n\nSee \"Gobs of data\" for a design discussion of the gob wire format:\nhttps://blog.golang.org/gobs-of-data\n\n# Security\n\nThis package is not designed to be hardened against adversarial inputs, and is\noutside the scope of https://go.dev/security/policy. In particular, the [Decoder]\ndoes only basic sanity checking on decoded input sizes, and its limits are not\nconfigurable. Care should be taken when decoding gob data from untrusted\nsources, which may consume significant resources.\n\n[gob on pkg.go.dev](https://pkg.go.dev/encoding/gob)",
        "isTrusted": true
      },
      "detail": "gob",
      "insertText": "encoding/gob",
      "kind": 8
    },
    {
      "label": "go/doc",
      "documentation": {
        "value": "Package doc extracts source code documentation from a Go AST.\n\n[doc on pkg.go.dev](https://pkg.go.dev/go/doc)",
        "isTrusted": true
      },
      "detail": "doc",
      "insertText": "go/doc",
      "kind": 8
    },
    {
      "label": "go/format",
      "documentation": {
        "value": "Package format implements standard formatting of Go source.\n\nNote that formatting of Go source code changes over time, so tools relying on\nconsistent formatting should execute a specific version of the gofmt binary\ninstead of using this package. That way, the formatting will be stable, and\nthe tools won't need to be recompiled each time gofmt changes.\n\nFor example, pre-submit checks that use this package directly would behave\ndifferently depending on what Go version each developer uses, causing the\ncheck to be inherently fragile.\n\n[format on pkg.go.dev](https://pkg.go.dev/go/format)",
        "isTrusted": true
      },
      "detail": "format",
      "insertText": "go/format",
      "kind": 8
    },
    {
      "label": "go/build",
      "documentation": {
        "value": "Package build gathers information about Go packages.\n\n# Go Path\n\nThe Go path is a list of directory trees containing Go source code.\nIt is consulted to resolve imports that cannot be found in the standard\nGo tree. The default path is the value of the GOPATH environment\nvariable, interpreted as a path list appropriate to the operating system\n(on Unix, the variable is a colon-separated string;\non Windows, a semicolon-separated string;\non Plan 9, a list).\n\nEach directory listed in the Go path must have a prescribed structure:\n\nThe src/ directory holds source code. The path below 'src' determines\nthe import path or executable name.\n\nThe pkg/ directory holds installed package objects.\nAs in the Go tree, each target operating system and\narchitecture pair has its own subdirectory of pkg\n(pkg/GOOS_GOARCH).\n\nIf DIR is a directory listed in the Go path, a package with\nsource in DIR/src/foo/bar can be imported as \"foo/bar\" and\nhas its compiled form installed to \"DIR/pkg/GOOS_GOARCH/foo/bar.a\"\n(or, for gccgo, \"DIR/pkg/gccgo/foo/libbar.a\").\n\nThe bin/ directory holds compiled commands.\nEach command is named for its source directory, but only\nusing the final element, not the entire path. That is, the\ncommand with source in DIR/src/foo/quux is installed into\nDIR/bin/quux, not DIR/bin/foo/quux. The foo/ is stripped\nso that you can add DIR/bin to your PATH to get at the\ninstalled commands.\n\nHere's an example directory layout:\n\n```\n\tGOPATH=/home/user/gocode\n\n\t/home/user/gocode/\n\t    src/\n\t        foo/\n\t            bar/               (go code in package bar)\n\t                x.go\n\t            quux/              (go code in package main)\n\t                y.go\n\t    bin/\n\t        quux                   (installed command)\n\t    pkg/\n\t        linux_amd64/\n\t            foo/\n\t                bar.a          (installed package object)\n\n```\n# Build Constraints\n\nA build constraint, also known as a build tag, is a condition under which a\nfile should be included in the package. Build constraints are given by a\nline comment that begins\n\n```\n\t//go:build\n\n```\nBuild constraints may also be part of a file's name\n(for example, source_windows.go will only be included if the target\noperating system is windows).\n\nSee 'go help buildconstraint'\n(https://golang.org/cmd/go/#hdr-Build_constraints) for details.\n\n# Binary-Only Packages\n\nIn Go 1.12 and earlier, it was possible to distribute packages in binary\nform without including the source code used for compiling the package.\nThe package was distributed with a source file not excluded by build\nconstraints and containing a \"//go:binary-only-package\" comment. Like a\nbuild constraint, this comment appeared at the top of a file, preceded\nonly by blank lines and other line comments and with a blank line\nfollowing the comment, to separate it from the package documentation.\nUnlike build constraints, this comment is only recognized in non-test\nGo source files.\n\nThe minimal source code for a binary-only package was therefore:\n\n```\n\t//go:binary-only-package\n\n\tpackage mypkg\n\n```\nThe source code could include additional Go code. That code was never\ncompiled but would be processed by tools like godoc and might be useful\nas end-user documentation.\n\n\"go build\" and other commands no longer support binary-only-packages.\n[Import] and [ImportDir] will still set the BinaryOnly flag in packages\ncontaining these comments for use in tools and error messages.\n\n[build on pkg.go.dev](https://pkg.go.dev/go/build)",
        "isTrusted": true
      },
      "detail": "build",
      "insertText": "go/build",
      "kind": 8
    },
    {
      "label": "encoding/xml",
      "documentation": {
        "value": "Package xml implements a simple XML 1.0 parser that\nunderstands XML name spaces.\n\n[xml on pkg.go.dev](https://pkg.go.dev/encoding/xml)",
        "isTrusted": true
      },
      "detail": "xml",
      "insertText": "encoding/xml",
      "kind": 8
    },
    {
      "label": "go/constant",
      "documentation": {
        "value": "Package constant implements Values representing untyped\nGo constants and their corresponding operations.\n\nA special Unknown value may be used when a value\nis unknown due to an error. Operations on unknown\nvalues produce unknown values unless specified\notherwise.\n\n[constant on pkg.go.dev](https://pkg.go.dev/go/constant)",
        "isTrusted": true
      },
      "detail": "constant",
      "insertText": "go/constant",
      "kind": 8
    },
    {
      "label": "go/scanner",
      "documentation": {
        "value": "Package scanner implements a scanner for Go source text.\nIt takes a []byte as source which can then be tokenized\nthrough repeated calls to the Scan method.\n\n[scanner on pkg.go.dev](https://pkg.go.dev/go/scanner)",
        "isTrusted": true
      },
      "detail": "scanner",
      "insertText": "go/scanner",
      "kind": 8
    },
    {
      "label": "go/types",
      "documentation": {
        "value": "Package types declares the data types and implements\nthe algorithms for type-checking of Go packages. Use\n[Config.Check] to invoke the type checker for a package.\nAlternatively, create a new type checker with [NewChecker]\nand invoke it incrementally by calling [Checker.Files].\n\nType-checking consists of several interdependent phases:\n\nName resolution maps each identifier (ast.Ident) in the program to the\nlanguage object ([Object]) it denotes.\nUse [Info].{Defs,Uses,Implicits} for the results of name resolution.\n\nConstant folding computes the exact constant value (constant.Value)\nfor every expression (ast.Expr) that is a compile-time constant.\nUse Info.Types[expr].Value for the results of constant folding.\n\n[Type] inference computes the type ([Type]) of every expression ([ast.Expr])\nand checks for compliance with the language specification.\nUse [Info.Types][expr].Type for the results of type inference.\n\nFor a tutorial, see https://golang.org/s/types-tutorial.\n\n[types on pkg.go.dev](https://pkg.go.dev/go/types)",
        "isTrusted": true
      },
      "detail": "types",
      "insertText": "go/types",
      "kind": 8
    },
    {
      "label": "go/version",
      "documentation": {
        "value": "Package version provides operations on [Go versions]\nin [Go toolchain name syntax]: strings like\n\"go1.20\", \"go1.21.0\", \"go1.22rc2\", and \"go1.23.4-bigcorp\".\n\n[Go versions]: https://go.dev/doc/toolchain#version\n[Go toolchain name syntax]: https://go.dev/doc/toolchain#name\n\n[version on pkg.go.dev](https://pkg.go.dev/go/version)",
        "isTrusted": true
      },
      "detail": "version",
      "insertText": "go/version",
      "kind": 8
    },
    {
      "label": "go/token",
      "documentation": {
        "value": "Package token defines constants representing the lexical tokens of the Go\nprogramming language and basic operations on tokens (printing, predicates).\n\n[token on pkg.go.dev](https://pkg.go.dev/go/token)",
        "isTrusted": true
      },
      "detail": "token",
      "insertText": "go/token",
      "kind": 8
    },
    {
      "label": "syscall/js",
      "documentation": {
        "value": "Package js gives access to the WebAssembly host environment when using the js/wasm architecture.\nIts API is based on JavaScript semantics.\n\nThis package is EXPERIMENTAL. Its current scope is only to allow tests to run, but not yet to provide a\ncomprehensive API for users. It is exempt from the Go compatibility promise.\n\n[js on pkg.go.dev](https://pkg.go.dev/syscall/js)",
        "isTrusted": true
      },
      "detail": "js",
      "insertText": "syscall/js",
      "kind": 8
    },
    {
      "label": "runtime/asan",
      "documentation": {
        "value": "[runtime/asan on pkg.go.dev](https://pkg.go.dev/runtime/asan)",
        "isTrusted": true
      },
      "detail": "runtime/asan",
      "insertText": "runtime/asan",
      "kind": 8
    },
    {
      "label": "runtime/cgo",
      "documentation": {
        "value": "Package cgo contains runtime support for code generated\nby the cgo tool.  See the documentation for the cgo command\nfor details on using cgo.\n\n[cgo on pkg.go.dev](https://pkg.go.dev/runtime/cgo)",
        "isTrusted": true
      },
      "detail": "cgo",
      "insertText": "runtime/cgo",
      "kind": 8
    },
    {
      "label": "runtime/metrics",
      "documentation": {
        "value": "Package metrics provides a stable interface to access implementation-defined\nmetrics exported by the Go runtime. This package is similar to existing functions\nlike [runtime.ReadMemStats] and [runtime/debug.ReadGCStats], but significantly more general.\n\nThe set of metrics defined by this package may evolve as the runtime itself\nevolves, and also enables variation across Go implementations, whose relevant\nmetric sets may not intersect.\n\n# Interface\n\nMetrics are designated by a string key, rather than, for example, a field name in\na struct. The full list of supported metrics is always available in the slice of\nDescriptions returned by [All]. Each [Description] also includes useful information\nabout the metric.\n\nThus, users of this API are encouraged to sample supported metrics defined by the\nslice returned by All to remain compatible across Go versions. Of course, situations\narise where reading specific metrics is critical. For these cases, users are\nencouraged to use build tags, and although metrics may be deprecated and removed,\nusers should consider this to be an exceptional and rare event, coinciding with a\nvery large change in a particular Go implementation.\n\nEach metric key also has a \"kind\" (see [ValueKind]) that describes the format of the\nmetric's value.\nIn the interest of not breaking users of this package, the \"kind\" for a given metric\nis guaranteed not to change. If it must change, then a new metric will be introduced\nwith a new key and a new \"kind.\"\n\n# Metric key format\n\nAs mentioned earlier, metric keys are strings. Their format is simple and well-defined,\ndesigned to be both human and machine readable. It is split into two components,\nseparated by a colon: a rooted path and a unit. The choice to include the unit in\nthe key is motivated by compatibility: if a metric's unit changes, its semantics likely\ndid also, and a new key should be introduced.\n\nFor more details on the precise definition of the metric key's path and unit formats, see\nthe documentation of the Name field of the Description struct.\n\n# A note about floats\n\nThis package supports metrics whose values have a floating-point representation. In\norder to improve ease-of-use, this package promises to never produce the following\nclasses of floating-point values: NaN, infinity.\n\n# Supported metrics\n\nBelow is the full list of supported metrics, ordered lexicographically.\n\n```\n\t/cgo/go-to-c-calls:calls\n\t\tCount of calls made from Go to C by the current process.\n\n\t/cpu/classes/gc/mark/assist:cpu-seconds\n\t\tEstimated total CPU time goroutines spent performing GC\n\t\ttasks to assist the GC and prevent it from falling behind the\n\t\tapplication. This metric is an overestimate, and not directly\n\t\tcomparable to system CPU time measurements. Compare only with\n\t\tother /cpu/classes metrics.\n\n\t/cpu/classes/gc/mark/dedicated:cpu-seconds\n\t\tEstimated total CPU time spent performing GC tasks on processors\n\t\t(as defined by GOMAXPROCS) dedicated to those tasks. This metric\n\t\tis an overestimate, and not directly comparable to system CPU\n\t\ttime measurements. Compare only with other /cpu/classes metrics.\n\n\t/cpu/classes/gc/mark/idle:cpu-seconds\n\t\tEstimated total CPU time spent performing GC tasks on spare CPU\n\t\tresources that the Go scheduler could not otherwise find a use\n\t\tfor. This should be subtracted from the total GC CPU time to\n\t\tobtain a measure of compulsory GC CPU time. This metric is an\n\t\toverestimate, and not directly comparable to system CPU time\n\t\tmeasurements. Compare only with other /cpu/classes metrics.\n\n\t/cpu/classes/gc/pause:cpu-seconds\n\t\tEstimated total CPU time spent with the application paused by\n\t\tthe GC. Even if only one thread is running during the pause,\n\t\tthis is computed as GOMAXPROCS times the pause latency because\n\t\tnothing else can be executing. This is the exact sum of samples\n\t\tin /sched/pauses/total/gc:seconds if each sample is multiplied\n\t\tby GOMAXPROCS at the time it is taken. This metric is an\n\t\toverestimate, and not directly comparable to system CPU time\n\t\tmeasurements. Compare only with other /cpu/classes metrics.\n\n\t/cpu/classes/gc/total:cpu-seconds\n\t\tEstimated total CPU time spent performing GC tasks. This metric\n\t\tis an overestimate, and not directly comparable to system CPU\n\t\ttime measurements. Compare only with other /cpu/classes metrics.\n\t\tSum of all metrics in /cpu/classes/gc.\n\n\t/cpu/classes/idle:cpu-seconds\n\t\tEstimated total available CPU time not spent executing\n\t\tany Go or Go runtime code. In other words, the part of\n\t\t/cpu/classes/total:cpu-seconds that was unused. This metric is\n\t\tan overestimate, and not directly comparable to system CPU time\n\t\tmeasurements. Compare only with other /cpu/classes metrics.\n\n\t/cpu/classes/scavenge/assist:cpu-seconds\n\t\tEstimated total CPU time spent returning unused memory to the\n\t\tunderlying platform in response eagerly in response to memory\n\t\tpressure. This metric is an overestimate, and not directly\n\t\tcomparable to system CPU time measurements. Compare only with\n\t\tother /cpu/classes metrics.\n\n\t/cpu/classes/scavenge/background:cpu-seconds\n\t\tEstimated total CPU time spent performing background tasks to\n\t\treturn unused memory to the underlying platform. This metric is\n\t\tan overestimate, and not directly comparable to system CPU time\n\t\tmeasurements. Compare only with other /cpu/classes metrics.\n\n\t/cpu/classes/scavenge/total:cpu-seconds\n\t\tEstimated total CPU time spent performing tasks that return\n\t\tunused memory to the underlying platform. This metric is an\n\t\toverestimate, and not directly comparable to system CPU time\n\t\tmeasurements. Compare only with other /cpu/classes metrics.\n\t\tSum of all metrics in /cpu/classes/scavenge.\n\n\t/cpu/classes/total:cpu-seconds\n\t\tEstimated total available CPU time for user Go code or the Go\n\t\truntime, as defined by GOMAXPROCS. In other words, GOMAXPROCS\n\t\tintegrated over the wall-clock duration this process has been\n\t\texecuting for. This metric is an overestimate, and not directly\n\t\tcomparable to system CPU time measurements. Compare only with\n\t\tother /cpu/classes metrics. Sum of all metrics in /cpu/classes.\n\n\t/cpu/classes/user:cpu-seconds\n\t\tEstimated total CPU time spent running user Go code. This may\n\t\talso include some small amount of time spent in the Go runtime.\n\t\tThis metric is an overestimate, and not directly comparable\n\t\tto system CPU time measurements. Compare only with other\n\t\t/cpu/classes metrics.\n\n\t/gc/cycles/automatic:gc-cycles\n\t\tCount of completed GC cycles generated by the Go runtime.\n\n\t/gc/cycles/forced:gc-cycles\n\t\tCount of completed GC cycles forced by the application.\n\n\t/gc/cycles/total:gc-cycles\n\t\tCount of all completed GC cycles.\n\n\t/gc/gogc:percent\n\t\tHeap size target percentage configured by the user, otherwise\n\t\t100. This value is set by the GOGC environment variable, and the\n\t\truntime/debug.SetGCPercent function.\n\n\t/gc/gomemlimit:bytes\n\t\tGo runtime memory limit configured by the user, otherwise\n\t\tmath.MaxInt64. This value is set by the GOMEMLIMIT environment\n\t\tvariable, and the runtime/debug.SetMemoryLimit function.\n\n\t/gc/heap/allocs-by-size:bytes\n\t\tDistribution of heap allocations by approximate size.\n\t\tBucket counts increase monotonically. Note that this does not\n\t\tinclude tiny objects as defined by /gc/heap/tiny/allocs:objects,\n\t\tonly tiny blocks.\n\n\t/gc/heap/allocs:bytes\n\t\tCumulative sum of memory allocated to the heap by the\n\t\tapplication.\n\n\t/gc/heap/allocs:objects\n\t\tCumulative count of heap allocations triggered by the\n\t\tapplication. Note that this does not include tiny objects as\n\t\tdefined by /gc/heap/tiny/allocs:objects, only tiny blocks.\n\n\t/gc/heap/frees-by-size:bytes\n\t\tDistribution of freed heap allocations by approximate size.\n\t\tBucket counts increase monotonically. Note that this does not\n\t\tinclude tiny objects as defined by /gc/heap/tiny/allocs:objects,\n\t\tonly tiny blocks.\n\n\t/gc/heap/frees:bytes\n\t\tCumulative sum of heap memory freed by the garbage collector.\n\n\t/gc/heap/frees:objects\n\t\tCumulative count of heap allocations whose storage was freed\n\t\tby the garbage collector. Note that this does not include tiny\n\t\tobjects as defined by /gc/heap/tiny/allocs:objects, only tiny\n\t\tblocks.\n\n\t/gc/heap/goal:bytes\n\t\tHeap size target for the end of the GC cycle.\n\n\t/gc/heap/live:bytes\n\t\tHeap memory occupied by live objects that were marked by the\n\t\tprevious GC.\n\n\t/gc/heap/objects:objects\n\t\tNumber of objects, live or unswept, occupying heap memory.\n\n\t/gc/heap/tiny/allocs:objects\n\t\tCount of small allocations that are packed together into blocks.\n\t\tThese allocations are counted separately from other allocations\n\t\tbecause each individual allocation is not tracked by the\n\t\truntime, only their block. Each block is already accounted for\n\t\tin allocs-by-size and frees-by-size.\n\n\t/gc/limiter/last-enabled:gc-cycle\n\t\tGC cycle the last time the GC CPU limiter was enabled.\n\t\tThis metric is useful for diagnosing the root cause of an\n\t\tout-of-memory error, because the limiter trades memory for CPU\n\t\ttime when the GC's CPU time gets too high. This is most likely\n\t\tto occur with use of SetMemoryLimit. The first GC cycle is cycle\n\t\t1, so a value of 0 indicates that it was never enabled.\n\n\t/gc/pauses:seconds\n\t\tDeprecated. Prefer the identical /sched/pauses/total/gc:seconds.\n\n\t/gc/scan/globals:bytes\n\t\tThe total amount of global variable space that is scannable.\n\n\t/gc/scan/heap:bytes\n\t\tThe total amount of heap space that is scannable.\n\n\t/gc/scan/stack:bytes\n\t\tThe number of bytes of stack that were scanned last GC cycle.\n\n\t/gc/scan/total:bytes\n\t\tThe total amount space that is scannable. Sum of all metrics in\n\t\t/gc/scan.\n\n\t/gc/stack/starting-size:bytes\n\t\tThe stack size of new goroutines.\n\n\t/godebug/non-default-behavior/execerrdot:events\n\t\tThe number of non-default behaviors executed by the os/exec\n\t\tpackage due to a non-default GODEBUG=execerrdot=... setting.\n\n\t/godebug/non-default-behavior/gocachehash:events\n\t\tThe number of non-default behaviors executed by the cmd/go\n\t\tpackage due to a non-default GODEBUG=gocachehash=... setting.\n\n\t/godebug/non-default-behavior/gocachetest:events\n\t\tThe number of non-default behaviors executed by the cmd/go\n\t\tpackage due to a non-default GODEBUG=gocachetest=... setting.\n\n\t/godebug/non-default-behavior/gocacheverify:events\n\t\tThe number of non-default behaviors executed by the cmd/go\n\t\tpackage due to a non-default GODEBUG=gocacheverify=... setting.\n\n\t/godebug/non-default-behavior/gotypesalias:events\n\t\tThe number of non-default behaviors executed by the go/types\n\t\tpackage due to a non-default GODEBUG=gotypesalias=... setting.\n\n\t/godebug/non-default-behavior/http2client:events\n\t\tThe number of non-default behaviors executed by the net/http\n\t\tpackage due to a non-default GODEBUG=http2client=... setting.\n\n\t/godebug/non-default-behavior/http2server:events\n\t\tThe number of non-default behaviors executed by the net/http\n\t\tpackage due to a non-default GODEBUG=http2server=... setting.\n\n\t/godebug/non-default-behavior/httplaxcontentlength:events\n\t\tThe number of non-default behaviors executed by the net/http\n\t\tpackage due to a non-default GODEBUG=httplaxcontentlength=...\n\t\tsetting.\n\n\t/godebug/non-default-behavior/httpmuxgo121:events\n\t\tThe number of non-default behaviors executed by the net/http\n\t\tpackage due to a non-default GODEBUG=httpmuxgo121=... setting.\n\n\t/godebug/non-default-behavior/installgoroot:events\n\t\tThe number of non-default behaviors executed by the go/build\n\t\tpackage due to a non-default GODEBUG=installgoroot=... setting.\n\n\t/godebug/non-default-behavior/jstmpllitinterp:events\n\t\tThe number of non-default behaviors executed by\n\t\tthe html/template package due to a non-default\n\t\tGODEBUG=jstmpllitinterp=... setting.\n\n\t/godebug/non-default-behavior/multipartmaxheaders:events\n\t\tThe number of non-default behaviors executed by\n\t\tthe mime/multipart package due to a non-default\n\t\tGODEBUG=multipartmaxheaders=... setting.\n\n\t/godebug/non-default-behavior/multipartmaxparts:events\n\t\tThe number of non-default behaviors executed by\n\t\tthe mime/multipart package due to a non-default\n\t\tGODEBUG=multipartmaxparts=... setting.\n\n\t/godebug/non-default-behavior/multipathtcp:events\n\t\tThe number of non-default behaviors executed by the net package\n\t\tdue to a non-default GODEBUG=multipathtcp=... setting.\n\n\t/godebug/non-default-behavior/panicnil:events\n\t\tThe number of non-default behaviors executed by the runtime\n\t\tpackage due to a non-default GODEBUG=panicnil=... setting.\n\n\t/godebug/non-default-behavior/randautoseed:events\n\t\tThe number of non-default behaviors executed by the math/rand\n\t\tpackage due to a non-default GODEBUG=randautoseed=... setting.\n\n\t/godebug/non-default-behavior/tarinsecurepath:events\n\t\tThe number of non-default behaviors executed by the archive/tar\n\t\tpackage due to a non-default GODEBUG=tarinsecurepath=...\n\t\tsetting.\n\n\t/godebug/non-default-behavior/tls10server:events\n\t\tThe number of non-default behaviors executed by the crypto/tls\n\t\tpackage due to a non-default GODEBUG=tls10server=... setting.\n\n\t/godebug/non-default-behavior/tlsmaxrsasize:events\n\t\tThe number of non-default behaviors executed by the crypto/tls\n\t\tpackage due to a non-default GODEBUG=tlsmaxrsasize=... setting.\n\n\t/godebug/non-default-behavior/tlsrsakex:events\n\t\tThe number of non-default behaviors executed by the crypto/tls\n\t\tpackage due to a non-default GODEBUG=tlsrsakex=... setting.\n\n\t/godebug/non-default-behavior/tlsunsafeekm:events\n\t\tThe number of non-default behaviors executed by the crypto/tls\n\t\tpackage due to a non-default GODEBUG=tlsunsafeekm=... setting.\n\n\t/godebug/non-default-behavior/x509sha1:events\n\t\tThe number of non-default behaviors executed by the crypto/x509\n\t\tpackage due to a non-default GODEBUG=x509sha1=... setting.\n\n\t/godebug/non-default-behavior/x509usefallbackroots:events\n\t\tThe number of non-default behaviors executed by the crypto/x509\n\t\tpackage due to a non-default GODEBUG=x509usefallbackroots=...\n\t\tsetting.\n\n\t/godebug/non-default-behavior/x509usepolicies:events\n\t\tThe number of non-default behaviors executed by the crypto/x509\n\t\tpackage due to a non-default GODEBUG=x509usepolicies=...\n\t\tsetting.\n\n\t/godebug/non-default-behavior/zipinsecurepath:events\n\t\tThe number of non-default behaviors executed by the archive/zip\n\t\tpackage due to a non-default GODEBUG=zipinsecurepath=...\n\t\tsetting.\n\n\t/memory/classes/heap/free:bytes\n\t\tMemory that is completely free and eligible to be returned to\n\t\tthe underlying system, but has not been. This metric is the\n\t\truntime's estimate of free address space that is backed by\n\t\tphysical memory.\n\n\t/memory/classes/heap/objects:bytes\n\t\tMemory occupied by live objects and dead objects that have not\n\t\tyet been marked free by the garbage collector.\n\n\t/memory/classes/heap/released:bytes\n\t\tMemory that is completely free and has been returned to the\n\t\tunderlying system. This metric is the runtime's estimate of free\n\t\taddress space that is still mapped into the process, but is not\n\t\tbacked by physical memory.\n\n\t/memory/classes/heap/stacks:bytes\n\t\tMemory allocated from the heap that is reserved for stack space,\n\t\twhether or not it is currently in-use. Currently, this\n\t\trepresents all stack memory for goroutines. It also includes all\n\t\tOS thread stacks in non-cgo programs. Note that stacks may be\n\t\tallocated differently in the future, and this may change.\n\n\t/memory/classes/heap/unused:bytes\n\t\tMemory that is reserved for heap objects but is not currently\n\t\tused to hold heap objects.\n\n\t/memory/classes/metadata/mcache/free:bytes\n\t\tMemory that is reserved for runtime mcache structures, but not\n\t\tin-use.\n\n\t/memory/classes/metadata/mcache/inuse:bytes\n\t\tMemory that is occupied by runtime mcache structures that are\n\t\tcurrently being used.\n\n\t/memory/classes/metadata/mspan/free:bytes\n\t\tMemory that is reserved for runtime mspan structures, but not\n\t\tin-use.\n\n\t/memory/classes/metadata/mspan/inuse:bytes\n\t\tMemory that is occupied by runtime mspan structures that are\n\t\tcurrently being used.\n\n\t/memory/classes/metadata/other:bytes\n\t\tMemory that is reserved for or used to hold runtime metadata.\n\n\t/memory/classes/os-stacks:bytes\n\t\tStack memory allocated by the underlying operating system.\n\t\tIn non-cgo programs this metric is currently zero. This may\n\t\tchange in the future.In cgo programs this metric includes\n\t\tOS thread stacks allocated directly from the OS. Currently,\n\t\tthis only accounts for one stack in c-shared and c-archive build\n\t\tmodes, and other sources of stacks from the OS are not measured.\n\t\tThis too may change in the future.\n\n\t/memory/classes/other:bytes\n\t\tMemory used by execution trace buffers, structures for debugging\n\t\tthe runtime, finalizer and profiler specials, and more.\n\n\t/memory/classes/profiling/buckets:bytes\n\t\tMemory that is used by the stack trace hash map used for\n\t\tprofiling.\n\n\t/memory/classes/total:bytes\n\t\tAll memory mapped by the Go runtime into the current process\n\t\tas read-write. Note that this does not include memory mapped\n\t\tby code called via cgo or via the syscall package. Sum of all\n\t\tmetrics in /memory/classes.\n\n\t/sched/gomaxprocs:threads\n\t\tThe current runtime.GOMAXPROCS setting, or the number of\n\t\toperating system threads that can execute user-level Go code\n\t\tsimultaneously.\n\n\t/sched/goroutines:goroutines\n\t\tCount of live goroutines.\n\n\t/sched/latencies:seconds\n\t\tDistribution of the time goroutines have spent in the scheduler\n\t\tin a runnable state before actually running. Bucket counts\n\t\tincrease monotonically.\n\n\t/sched/pauses/stopping/gc:seconds\n\t\tDistribution of individual GC-related stop-the-world stopping\n\t\tlatencies. This is the time it takes from deciding to stop the\n\t\tworld until all Ps are stopped. This is a subset of the total\n\t\tGC-related stop-the-world time (/sched/pauses/total/gc:seconds).\n\t\tDuring this time, some threads may be executing. Bucket counts\n\t\tincrease monotonically.\n\n\t/sched/pauses/stopping/other:seconds\n\t\tDistribution of individual non-GC-related stop-the-world\n\t\tstopping latencies. This is the time it takes from deciding\n\t\tto stop the world until all Ps are stopped. This is a\n\t\tsubset of the total non-GC-related stop-the-world time\n\t\t(/sched/pauses/total/other:seconds). During this time, some\n\t\tthreads may be executing. Bucket counts increase monotonically.\n\n\t/sched/pauses/total/gc:seconds\n\t\tDistribution of individual GC-related stop-the-world pause\n\t\tlatencies. This is the time from deciding to stop the world\n\t\tuntil the world is started again. Some of this time is spent\n\t\tgetting all threads to stop (this is measured directly in\n\t\t/sched/pauses/stopping/gc:seconds), during which some threads\n\t\tmay still be running. Bucket counts increase monotonically.\n\n\t/sched/pauses/total/other:seconds\n\t\tDistribution of individual non-GC-related stop-the-world\n\t\tpause latencies. This is the time from deciding to stop the\n\t\tworld until the world is started again. Some of this time\n\t\tis spent getting all threads to stop (measured directly in\n\t\t/sched/pauses/stopping/other:seconds). Bucket counts increase\n\t\tmonotonically.\n\n\t/sync/mutex/wait/total:seconds\n\t\tApproximate cumulative time goroutines have spent blocked on a\n\t\tsync.Mutex, sync.RWMutex, or runtime-internal lock. This metric\n\t\tis useful for identifying global changes in lock contention.\n\t\tCollect a mutex or block profile using the runtime/pprof package\n\t\tfor more detailed contention data.\n\n```\n\n[metrics on pkg.go.dev](https://pkg.go.dev/runtime/metrics)",
        "isTrusted": true
      },
      "detail": "metrics",
      "insertText": "runtime/metrics",
      "kind": 8
    },
    {
      "label": "runtime/coverage",
      "documentation": {
        "value": "[runtime/coverage on pkg.go.dev](https://pkg.go.dev/runtime/coverage)",
        "isTrusted": true
      },
      "detail": "runtime/coverage",
      "insertText": "runtime/coverage",
      "kind": 8
    },
    {
      "label": "runtime/msan",
      "documentation": {
        "value": "[runtime/msan on pkg.go.dev](https://pkg.go.dev/runtime/msan)",
        "isTrusted": true
      },
      "detail": "runtime/msan",
      "insertText": "runtime/msan",
      "kind": 8
    },
    {
      "label": "go/parser",
      "documentation": {
        "value": "Package parser implements a parser for Go source files. Input may be\nprovided in a variety of forms (see the various Parse* functions); the\noutput is an abstract syntax tree (AST) representing the Go source. The\nparser is invoked through one of the Parse* functions.\n\nThe parser accepts a larger language than is syntactically permitted by\nthe Go spec, for simplicity, and for improved robustness in the presence\nof syntax errors. For instance, in method declarations, the receiver is\ntreated like an ordinary parameter list and thus may contain multiple\nentries where the spec permits exactly one. Consequently, the corresponding\nfield in the AST (ast.FuncDecl.Recv) field is not restricted to one entry.\n\n[parser on pkg.go.dev](https://pkg.go.dev/go/parser)",
        "isTrusted": true
      },
      "detail": "parser",
      "insertText": "go/parser",
      "kind": 8
    },
    {
      "label": "runtime/race",
      "documentation": {
        "value": "Package race implements data race detection logic.\nNo public interface is provided.\nFor details about the race detector see\nhttps://golang.org/doc/articles/race_detector.html\n\n[race on pkg.go.dev](https://pkg.go.dev/runtime/race)",
        "isTrusted": true
      },
      "detail": "race",
      "insertText": "runtime/race",
      "kind": 8
    },
    {
      "label": "runtime/debug",
      "documentation": {
        "value": "Package debug contains facilities for programs to debug themselves while\nthey are running.\n\n[debug on pkg.go.dev](https://pkg.go.dev/runtime/debug)",
        "isTrusted": true
      },
      "detail": "debug",
      "insertText": "runtime/debug",
      "kind": 8
    },
    {
      "label": "runtime/trace",
      "documentation": {
        "value": "Package trace contains facilities for programs to generate traces\nfor the Go execution tracer.\n\n# Tracing runtime activities\n\nThe execution trace captures a wide range of execution events such as\ngoroutine creation/blocking/unblocking, syscall enter/exit/block,\nGC-related events, changes of heap size, processor start/stop, etc.\nWhen CPU profiling is active, the execution tracer makes an effort to\ninclude those samples as well.\nA precise nanosecond-precision timestamp and a stack trace is\ncaptured for most events. The generated trace can be interpreted\nusing `go tool trace`.\n\nSupport for tracing tests and benchmarks built with the standard\ntesting package is built into `go test`. For example, the following\ncommand runs the test in the current directory and writes the trace\nfile (trace.out).\n\n```\n\tgo test -trace=trace.out\n\n```\nThis runtime/trace package provides APIs to add equivalent tracing\nsupport to a standalone program. See the Example that demonstrates\nhow to use this API to enable tracing.\n\nThere is also a standard HTTP interface to trace data. Adding the\nfollowing line will install a handler under the /debug/pprof/trace URL\nto download a live trace:\n\n```\n\timport _ \"net/http/pprof\"\n\n```\nSee the [net/http/pprof] package for more details about all of the\ndebug endpoints installed by this import.\n\n# User annotation\n\nPackage trace provides user annotation APIs that can be used to\nlog interesting events during execution.\n\nThere are three types of user annotations: log messages, regions,\nand tasks.\n\n[Log] emits a timestamped message to the execution trace along with\nadditional information such as the category of the message and\nwhich goroutine called [Log]. The execution tracer provides UIs to filter\nand group goroutines using the log category and the message supplied\nin [Log].\n\nA region is for logging a time interval during a goroutine's execution.\nBy definition, a region starts and ends in the same goroutine.\nRegions can be nested to represent subintervals.\nFor example, the following code records four regions in the execution\ntrace to trace the durations of sequential steps in a cappuccino making\noperation.\n\n```\n\ttrace.WithRegion(ctx, \"makeCappuccino\", func() {\n\n\t   // orderID allows to identify a specific order\n\t   // among many cappuccino order region records.\n\t   trace.Log(ctx, \"orderID\", orderID)\n\n\t   trace.WithRegion(ctx, \"steamMilk\", steamMilk)\n\t   trace.WithRegion(ctx, \"extractCoffee\", extractCoffee)\n\t   trace.WithRegion(ctx, \"mixMilkCoffee\", mixMilkCoffee)\n\t})\n\n```\nA task is a higher-level component that aids tracing of logical\noperations such as an RPC request, an HTTP request, or an\ninteresting local operation which may require multiple goroutines\nworking together. Since tasks can involve multiple goroutines,\nthey are tracked via a [context.Context] object. [NewTask] creates\na new task and embeds it in the returned [context.Context] object.\nLog messages and regions are attached to the task, if any, in the\nContext passed to [Log] and [WithRegion].\n\nFor example, assume that we decided to froth milk, extract coffee,\nand mix milk and coffee in separate goroutines. With a task,\nthe trace tool can identify the goroutines involved in a specific\ncappuccino order.\n\n```\n\tctx, task := trace.NewTask(ctx, \"makeCappuccino\")\n\ttrace.Log(ctx, \"orderID\", orderID)\n\n\tmilk := make(chan bool)\n\tespresso := make(chan bool)\n\n\tgo func() {\n\t        trace.WithRegion(ctx, \"steamMilk\", steamMilk)\n\t        milk \u003c- true\n\t}()\n\tgo func() {\n\t        trace.WithRegion(ctx, \"extractCoffee\", extractCoffee)\n\t        espresso \u003c- true\n\t}()\n\tgo func() {\n\t        defer task.End() // When assemble is done, the order is complete.\n\t        \u003c-espresso\n\t        \u003c-milk\n\t        trace.WithRegion(ctx, \"mixMilkCoffee\", mixMilkCoffee)\n\t}()\n\n```\nThe trace tool computes the latency of a task by measuring the\ntime between the task creation and the task end and provides\nlatency distributions for each task type found in the trace.\n\n[trace on pkg.go.dev](https://pkg.go.dev/runtime/trace)",
        "isTrusted": true
      },
      "detail": "trace",
      "insertText": "runtime/trace",
      "kind": 8
    },
    {
      "label": "sync/atomic",
      "documentation": {
        "value": "Package atomic provides low-level atomic memory primitives\nuseful for implementing synchronization algorithms.\n\nThese functions require great care to be used correctly.\nExcept for special, low-level applications, synchronization is better\ndone with channels or the facilities of the [sync] package.\nShare memory by communicating;\ndon't communicate by sharing memory.\n\nThe swap operation, implemented by the SwapT functions, is the atomic\nequivalent of:\n\n```\n\told = *addr\n\t*addr = new\n\treturn old\n\n```\nThe compare-and-swap operation, implemented by the CompareAndSwapT\nfunctions, is the atomic equivalent of:\n\n```\n\tif *addr == old {\n\t\t*addr = new\n\t\treturn true\n\t}\n\treturn false\n\n```\nThe add operation, implemented by the AddT functions, is the atomic\nequivalent of:\n\n```\n\t*addr += delta\n\treturn *addr\n\n```\nThe load and store operations, implemented by the LoadT and StoreT\nfunctions, are the atomic equivalents of \"return *addr\" and\n\"*addr = val\".\n\nIn the terminology of the Go memory model, if the effect of\nan atomic operation A is observed by atomic operation B,\nthen A “synchronizes before” B.\nAdditionally, all the atomic operations executed in a program\nbehave as though executed in some sequentially consistent order.\nThis definition provides the same semantics as\nC++'s sequentially consistent atomics and Java's volatile variables.\n\n[atomic on pkg.go.dev](https://pkg.go.dev/sync/atomic)",
        "isTrusted": true
      },
      "detail": "atomic",
      "insertText": "sync/atomic",
      "kind": 8
    },
    {
      "label": "go/printer",
      "documentation": {
        "value": "Package printer implements printing of AST nodes.\n\n[printer on pkg.go.dev](https://pkg.go.dev/go/printer)",
        "isTrusted": true
      },
      "detail": "printer",
      "insertText": "go/printer",
      "kind": 8
    },
    {
      "label": "text/tabwriter",
      "documentation": {
        "value": "Package tabwriter implements a write filter (tabwriter.Writer) that\ntranslates tabbed columns in input into properly aligned text.\n\nThe package is using the Elastic Tabstops algorithm described at\nhttp://nickgravgaard.com/elastictabstops/index.html.\n\nThe text/tabwriter package is frozen and is not accepting new features.\n\n[tabwriter on pkg.go.dev](https://pkg.go.dev/text/tabwriter)",
        "isTrusted": true
      },
      "detail": "tabwriter",
      "insertText": "text/tabwriter",
      "kind": 8
    },
    {
      "label": "text/template",
      "documentation": {
        "value": "Package template implements data-driven templates for generating textual output.\n\nTo generate HTML output, see [html/template], which has the same interface\nas this package but automatically secures HTML output against certain attacks.\n\nTemplates are executed by applying them to a data structure. Annotations in the\ntemplate refer to elements of the data structure (typically a field of a struct\nor a key in a map) to control execution and derive values to be displayed.\nExecution of the template walks the structure and sets the cursor, represented\nby a period '.' and called \"dot\", to the value at the current location in the\nstructure as execution proceeds.\n\nThe input text for a template is UTF-8-encoded text in any format.\n\"Actions\"--data evaluations or control structures--are delimited by\n\"{{\" and \"}}\"; all text outside actions is copied to the output unchanged.\n\nOnce parsed, a template may be executed safely in parallel, although if parallel\nexecutions share a Writer the output may be interleaved.\n\nHere is a trivial example that prints \"17 items are made of wool\".\n\n```\n\ttype Inventory struct {\n\t\tMaterial string\n\t\tCount    uint\n\t}\n\tsweaters := Inventory{\"wool\", 17}\n\ttmpl, err := template.New(\"test\").Parse(\"{{.Count}} items are made of {{.Material}}\")\n\tif err != nil { panic(err) }\n\terr = tmpl.Execute(os.Stdout, sweaters)\n\tif err != nil { panic(err) }\n\n```\nMore intricate examples appear below.\n\nText and spaces\n\nBy default, all text between actions is copied verbatim when the template is\nexecuted. For example, the string \" items are made of \" in the example above\nappears on standard output when the program is run.\n\nHowever, to aid in formatting template source code, if an action's left\ndelimiter (by default \"{{\") is followed immediately by a minus sign and white\nspace, all trailing white space is trimmed from the immediately preceding text.\nSimilarly, if the right delimiter (\"}}\") is preceded by white space and a minus\nsign, all leading white space is trimmed from the immediately following text.\nIn these trim markers, the white space must be present:\n\"{{- 3}}\" is like \"{{3}}\" but trims the immediately preceding text, while\n\"{{-3}}\" parses as an action containing the number -3.\n\nFor instance, when executing the template whose source is\n\n```\n\t\"{{23 -}} \u003c {{- 45}}\"\n\n```\nthe generated output would be\n\n```\n\t\"23\u003c45\"\n\n```\nFor this trimming, the definition of white space characters is the same as in Go:\nspace, horizontal tab, carriage return, and newline.\n\nActions\n\nHere is the list of actions. \"Arguments\" and \"pipelines\" are evaluations of\ndata, defined in detail in the corresponding sections that follow.\n\n```\n\t{{/* a comment */}}\n\t{{- /* a comment with white space trimmed from preceding and following text */ -}}\n\t\tA comment; discarded. May contain newlines.\n\t\tComments do not nest and must start and end at the\n\t\tdelimiters, as shown here.\n\n\t{{pipeline}}\n\t\tThe default textual representation (the same as would be\n\t\tprinted by fmt.Print) of the value of the pipeline is copied\n\t\tto the output.\n\n\t{{if pipeline}} T1 {{end}}\n\t\tIf the value of the pipeline is empty, no output is generated;\n\t\totherwise, T1 is executed. The empty values are false, 0, any\n\t\tnil pointer or interface value, and any array, slice, map, or\n\t\tstring of length zero.\n\t\tDot is unaffected.\n\n\t{{if pipeline}} T1 {{else}} T0 {{end}}\n\t\tIf the value of the pipeline is empty, T0 is executed;\n\t\totherwise, T1 is executed. Dot is unaffected.\n\n\t{{if pipeline}} T1 {{else if pipeline}} T0 {{end}}\n\t\tTo simplify the appearance of if-else chains, the else action\n\t\tof an if may include another if directly; the effect is exactly\n\t\tthe same as writing\n\t\t\t{{if pipeline}} T1 {{else}}{{if pipeline}} T0 {{end}}{{end}}\n\n\t{{range pipeline}} T1 {{end}}\n\t\tThe value of the pipeline must be an array, slice, map, or channel.\n\t\tIf the value of the pipeline has length zero, nothing is output;\n\t\totherwise, dot is set to the successive elements of the array,\n\t\tslice, or map and T1 is executed. If the value is a map and the\n\t\tkeys are of basic type with a defined order, the elements will be\n\t\tvisited in sorted key order.\n\n\t{{range pipeline}} T1 {{else}} T0 {{end}}\n\t\tThe value of the pipeline must be an array, slice, map, or channel.\n\t\tIf the value of the pipeline has length zero, dot is unaffected and\n\t\tT0 is executed; otherwise, dot is set to the successive elements\n\t\tof the array, slice, or map and T1 is executed.\n\n\t{{break}}\n\t\tThe innermost {{range pipeline}} loop is ended early, stopping the\n\t\tcurrent iteration and bypassing all remaining iterations.\n\n\t{{continue}}\n\t\tThe current iteration of the innermost {{range pipeline}} loop is\n\t\tstopped, and the loop starts the next iteration.\n\n\t{{template \"name\"}}\n\t\tThe template with the specified name is executed with nil data.\n\n\t{{template \"name\" pipeline}}\n\t\tThe template with the specified name is executed with dot set\n\t\tto the value of the pipeline.\n\n\t{{block \"name\" pipeline}} T1 {{end}}\n\t\tA block is shorthand for defining a template\n\t\t\t{{define \"name\"}} T1 {{end}}\n\t\tand then executing it in place\n\t\t\t{{template \"name\" pipeline}}\n\t\tThe typical use is to define a set of root templates that are\n\t\tthen customized by redefining the block templates within.\n\n\t{{with pipeline}} T1 {{end}}\n\t\tIf the value of the pipeline is empty, no output is generated;\n\t\totherwise, dot is set to the value of the pipeline and T1 is\n\t\texecuted.\n\n\t{{with pipeline}} T1 {{else}} T0 {{end}}\n\t\tIf the value of the pipeline is empty, dot is unaffected and T0\n\t\tis executed; otherwise, dot is set to the value of the pipeline\n\t\tand T1 is executed.\n\n```\nArguments\n\nAn argument is a simple value, denoted by one of the following.\n\n```\n\t- A boolean, string, character, integer, floating-point, imaginary\n\t  or complex constant in Go syntax. These behave like Go's untyped\n\t  constants. Note that, as in Go, whether a large integer constant\n\t  overflows when assigned or passed to a function can depend on whether\n\t  the host machine's ints are 32 or 64 bits.\n\t- The keyword nil, representing an untyped Go nil.\n\t- The character '.' (period):\n\t\t.\n\t  The result is the value of dot.\n\t- A variable name, which is a (possibly empty) alphanumeric string\n\t  preceded by a dollar sign, such as\n\t\t$piOver2\n\t  or\n\t\t$\n\t  The result is the value of the variable.\n\t  Variables are described below.\n\t- The name of a field of the data, which must be a struct, preceded\n\t  by a period, such as\n\t\t.Field\n\t  The result is the value of the field. Field invocations may be\n\t  chained:\n\t    .Field1.Field2\n\t  Fields can also be evaluated on variables, including chaining:\n\t    $x.Field1.Field2\n\t- The name of a key of the data, which must be a map, preceded\n\t  by a period, such as\n\t\t.Key\n\t  The result is the map element value indexed by the key.\n\t  Key invocations may be chained and combined with fields to any\n\t  depth:\n\t    .Field1.Key1.Field2.Key2\n\t  Although the key must be an alphanumeric identifier, unlike with\n\t  field names they do not need to start with an upper case letter.\n\t  Keys can also be evaluated on variables, including chaining:\n\t    $x.key1.key2\n\t- The name of a niladic method of the data, preceded by a period,\n\t  such as\n\t\t.Method\n\t  The result is the value of invoking the method with dot as the\n\t  receiver, dot.Method(). Such a method must have one return value (of\n\t  any type) or two return values, the second of which is an error.\n\t  If it has two and the returned error is non-nil, execution terminates\n\t  and an error is returned to the caller as the value of Execute.\n\t  Method invocations may be chained and combined with fields and keys\n\t  to any depth:\n\t    .Field1.Key1.Method1.Field2.Key2.Method2\n\t  Methods can also be evaluated on variables, including chaining:\n\t    $x.Method1.Field\n\t- The name of a niladic function, such as\n\t\tfun\n\t  The result is the value of invoking the function, fun(). The return\n\t  types and values behave as in methods. Functions and function\n\t  names are described below.\n\t- A parenthesized instance of one the above, for grouping. The result\n\t  may be accessed by a field or map key invocation.\n\t\tprint (.F1 arg1) (.F2 arg2)\n\t\t(.StructValuedMethod \"arg\").Field\n\n```\nArguments may evaluate to any type; if they are pointers the implementation\nautomatically indirects to the base type when required.\nIf an evaluation yields a function value, such as a function-valued\nfield of a struct, the function is not invoked automatically, but it\ncan be used as a truth value for an if action and the like. To invoke\nit, use the call function, defined below.\n\nPipelines\n\nA pipeline is a possibly chained sequence of \"commands\". A command is a simple\nvalue (argument) or a function or method call, possibly with multiple arguments:\n\n```\n\tArgument\n\t\tThe result is the value of evaluating the argument.\n\t.Method [Argument...]\n\t\tThe method can be alone or the last element of a chain but,\n\t\tunlike methods in the middle of a chain, it can take arguments.\n\t\tThe result is the value of calling the method with the\n\t\targuments:\n\t\t\tdot.Method(Argument1, etc.)\n\tfunctionName [Argument...]\n\t\tThe result is the value of calling the function associated\n\t\twith the name:\n\t\t\tfunction(Argument1, etc.)\n\t\tFunctions and function names are described below.\n\n```\nA pipeline may be \"chained\" by separating a sequence of commands with pipeline\ncharacters '|'. In a chained pipeline, the result of each command is\npassed as the last argument of the following command. The output of the final\ncommand in the pipeline is the value of the pipeline.\n\nThe output of a command will be either one value or two values, the second of\nwhich has type error. If that second value is present and evaluates to\nnon-nil, execution terminates and the error is returned to the caller of\nExecute.\n\nVariables\n\nA pipeline inside an action may initialize a variable to capture the result.\nThe initialization has syntax\n\n```\n\t$variable := pipeline\n\n```\nwhere $variable is the name of the variable. An action that declares a\nvariable produces no output.\n\nVariables previously declared can also be assigned, using the syntax\n\n```\n\t$variable = pipeline\n\n```\nIf a \"range\" action initializes a variable, the variable is set to the\nsuccessive elements of the iteration. Also, a \"range\" may declare two\nvariables, separated by a comma:\n\n```\n\trange $index, $element := pipeline\n\n```\nin which case $index and $element are set to the successive values of the\narray/slice index or map key and element, respectively. Note that if there is\nonly one variable, it is assigned the element; this is opposite to the\nconvention in Go range clauses.\n\nA variable's scope extends to the \"end\" action of the control structure (\"if\",\n\"with\", or \"range\") in which it is declared, or to the end of the template if\nthere is no such control structure. A template invocation does not inherit\nvariables from the point of its invocation.\n\nWhen execution begins, $ is set to the data argument passed to Execute, that is,\nto the starting value of dot.\n\nExamples\n\nHere are some example one-line templates demonstrating pipelines and variables.\nAll produce the quoted word \"output\":\n\n```\n\t{{\"\\\"output\\\"\"}}\n\t\tA string constant.\n\t{{`\"output\"`}}\n\t\tA raw string constant.\n\t{{printf \"%q\" \"output\"}}\n\t\tA function call.\n\t{{\"output\" | printf \"%q\"}}\n\t\tA function call whose final argument comes from the previous\n\t\tcommand.\n\t{{printf \"%q\" (print \"out\" \"put\")}}\n\t\tA parenthesized argument.\n\t{{\"put\" | printf \"%s%s\" \"out\" | printf \"%q\"}}\n\t\tA more elaborate call.\n\t{{\"output\" | printf \"%s\" | printf \"%q\"}}\n\t\tA longer chain.\n\t{{with \"output\"}}{{printf \"%q\" .}}{{end}}\n\t\tA with action using dot.\n\t{{with $x := \"output\" | printf \"%q\"}}{{$x}}{{end}}\n\t\tA with action that creates and uses a variable.\n\t{{with $x := \"output\"}}{{printf \"%q\" $x}}{{end}}\n\t\tA with action that uses the variable in another action.\n\t{{with $x := \"output\"}}{{$x | printf \"%q\"}}{{end}}\n\t\tThe same, but pipelined.\n\n```\nFunctions\n\nDuring execution functions are found in two function maps: first in the\ntemplate, then in the global function map. By default, no functions are defined\nin the template but the Funcs method can be used to add them.\n\nPredefined global functions are named as follows.\n\n```\n\tand\n\t\tReturns the boolean AND of its arguments by returning the\n\t\tfirst empty argument or the last argument. That is,\n\t\t\"and x y\" behaves as \"if x then y else x.\"\n\t\tEvaluation proceeds through the arguments left to right\n\t\tand returns when the result is determined.\n\tcall\n\t\tReturns the result of calling the first argument, which\n\t\tmust be a function, with the remaining arguments as parameters.\n\t\tThus \"call .X.Y 1 2\" is, in Go notation, dot.X.Y(1, 2) where\n\t\tY is a func-valued field, map entry, or the like.\n\t\tThe first argument must be the result of an evaluation\n\t\tthat yields a value of function type (as distinct from\n\t\ta predefined function such as print). The function must\n\t\treturn either one or two result values, the second of which\n\t\tis of type error. If the arguments don't match the function\n\t\tor the returned error value is non-nil, execution stops.\n\thtml\n\t\tReturns the escaped HTML equivalent of the textual\n\t\trepresentation of its arguments. This function is unavailable\n\t\tin html/template, with a few exceptions.\n\tindex\n\t\tReturns the result of indexing its first argument by the\n\t\tfollowing arguments. Thus \"index x 1 2 3\" is, in Go syntax,\n\t\tx[1][2][3]. Each indexed item must be a map, slice, or array.\n\tslice\n\t\tslice returns the result of slicing its first argument by the\n\t\tremaining arguments. Thus \"slice x 1 2\" is, in Go syntax, x[1:2],\n\t\twhile \"slice x\" is x[:], \"slice x 1\" is x[1:], and \"slice x 1 2 3\"\n\t\tis x[1:2:3]. The first argument must be a string, slice, or array.\n\tjs\n\t\tReturns the escaped JavaScript equivalent of the textual\n\t\trepresentation of its arguments.\n\tlen\n\t\tReturns the integer length of its argument.\n\tnot\n\t\tReturns the boolean negation of its single argument.\n\tor\n\t\tReturns the boolean OR of its arguments by returning the\n\t\tfirst non-empty argument or the last argument, that is,\n\t\t\"or x y\" behaves as \"if x then x else y\".\n\t\tEvaluation proceeds through the arguments left to right\n\t\tand returns when the result is determined.\n\tprint\n\t\tAn alias for fmt.Sprint\n\tprintf\n\t\tAn alias for fmt.Sprintf\n\tprintln\n\t\tAn alias for fmt.Sprintln\n\turlquery\n\t\tReturns the escaped value of the textual representation of\n\t\tits arguments in a form suitable for embedding in a URL query.\n\t\tThis function is unavailable in html/template, with a few\n\t\texceptions.\n\n```\nThe boolean functions take any zero value to be false and a non-zero\nvalue to be true.\n\nThere is also a set of binary comparison operators defined as\nfunctions:\n\n```\n\teq\n\t\tReturns the boolean truth of arg1 == arg2\n\tne\n\t\tReturns the boolean truth of arg1 != arg2\n\tlt\n\t\tReturns the boolean truth of arg1 \u003c arg2\n\tle\n\t\tReturns the boolean truth of arg1 \u003c= arg2\n\tgt\n\t\tReturns the boolean truth of arg1 \u003e arg2\n\tge\n\t\tReturns the boolean truth of arg1 \u003e= arg2\n\n```\nFor simpler multi-way equality tests, eq (only) accepts two or more\narguments and compares the second and subsequent to the first,\nreturning in effect\n\n```\n\targ1==arg2 || arg1==arg3 || arg1==arg4 ...\n\n```\n(Unlike with || in Go, however, eq is a function call and all the\narguments will be evaluated.)\n\nThe comparison functions work on any values whose type Go defines as\ncomparable. For basic types such as integers, the rules are relaxed:\nsize and exact type are ignored, so any integer value, signed or unsigned,\nmay be compared with any other integer value. (The arithmetic value is compared,\nnot the bit pattern, so all negative integers are less than all unsigned integers.)\nHowever, as usual, one may not compare an int with a float32 and so on.\n\nAssociated templates\n\nEach template is named by a string specified when it is created. Also, each\ntemplate is associated with zero or more other templates that it may invoke by\nname; such associations are transitive and form a name space of templates.\n\nA template may use a template invocation to instantiate another associated\ntemplate; see the explanation of the \"template\" action above. The name must be\nthat of a template associated with the template that contains the invocation.\n\nNested template definitions\n\nWhen parsing a template, another template may be defined and associated with the\ntemplate being parsed. Template definitions must appear at the top level of the\ntemplate, much like global variables in a Go program.\n\nThe syntax of such definitions is to surround each template declaration with a\n\"define\" and \"end\" action.\n\nThe define action names the template being created by providing a string\nconstant. Here is a simple example:\n\n```\n\t{{define \"T1\"}}ONE{{end}}\n\t{{define \"T2\"}}TWO{{end}}\n\t{{define \"T3\"}}{{template \"T1\"}} {{template \"T2\"}}{{end}}\n\t{{template \"T3\"}}\n\n```\nThis defines two templates, T1 and T2, and a third T3 that invokes the other two\nwhen it is executed. Finally it invokes T3. If executed this template will\nproduce the text\n\n```\n\tONE TWO\n\n```\nBy construction, a template may reside in only one association. If it's\nnecessary to have a template addressable from multiple associations, the\ntemplate definition must be parsed multiple times to create distinct *Template\nvalues, or must be copied with [Template.Clone] or [Template.AddParseTree].\n\nParse may be called multiple times to assemble the various associated templates;\nsee [ParseFiles], [ParseGlob], [Template.ParseFiles] and [Template.ParseGlob]\nfor simple ways to parse related templates stored in files.\n\nA template may be executed directly or through [Template.ExecuteTemplate], which executes\nan associated template identified by name. To invoke our example above, we\nmight write,\n\n```\n\terr := tmpl.Execute(os.Stdout, \"no data needed\")\n\tif err != nil {\n\t\tlog.Fatalf(\"execution failed: %s\", err)\n\t}\n\n```\nor to invoke a particular template explicitly by name,\n\n```\n\terr := tmpl.ExecuteTemplate(os.Stdout, \"T2\", \"no data needed\")\n\tif err != nil {\n\t\tlog.Fatalf(\"execution failed: %s\", err)\n\t}\n\n```\n\n[template on pkg.go.dev](https://pkg.go.dev/text/template)",
        "isTrusted": true
      },
      "detail": "template",
      "insertText": "text/template",
      "kind": 8
    },
    {
      "label": "text/scanner",
      "documentation": {
        "value": "Package scanner provides a scanner and tokenizer for UTF-8-encoded text.\nIt takes an io.Reader providing the source, which then can be tokenized\nthrough repeated calls to the Scan function. For compatibility with\nexisting tools, the NUL character is not allowed. If the first character\nin the source is a UTF-8 encoded byte order mark (BOM), it is discarded.\n\nBy default, a Scanner skips white space and Go comments and recognizes all\nliterals as defined by the Go language specification. It may be\ncustomized to recognize only a subset of those literals and to recognize\ndifferent identifier and white space characters.\n\n[scanner on pkg.go.dev](https://pkg.go.dev/text/scanner)",
        "isTrusted": true
      },
      "detail": "scanner",
      "insertText": "text/scanner",
      "kind": 8
    },
    {
      "label": "runtime/pprof",
      "documentation": {
        "value": "Package pprof writes runtime profiling data in the format expected\nby the pprof visualization tool.\n\n# Profiling a Go program\n\nThe first step to profiling a Go program is to enable profiling.\nSupport for profiling benchmarks built with the standard testing\npackage is built into go test. For example, the following command\nruns benchmarks in the current directory and writes the CPU and\nmemory profiles to cpu.prof and mem.prof:\n\n```\n\tgo test -cpuprofile cpu.prof -memprofile mem.prof -bench .\n\n```\nTo add equivalent profiling support to a standalone program, add\ncode like the following to your main function:\n\n```\n\tvar cpuprofile = flag.String(\"cpuprofile\", \"\", \"write cpu profile to `file`\")\n\tvar memprofile = flag.String(\"memprofile\", \"\", \"write memory profile to `file`\")\n\n\tfunc main() {\n\t    flag.Parse()\n\t    if *cpuprofile != \"\" {\n\t        f, err := os.Create(*cpuprofile)\n\t        if err != nil {\n\t            log.Fatal(\"could not create CPU profile: \", err)\n\t        }\n\t        defer f.Close() // error handling omitted for example\n\t        if err := pprof.StartCPUProfile(f); err != nil {\n\t            log.Fatal(\"could not start CPU profile: \", err)\n\t        }\n\t        defer pprof.StopCPUProfile()\n\t    }\n\n\t    // ... rest of the program ...\n\n\t    if *memprofile != \"\" {\n\t        f, err := os.Create(*memprofile)\n\t        if err != nil {\n\t            log.Fatal(\"could not create memory profile: \", err)\n\t        }\n\t        defer f.Close() // error handling omitted for example\n\t        runtime.GC() // get up-to-date statistics\n\t        if err := pprof.WriteHeapProfile(f); err != nil {\n\t            log.Fatal(\"could not write memory profile: \", err)\n\t        }\n\t    }\n\t}\n\n```\nThere is also a standard HTTP interface to profiling data. Adding\nthe following line will install handlers under the /debug/pprof/\nURL to download live profiles:\n\n```\n\timport _ \"net/http/pprof\"\n\n```\nSee the net/http/pprof package for more details.\n\nProfiles can then be visualized with the pprof tool:\n\n```\n\tgo tool pprof cpu.prof\n\n```\nThere are many commands available from the pprof command line.\nCommonly used commands include \"top\", which prints a summary of the\ntop program hot-spots, and \"web\", which opens an interactive graph\nof hot-spots and their call graphs. Use \"help\" for information on\nall pprof commands.\n\nFor more information about pprof, see\nhttps://github.com/google/pprof/blob/main/doc/README.md.\n\n[pprof on pkg.go.dev](https://pkg.go.dev/runtime/pprof)",
        "isTrusted": true
      },
      "detail": "pprof",
      "insertText": "runtime/pprof",
      "kind": 8
    },
    {
      "label": "testing/iotest",
      "documentation": {
        "value": "Package iotest implements Readers and Writers useful mainly for testing.\n\n[iotest on pkg.go.dev](https://pkg.go.dev/testing/iotest)",
        "isTrusted": true
      },
      "detail": "iotest",
      "insertText": "testing/iotest",
      "kind": 8
    },
    {
      "label": "unicode/utf16",
      "documentation": {
        "value": "Package utf16 implements encoding and decoding of UTF-16 sequences.\n\n[utf16 on pkg.go.dev](https://pkg.go.dev/unicode/utf16)",
        "isTrusted": true
      },
      "detail": "utf16",
      "insertText": "unicode/utf16",
      "kind": 8
    },
    {
      "label": "testing/quick",
      "documentation": {
        "value": "Package quick implements utility functions to help with black box testing.\n\nThe testing/quick package is frozen and is not accepting new features.\n\n[quick on pkg.go.dev](https://pkg.go.dev/testing/quick)",
        "isTrusted": true
      },
      "detail": "quick",
      "insertText": "testing/quick",
      "kind": 8
    },
    {
      "label": "testing/slogtest",
      "documentation": {
        "value": "Package slogtest implements support for testing implementations of log/slog.Handler.\n\n[slogtest on pkg.go.dev](https://pkg.go.dev/testing/slogtest)",
        "isTrusted": true
      },
      "detail": "slogtest",
      "insertText": "testing/slogtest",
      "kind": 8
    },
    {
      "label": "crypto/tls/fipsonly",
      "documentation": {
        "value": "Package fipsonly restricts all TLS configuration to FIPS-approved settings.\n\nThe effect is triggered by importing the package anywhere in a program, as in:\n\n```\n\timport _ \"crypto/tls/fipsonly\"\n\n```\nThis package only exists when using Go compiled with GOEXPERIMENT=boringcrypto.\n\n[fipsonly on pkg.go.dev](https://pkg.go.dev/crypto/tls/fipsonly)",
        "isTrusted": true
      },
      "detail": "fipsonly",
      "insertText": "crypto/tls/fipsonly",
      "kind": 8
    },
    {
      "label": "time/tzdata",
      "documentation": {
        "value": "Package tzdata provides an embedded copy of the timezone database.\nIf this package is imported anywhere in the program, then if\nthe time package cannot find tzdata files on the system,\nit will use this embedded information.\n\nImporting this package will increase the size of a program by about\n450 KB.\n\nThis package should normally be imported by a program's main package,\nnot by a library. Libraries normally shouldn't decide whether to\ninclude the timezone database in a program.\n\nThis package will be automatically imported if you build with\n-tags timetzdata.\n\n[tzdata on pkg.go.dev](https://pkg.go.dev/time/tzdata)",
        "isTrusted": true
      },
      "detail": "tzdata",
      "insertText": "time/tzdata",
      "kind": 8
    },
    {
      "label": "testing/fstest",
      "documentation": {
        "value": "Package fstest implements support for testing implementations and users of file systems.\n\n[fstest on pkg.go.dev](https://pkg.go.dev/testing/fstest)",
        "isTrusted": true
      },
      "detail": "fstest",
      "insertText": "testing/fstest",
      "kind": 8
    },
    {
      "label": "crypto/x509/pkix",
      "documentation": {
        "value": "Package pkix contains shared, low level structures used for ASN.1 parsing\nand serialization of X.509 certificates, CRL and OCSP.\n\n[pkix on pkg.go.dev](https://pkg.go.dev/crypto/x509/pkix)",
        "isTrusted": true
      },
      "detail": "pkix",
      "insertText": "crypto/x509/pkix",
      "kind": 8
    },
    {
      "label": "unicode/utf8",
      "documentation": {
        "value": "Package utf8 implements functions and constants to support text encoded in\nUTF-8. It includes functions to translate between runes and UTF-8 byte sequences.\nSee https://en.wikipedia.org/wiki/UTF-8\n\n[utf8 on pkg.go.dev](https://pkg.go.dev/unicode/utf8)",
        "isTrusted": true
      },
      "detail": "utf8",
      "insertText": "unicode/utf8",
      "kind": 8
    },
    {
      "label": "image/color/palette",
      "documentation": {
        "value": "Package palette provides standard color palettes.\n\n[palette on pkg.go.dev](https://pkg.go.dev/image/color/palette)",
        "isTrusted": true
      },
      "detail": "palette",
      "insertText": "image/color/palette",
      "kind": 8
    },
    {
      "label": "database/sql/driver",
      "documentation": {
        "value": "Package driver defines interfaces to be implemented by database\ndrivers as used by package sql.\n\nMost code should use the [database/sql] package.\n\nThe driver interface has evolved over time. Drivers should implement\n[Connector] and [DriverContext] interfaces.\nThe Connector.Connect and Driver.Open methods should never return [ErrBadConn].\n[ErrBadConn] should only be returned from [Validator], [SessionResetter], or\na query method if the connection is already in an invalid (e.g. closed) state.\n\nAll [Conn] implementations should implement the following interfaces:\n[Pinger], [SessionResetter], and [Validator].\n\nIf named parameters or context are supported, the driver's [Conn] should implement:\n[ExecerContext], [QueryerContext], [ConnPrepareContext], and [ConnBeginTx].\n\nTo support custom data types, implement [NamedValueChecker]. [NamedValueChecker]\nalso allows queries to accept per-query options as a parameter by returning\n[ErrRemoveArgument] from CheckNamedValue.\n\nIf multiple result sets are supported, [Rows] should implement [RowsNextResultSet].\nIf the driver knows how to describe the types present in the returned result\nit should implement the following interfaces: [RowsColumnTypeScanType],\n[RowsColumnTypeDatabaseTypeName], [RowsColumnTypeLength], [RowsColumnTypeNullable],\nand [RowsColumnTypePrecisionScale]. A given row value may also return a [Rows]\ntype, which may represent a database cursor value.\n\nIf a [Conn] implements [Validator], then the IsValid method is called\nbefore returning the connection to the connection pool. If an entry in the\nconnection pool implements [SessionResetter], then ResetSession\nis called before reusing the connection for another query. If a connection is\nnever returned to the connection pool but is immediately reused, then\nResetSession is called prior to reuse but IsValid is not called.\n\n[driver on pkg.go.dev](https://pkg.go.dev/database/sql/driver)",
        "isTrusted": true
      },
      "detail": "driver",
      "insertText": "database/sql/driver",
      "kind": 8
    },
    {
      "label": "net/http/cookiejar",
      "documentation": {
        "value": "Package cookiejar implements an in-memory RFC 6265-compliant http.CookieJar.\n\n[cookiejar on pkg.go.dev](https://pkg.go.dev/net/http/cookiejar)",
        "isTrusted": true
      },
      "detail": "cookiejar",
      "insertText": "net/http/cookiejar",
      "kind": 8
    },
    {
      "label": "net/http/fcgi",
      "documentation": {
        "value": "Package fcgi implements the FastCGI protocol.\n\nSee https://fast-cgi.github.io/ for an unofficial mirror of the\noriginal documentation.\n\nCurrently only the responder role is supported.\n\n[fcgi on pkg.go.dev](https://pkg.go.dev/net/http/fcgi)",
        "isTrusted": true
      },
      "detail": "fcgi",
      "insertText": "net/http/fcgi",
      "kind": 8
    },
    {
      "label": "net/http/httptest",
      "documentation": {
        "value": "Package httptest provides utilities for HTTP testing.\n\n[httptest on pkg.go.dev](https://pkg.go.dev/net/http/httptest)",
        "isTrusted": true
      },
      "detail": "httptest",
      "insertText": "net/http/httptest",
      "kind": 8
    },
    {
      "label": "net/http/httptrace",
      "documentation": {
        "value": "Package httptrace provides mechanisms to trace the events within\nHTTP client requests.\n\n[httptrace on pkg.go.dev](https://pkg.go.dev/net/http/httptrace)",
        "isTrusted": true
      },
      "detail": "httptrace",
      "insertText": "net/http/httptrace",
      "kind": 8
    },
    {
      "label": "net/http/cgi",
      "documentation": {
        "value": "Package cgi implements CGI (Common Gateway Interface) as specified\nin RFC 3875.\n\nNote that using CGI means starting a new process to handle each\nrequest, which is typically less efficient than using a\nlong-running server. This package is intended primarily for\ncompatibility with existing systems.\n\n[cgi on pkg.go.dev](https://pkg.go.dev/net/http/cgi)",
        "isTrusted": true
      },
      "detail": "cgi",
      "insertText": "net/http/cgi",
      "kind": 8
    },
    {
      "label": "math/rand/v2",
      "documentation": {
        "value": "Package rand implements pseudo-random number generators suitable for tasks\nsuch as simulation, but it should not be used for security-sensitive work.\n\nRandom numbers are generated by a [Source], usually wrapped in a [Rand].\nBoth types should be used by a single goroutine at a time: sharing among\nmultiple goroutines requires some kind of synchronization.\n\nTop-level functions, such as [Float64] and [Int],\nare safe for concurrent use by multiple goroutines.\n\nThis package's outputs might be easily predictable regardless of how it's\nseeded. For random numbers suitable for security-sensitive work, see the\ncrypto/rand package.\n\n[rand on pkg.go.dev](https://pkg.go.dev/math/rand/v2)",
        "isTrusted": true
      },
      "detail": "rand",
      "insertText": "math/rand/v2",
      "kind": 8
    },
    {
      "label": "net/rpc/jsonrpc",
      "documentation": {
        "value": "Package jsonrpc implements a JSON-RPC 1.0 ClientCodec and ServerCodec\nfor the rpc package.\nFor JSON-RPC 2.0 support, see https://godoc.org/?q=json-rpc+2.0\n\n[jsonrpc on pkg.go.dev](https://pkg.go.dev/net/rpc/jsonrpc)",
        "isTrusted": true
      },
      "detail": "jsonrpc",
      "insertText": "net/rpc/jsonrpc",
      "kind": 8
    },
    {
      "label": "go/doc/comment",
      "documentation": {
        "value": "Package comment implements parsing and reformatting of Go doc comments,\n(documentation comments), which are comments that immediately precede\na top-level declaration of a package, const, func, type, or var.\n\nGo doc comment syntax is a simplified subset of Markdown that supports\nlinks, headings, paragraphs, lists (without nesting), and preformatted text blocks.\nThe details of the syntax are documented at https://go.dev/doc/comment.\n\nTo parse the text associated with a doc comment (after removing comment markers),\nuse a [Parser]:\n\n```\n\tvar p comment.Parser\n\tdoc := p.Parse(text)\n\n```\nThe result is a [*Doc].\nTo reformat it as a doc comment, HTML, Markdown, or plain text,\nuse a [Printer]:\n\n```\n\tvar pr comment.Printer\n\tos.Stdout.Write(pr.Text(doc))\n\n```\nThe [Parser] and [Printer] types are structs whose fields can be\nmodified to customize the operations.\nFor details, see the documentation for those types.\n\nUse cases that need additional control over reformatting can\nimplement their own logic by inspecting the parsed syntax itself.\nSee the documentation for [Doc], [Block], [Text] for an overview\nand links to additional types.\n\n[comment on pkg.go.dev](https://pkg.go.dev/go/doc/comment)",
        "isTrusted": true
      },
      "detail": "comment",
      "insertText": "go/doc/comment",
      "kind": 8
    },
    {
      "label": "net/http/httputil",
      "documentation": {
        "value": "Package httputil provides HTTP utility functions, complementing the\nmore common ones in the net/http package.\n\n[httputil on pkg.go.dev](https://pkg.go.dev/net/http/httputil)",
        "isTrusted": true
      },
      "detail": "httputil",
      "insertText": "net/http/httputil",
      "kind": 8
    },
    {
      "label": "net/http/pprof",
      "documentation": {
        "value": "Package pprof serves via its HTTP server runtime profiling data\nin the format expected by the pprof visualization tool.\n\nThe package is typically only imported for the side effect of\nregistering its HTTP handlers.\nThe handled paths all begin with /debug/pprof/.\n\nTo use pprof, link this package into your program:\n\n```\n\timport _ \"net/http/pprof\"\n\n```\nIf your application is not already running an http server, you\nneed to start one. Add \"net/http\" and \"log\" to your imports and\nthe following code to your main function:\n\n```\n\tgo func() {\n\t\tlog.Println(http.ListenAndServe(\"localhost:6060\", nil))\n\t}()\n\n```\nBy default, all the profiles listed in [runtime/pprof.Profile] are\navailable (via [Handler]), in addition to the [Cmdline], [Profile], [Symbol],\nand [Trace] profiles defined in this package.\nIf you are not using DefaultServeMux, you will have to register handlers\nwith the mux you are using.\n\n# Parameters\n\nParameters can be passed via GET query params:\n\n```\n  - debug=N (all profiles): response format: N = 0: binary (default), N \u003e 0: plaintext\n  - gc=N (heap profile): N \u003e 0: run a garbage collection cycle before profiling\n  - seconds=N (allocs, block, goroutine, heap, mutex, threadcreate profiles): return a delta profile\n  - seconds=N (cpu (profile), trace profiles): profile for the given duration\n\n```\n# Usage examples\n\nUse the pprof tool to look at the heap profile:\n\n```\n\tgo tool pprof http://localhost:6060/debug/pprof/heap\n\n```\nOr to look at a 30-second CPU profile:\n\n```\n\tgo tool pprof http://localhost:6060/debug/pprof/profile?seconds=30\n\n```\nOr to look at the goroutine blocking profile, after calling\n[runtime.SetBlockProfileRate] in your program:\n\n```\n\tgo tool pprof http://localhost:6060/debug/pprof/block\n\n```\nOr to look at the holders of contended mutexes, after calling\n[runtime.SetMutexProfileFraction] in your program:\n\n```\n\tgo tool pprof http://localhost:6060/debug/pprof/mutex\n\n```\nThe package also exports a handler that serves execution trace data\nfor the \"go tool trace\" command. To collect a 5-second execution trace:\n\n```\n\tcurl -o trace.out http://localhost:6060/debug/pprof/trace?seconds=5\n\tgo tool trace trace.out\n\n```\nTo view all available profiles, open http://localhost:6060/debug/pprof/\nin your browser.\n\nFor a study of the facility in action, visit\nhttps://blog.golang.org/2011/06/profiling-go-programs.html.\n\n[pprof on pkg.go.dev](https://pkg.go.dev/net/http/pprof)",
        "isTrusted": true
      },
      "detail": "pprof",
      "insertText": "net/http/pprof",
      "kind": 8
    },
    {
      "label": "go/build/constraint",
      "documentation": {
        "value": "Package constraint implements parsing and evaluation of build constraint lines.\nSee https://golang.org/cmd/go/#hdr-Build_constraints for documentation about build constraints themselves.\n\nThis package parses both the original “// +build” syntax and the “//go:build” syntax that was added in Go 1.17.\nSee https://golang.org/design/draft-gobuild for details about the “//go:build” syntax.\n\n[constraint on pkg.go.dev](https://pkg.go.dev/go/build/constraint)",
        "isTrusted": true
      },
      "detail": "constraint",
      "insertText": "go/build/constraint",
      "kind": 8
    },
    {
      "label": "text/template/parse",
      "documentation": {
        "value": "Package parse builds parse trees for templates as defined by text/template\nand html/template. Clients should use those packages to construct templates\nrather than this one, which provides shared internal data structures not\nintended for general use.\n\n[parse on pkg.go.dev](https://pkg.go.dev/text/template/parse)",
        "isTrusted": true
      },
      "detail": "parse",
      "insertText": "text/template/parse",
      "kind": 8
    }
  ]
}
